import { AppImpl } from './app.js';
import { AssetImpl } from './asset.js';
import { BackendClient, ClientImpl, ClientType, FrontendClient, ServiceClient } from './client.js';
import { ComputeImpl, JobPhase, } from './compute.js';
import { DatabaseImpl } from './database.js';
import { DocumentImpl } from './document.js';
import { Capabilities, GrantImpl } from './grant.js';
import { ApiError, HttpClient } from './http.js';
import { IdentityImpl } from './identity.js';
import { MeterImpl } from './meter.js';
import { PermissionImpl } from './permission.js';
import { TokenProvider, PARCEL_RUNTIME_AUD } from './token.js';
import { TokenImpl } from './tokenization.js';
export { ApiError, BackendClient, Capabilities, ClientType, FrontendClient, JobPhase, PARCEL_RUNTIME_AUD, ServiceClient, };
/**
 * Example:
 * ```ts
 * import Parcel from '@oasislabs/parcel';
 * const parcel = new Parcel({
 *   clientId: serviceClientId,
 *   privateKey: serviceClientPrivateKey,
 * });
 * console.log(await parcel.searchDocuments());
 * ```
 *
 * @category Main
 */
export class Parcel {
    constructor(tokenSource, config) {
        const tokenProvider = TokenProvider.fromSource(tokenSource);
        this.client = new HttpClient(tokenProvider, {
            apiUrl: config === null || config === void 0 ? void 0 : config.apiUrl,
            storageUrl: config === null || config === void 0 ? void 0 : config.storageUrl,
            httpClientConfig: config === null || config === void 0 ? void 0 : config.httpClientConfig,
        });
    }
    get apiUrl() {
        return this.client.apiUrl;
    }
    async createIdentity(params) {
        return IdentityImpl.create(this.client, params);
    }
    async getCurrentIdentity() {
        if (!this.currentIdentity) {
            this.currentIdentity = await IdentityImpl.current(this.client);
        }
        return this.currentIdentity;
    }
    async createDatabase(params) {
        return DatabaseImpl.create(this.client, params);
    }
    async getDatabase(id) {
        return DatabaseImpl.get(this.client, id);
    }
    async updateDatabase(id, params) {
        return DatabaseImpl.update(this.client, id, params);
    }
    async queryDatabase(id, params) {
        return DatabaseImpl.query(this.client, id, params);
    }
    async listDatabases(params) {
        return DatabaseImpl.list(this.client, params);
    }
    async deleteDatabase(id) {
        return DatabaseImpl.delete_(this.client, id);
    }
    uploadDocument(data, params) {
        return DocumentImpl.upload(this.client, data, params);
    }
    async getDocument(id) {
        return DocumentImpl.get(this.client, id);
    }
    async searchDocuments(params) {
        return DocumentImpl.search(this.client, params);
    }
    downloadDocument(id) {
        return DocumentImpl.download(this.client, id);
    }
    async getDocumentHistory(id, filter) {
        return DocumentImpl.history(this.client, id, filter);
    }
    async updateDocument(id, update) {
        return DocumentImpl.update(this.client, id, update);
    }
    async deleteDocument(id) {
        return DocumentImpl.delete_(this.client, id);
    }
    async createApp(params) {
        return AppImpl.create(this.client, params);
    }
    async getApp(id) {
        return AppImpl.get(this.client, id);
    }
    async listApps(filter) {
        return AppImpl.list(this.client, filter);
    }
    async updateApp(id, update) {
        return AppImpl.update(this.client, id, update);
    }
    async deleteApp(id) {
        return AppImpl.delete_(this.client, id);
    }
    async createPermission(appId, params) {
        return PermissionImpl.create(this.client, appId, params);
    }
    async listPermissions(appId, filter) {
        return PermissionImpl.list(this.client, appId, filter);
    }
    async deletePermission(appId, permissionId) {
        return PermissionImpl.delete_(this.client, appId, permissionId);
    }
    async createClient(appId, params) {
        return ClientImpl.create(this.client, appId, params);
    }
    async getClient(appId, clientId) {
        return ClientImpl.get(this.client, appId, clientId);
    }
    async listClients(appId, filter) {
        return ClientImpl.list(this.client, appId, filter);
    }
    async updateClient(appId, clientId, update) {
        return ClientImpl.update(this.client, appId, clientId, update);
    }
    async deleteClient(appId, clientId) {
        return ClientImpl.delete_(this.client, appId, clientId);
    }
    async createGrant(params) {
        return GrantImpl.create(this.client, params);
    }
    async getGrant(id) {
        return GrantImpl.get(this.client, id);
    }
    async listGrants(filter) {
        return GrantImpl.list(this.client, filter);
    }
    async deleteGrant(id) {
        return GrantImpl.delete_(this.client, id);
    }
    /**
     * Enqueues a new job.
     * @param spec Specification for the job to enqueue.
     * @result Job The new job, including a newly-assigned ID.
     */
    async submitJob(spec) {
        return ComputeImpl.submitJob(this.client, spec);
    }
    /**
     * Lists all known jobs visible to the current user.
     * @param filter Controls pagination.
     * @result Job Lists known jobs. Includes recently completed jobs.
     */
    async listJobs(filter = {}) {
        return ComputeImpl.listJobs(this.client, filter);
    }
    /**
     * Returns the full description of a known job, including its status.
     */
    async getJob(jobId) {
        return ComputeImpl.getJob(this.client, jobId);
    }
    /**
     * Returns the status of the job. This method is faster than `getJob()` and throws if the
     * job status is unknown. This makes it well suited for status polling.
     */
    async getJobStatus(jobId) {
        return ComputeImpl.getJobStatus(this.client, jobId);
    }
    /**
     * Schedules the job for eventual termination/deletion. The job will be terminated at some point in the future on a best-effort basis.
     * It is not an error to request to terminate an already-terminated or non-existing job.
     * @param jobId The unique identifier of the job.
     */
    async terminateJob(jobId) {
        return ComputeImpl.terminateJob(this.client, jobId);
    }
    /**
     * Gets a metering report for your API usage.
     * @param filter Controls API usage window.
     */
    async getUsage(filter) {
        return MeterImpl.getUsage(this.client, filter);
    }
    /**
     * Gets your monthly API usage quota limits.
     */
    async getQuota() {
        return MeterImpl.getQuota(this.client);
    }
    /**
     * Updates your monthly API usage quota limits.
     * @param params Specifies monthly quota limits to enforce until you change them again.
     */
    async setQuota(params) {
        return MeterImpl.setQuota(this.client, params);
    }
    // Tokenization
    /** Returns the amount of the token held by the identity. */
    async getTokenBalance(identityId, tokenId) {
        return IdentityImpl.getTokenBalance(this.client, identityId, tokenId);
    }
    /** Mints a new token. */
    async mintToken(params) {
        return TokenImpl.mint(this.client, params);
    }
    /** Returns information about a token. */
    async getToken(tokenId) {
        return TokenImpl.get(this.client, tokenId);
    }
    async searchTokens(filter) {
        return TokenImpl.search(this.client, filter);
    }
    /** Returns information about an asset held by the escrow identity. */
    async searchEscrowedAssets(filter) {
        return AssetImpl.search(this.client, filter);
    }
    /** Returns information about an asset held by the escrow identity. */
    async getEscrowedAsset(assetId) {
        return AssetImpl.get(this.client, assetId);
    }
    async transferToken(tokenId, amount, recipient) {
        return TokenImpl.transfer(this.client, tokenId, amount, recipient);
    }
    async getTransferReceipt(recieptId) {
        return TokenImpl.getTransferReceipt(this.client, recieptId);
    }
}
export default Parcel;
//# sourceMappingURL=index.js.map