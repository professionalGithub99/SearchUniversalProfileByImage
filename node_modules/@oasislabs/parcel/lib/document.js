var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Document_client;
import EventEmitter from 'eventemitter3';
import FormData from 'form-data';
import { makePage } from './model.js';
export class Document {
    constructor(client, pod) {
        _Document_client.set(this, void 0);
        __classPrivateFieldSet(this, _Document_client, client, "f");
        this.id = pod.id;
        this.createdAt = new Date(pod.createdAt);
        this.creator = pod.creator;
        this.owner = pod.owner;
        this.size = pod.size;
        this.details = pod.details;
        this.originatingJob = pod.originatingJob;
    }
    /**
     * Downloads the private data referenced by the document if the authorized identity
     * has been granted access.
     * @returns the decrypted data as a pipeable stream and AsyncIterable
     */
    download() {
        return DocumentImpl.download(__classPrivateFieldGet(this, _Document_client, "f"), this.id);
    }
    async update(params) {
        Object.assign(this, await DocumentImpl.update(__classPrivateFieldGet(this, _Document_client, "f"), this.id, params));
        return this;
    }
    async delete() {
        return DocumentImpl.delete_(__classPrivateFieldGet(this, _Document_client, "f"), this.id);
    }
    async history(filter) {
        return DocumentImpl.history(__classPrivateFieldGet(this, _Document_client, "f"), this.id, filter);
    }
}
_Document_client = new WeakMap();
export var DocumentImpl;
(function (DocumentImpl) {
    async function get(client, id) {
        const podDocument = await client.get(endpointForId(id));
        return new Document(client, podDocument);
    }
    DocumentImpl.get = get;
    async function search(client, params) {
        const podPage = await client.search(DOCUMENTS_EP, params);
        return makePage(Document, podPage, client);
    }
    DocumentImpl.search = search;
    function upload(client, data, params) {
        return new Upload(client, data, params !== null && params !== void 0 ? params : undefined);
    }
    DocumentImpl.upload = upload;
    function download(client, id) {
        return client.download(endpointForId(id) + '/download');
    }
    DocumentImpl.download = download;
    async function history(client, id, filter) {
        const podPage = await client.get(endpointForId(id) + '/history', filter);
        const results = podPage.results.map((podAccessEvent) => ({
            createdAt: new Date(podAccessEvent.createdAt),
            document: podAccessEvent.document,
            accessor: podAccessEvent.accessor,
        }));
        return {
            results,
            nextPageToken: podPage.nextPageToken,
        };
    }
    DocumentImpl.history = history;
    async function update(client, id, params) {
        const podDocument = await client.update(endpointForId(id), params);
        return new Document(client, podDocument);
    }
    DocumentImpl.update = update;
    async function delete_(client, id) {
        return client.delete(endpointForId(id));
    }
    DocumentImpl.delete_ = delete_;
})(DocumentImpl || (DocumentImpl = {}));
const DOCUMENTS_EP = 'documents';
const endpointForId = (id) => `${DOCUMENTS_EP}/${id}`;
/**
 * An `Upload` is the result of calling `parcel.uploadDocument`.
 *
 * During upload, emits `progress` events, each with a `ProgressEvent` as its argument.
 *
 * When the document has been uploaded, the `finish` event is emitted with the `Document`
 * reference as its argument.
 */
export class Upload extends EventEmitter {
    constructor(client, data, sdkParams) {
        var _a, _b;
        super();
        this.abortController = new AbortController();
        const form = new FormData();
        const appendPart = (name, data, contentType, length) => {
            if (typeof Blob === 'undefined') {
                // If Blob isn't present, we're likely in Node and should use the `form-data` API.
                form.append(name, data, {
                    contentType,
                    knownLength: length,
                });
            }
            else {
                // If `Blob` exists, we're probably in the browser and will prefer to use it.
                if (typeof data === 'string' || data instanceof Uint8Array) {
                    data = new Blob([data], { type: contentType });
                }
                else if ('pipe' in data) {
                    throw new TypeError('uploaded data must of type `Storable`');
                }
                form.append(name, data);
            }
        };
        if (sdkParams) {
            const { toApp, ...parcelParams } = sdkParams;
            if (toApp) {
                parcelParams.details = {
                    ...parcelParams.details,
                    tags: [...((_b = (_a = parcelParams === null || parcelParams === void 0 ? void 0 : parcelParams.details) === null || _a === void 0 ? void 0 : _a.tags) !== null && _b !== void 0 ? _b : []), `to-app-${toApp}`],
                };
            }
            const paramsString = JSON.stringify(parcelParams);
            appendPart('metadata', paramsString, 'application/json', paramsString.length);
        }
        appendPart('data', data, 'application/octet-stream', data.length);
        client
            .upload(form, {
            headers: 'getHeaders' in form ? /* node */ form.getHeaders() : undefined,
            signal: this.abortController.signal,
            timeout: false,
        })
            // eslint-disable-next-line promise/prefer-await-to-then
            .then((podDocument) => {
            this.emit('finish', new Document(client, podDocument));
        })
            // eslint-disable-next-line promise/prefer-await-to-then
            .catch((error) => {
            this.emit('error', error);
        });
    }
    /** Aborts the upload. Emits an `abort` event and sets the `aborted` flag. */
    abort() {
        this.abortController.abort();
        this.emit('abort');
    }
    get aborted() {
        return this.abortController.signal.aborted;
    }
    /**
     * @returns a `Promise` that resolves when the upload stream has finished.
     */
    get finished() {
        return new Promise((resolve, reject) => {
            this.on('finish', resolve);
            this.on('error', reject);
        });
    }
}
//# sourceMappingURL=document.js.map