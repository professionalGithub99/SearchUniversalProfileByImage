import type { Except, Opaque } from 'type-fest';
import type { AccessContext, AssetId, EscrowedAsset, EscrowedAssetSearchParams } from './asset.js';
import type { Condition } from './condition.js';
import type { Capabilities } from './grant.js';
import type { HttpClient } from './http.js';
import type { IdentityId } from './identity.js';
import type { Model, Page, PageParams, PODModel, ResourceId } from './model.js';
export declare type TokenId = Opaque<ResourceId, 'TokenId'>;
export declare type TransferReceiptId = Opaque<ResourceId, 'TransferReceiptId'>;
export declare type PODToken = Readonly<PODModel & {
    creator: string;
    name?: string;
    grant: TokenGrantSpec;
    supply: number;
    consumesAssets: boolean;
    ethBridge: EthBridge;
}>;
export declare class Token implements Model {
    #private;
    readonly id: TokenId;
    readonly creator: IdentityId;
    readonly createdAt: Date;
    readonly name?: string;
    readonly grant: TokenGrantSpec;
    readonly supply: number;
    readonly consumesAssets: boolean;
    readonly ethBridge: EthBridge;
    constructor(client: HttpClient, pod: PODToken);
    delete(): Promise<void>;
    searchAssets(filter?: Except<EscrowedAssetSearchParams, 'token'> & PageParams): Promise<Page<EscrowedAsset>>;
    /**
     * Adds an asset to this token.
     * The asset must be held by the escrow identity and not have been consumed by another token.
     */
    addAsset(asset: AssetId): Promise<TokenizationReceipt>;
    /**
     * Removes an asset from this token. You must hold the entire supply of the token to do this.
     * If this token previously consumed the asset, it will again become available to tokenize.
     */
    removeAsset(asset: AssetId): Promise<void>;
    transfer(amount: number, recipient: IdentityId): Promise<TransferReceipt>;
    listTransfers(filter?: ListTokenTransfersFilter & PageParams): Promise<Page<TransferReceipt>>;
}
export declare namespace TokenImpl {
    function mint(client: HttpClient, params: TokenCreateParams): Promise<Token>;
    function get(client: HttpClient, id: TokenId): Promise<Token>;
    function delete_(client: HttpClient, id: TokenId): Promise<void>;
    function search(client: HttpClient, params?: TokenSearchParams & PageParams): Promise<Page<Token>>;
    function addAsset(client: HttpClient, token: TokenId, asset: AssetId): Promise<TokenizationReceipt>;
    function removeAsset(client: HttpClient, token: TokenId, asset: AssetId): Promise<void>;
    function transfer(client: HttpClient, token: TokenId, amount: number, recipient: IdentityId): Promise<TransferReceipt>;
    function listTransferReceipts(client: HttpClient, tokenId: TokenId, filter?: ListTokenTransfersFilter & PageParams): Promise<Page<TransferReceipt>>;
    function getTransferReceipt(client: HttpClient, receipt: TransferReceiptId, token?: TokenId): Promise<TransferReceipt>;
}
export declare type TokenCreateParams = {
    name?: string;
    grant: TokenGrantSpec;
    supply: number;
    consumesAssets?: boolean;
    ethBridge?: EthBridge;
};
export declare type TokenGrantSpec = {
    condition?: Condition | null;
    capabilities?: Capabilities;
};
export declare type TokenBalance = {
    id: TokenId;
    balance: number;
};
export declare type EthAddr = string;
export declare namespace EthBridge {
    type Managed = {
        type: 'managed';
    };
    type ERC20 = {
        type: 'erc20';
        address: EthAddr;
        gas: EthBridgeGasParams;
    };
    type ERC721 = {
        type: 'erc721';
        address: EthAddr;
        gas: EthBridgeGasParams;
        /** Hex-encoded U256. */
        optionId: string;
    };
    type ERC1155 = {
        type: 'erc1155';
        address: EthAddr;
        gas: EthBridgeGasParams;
        /** Hex-encoded U256. */
        optionId: string;
    };
}
export declare type EthBridge = EthBridge.Managed | EthBridge.ERC20 | EthBridge.ERC721 | EthBridge.ERC1155;
export declare type EthBridgeType = 'managed' | 'erc20' | 'erc721' | 'erc1155';
export declare type EthBridgeGasParams = {
    limit: number;
    price: 'slow' | 'standard' | 'fast';
};
export declare type TokenSearchParams = {
    /** Search for tokens held by this identity. */
    heldBy?: IdentityId;
    containsAsset?: {
        selectedByCondition?: Condition;
        accessibleInContext?: AccessContext;
    };
};
export declare type TokenizationReceipt = {
    asset: AssetId;
    token: TokenId;
    consumed: boolean;
};
export declare type TransferReceipt = {
    id: TransferReceiptId;
    completedAt: Date;
    token: TokenId;
    amount: number;
    sender: IdentityId;
    recipient: IdentityId;
    /** The transaction hash of the Ethereum transaction that triggered this transfer. */
    bridgeTxId?: string;
};
export declare type PODTransferReceipt = Except<TransferReceipt, 'completedAt'> & {
    completedAt: string;
};
export declare type ListTokenTransfersFilter = {
    sender?: IdentityId;
    recipient?: IdentityId;
    /** Transfers completed after this time. */
    after?: Date;
    /** Transfers completed before this time. */
    before?: Date;
};
//# sourceMappingURL=tokenization.d.ts.map