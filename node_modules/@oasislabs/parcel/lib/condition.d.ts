import type { Primitive } from 'type-fest';
import type { InputDocumentSpec as $InputDocumentSpec, OutputDocumentSpec as $OutputDocumentSpec } from './compute.js';
import type { DatabaseId as $DatabaseId } from './database.js';
import type { DocumentId as $DocumentId } from './document.js';
import type { IdentityId as $IdentityId } from './identity.js';
export declare namespace Selectors {
    type IdentityId = {
        'identity.id': RelationalOp<$IdentityId>;
    };
    type DocumentId = {
        'document.id': RelationalOp<$DocumentId>;
    };
    type DocumentCreator = {
        'document.creator': RelationalOp<$IdentityId>;
    };
    type DocumentOwner = {
        'document.owner': RelationalOp<$IdentityId>;
    };
    type DocumentTitle = {
        'document.title': RelationalOp<string>;
    };
    type DocumentTags = {
        'document.tags': SetOp<string>;
    };
    type Document = DocumentId | DocumentCreator | DocumentOwner | DocumentTitle | DocumentTags;
    type DatabaseId = {
        'database.id': RelationalOp<$DatabaseId>;
    };
    type DatabaseCreator = {
        'database.creator': RelationalOp<$IdentityId>;
    };
    type DatabaseOwner = {
        'database.owner': RelationalOp<$IdentityId>;
    };
    type DatabaseName = {
        'database.name': RelationalOp<string>;
    };
    type Database = DatabaseId | DatabaseCreator | DatabaseOwner | DatabaseName;
    type JobImage = {
        'job.spec.image': RelationalOp<string>;
    };
    type JobInputs = {
        'job.spec.inputs': RelationalOp<$InputDocumentSpec>;
    };
    type JobOutputs = {
        'job.spec.outputs': RelationalOp<$OutputDocumentSpec>;
    };
    type Job = JobImage | JobInputs | JobOutputs;
    type AccessTime = {
        accessTime: RelationalOp<string>;
    };
    type WorkerId = {
        'worker.id': RelationalOp<$IdentityId>;
    };
    type WorkerVersion = {
        'worker.version': RelationalOp<string>;
    };
}
export declare type Selector = Selectors.IdentityId | Selectors.Database | Selectors.Document | Selectors.Job | Selectors.AccessTime;
export declare namespace LogicalOps {
    type And = {
        $and: Condition[];
    };
    type Or = {
        $or: Condition[];
    };
    type Nor = {
        $nor: Condition[];
    };
    type Not = {
        $not: Condition;
    };
}
export declare type LogicalOp = LogicalOps.And | LogicalOps.Or | LogicalOps.Nor | LogicalOps.Not;
export declare type Condition = Selector | LogicalOp;
export declare namespace RelationalOp {
    type Eq<T = Primitive> = {
        $eq: T;
    };
    type Neq<T = Primitive> = {
        $ne: T;
    };
    type Geq<T = Comparable> = {
        $gte: T;
    };
    type Gt<T = Comparable> = {
        $gt: T;
    };
    type Leq<T = Comparable> = {
        $lte: T;
    };
    type Lt<T = Comparable> = {
        $lt: T;
    };
    type In<T = Primitive> = {
        $in: T[];
    };
    type Nin<T = Primitive> = {
        $nin: T[];
    };
}
declare type Comparable = number | Date;
declare type RelationalOp<T> = RelationalOp.Eq<T> | RelationalOp.Neq<T> | RelationalOp.Geq<T> | RelationalOp.Gt<T> | RelationalOp.Leq<T> | RelationalOp.Lt<T> | RelationalOp.In<T> | RelationalOp.Nin<T>;
export declare namespace ArrayOps {
    type Any<T = Primitive> = {
        $any: RelationalOp<T>;
    };
    type All<T = Primitive> = {
        $all: RelationalOp<T>;
    };
    type Len<T = Primitive> = {
        $size: RelationalOp<T>;
    };
}
export declare type ArrayOp<T> = ArrayOps.Any<T> | ArrayOps.All<T> | ArrayOps.Len<T>;
export declare namespace SetOps {
    type Contains<T = Primitive> = {
        $contains: T;
    };
    type Intersects<T = Primitive> = {
        $intersects: T[];
    };
    type Superset<T = Primitive> = {
        $superset: T[];
    };
    type Subset<T = Primitive> = {
        $subset: T[];
    };
    type Values<T = Primitive> = {
        $values: ArrayOp<T>;
    };
    type Len<T = Primitive> = {
        $size: RelationalOp<T>;
    };
}
export declare type SetOp<T> = SetOps.Contains<T> | SetOps.Intersects<T> | SetOps.Superset<T> | SetOps.Subset<T> | SetOps.Values<T> | SetOps.Len<T>;
export {};
//# sourceMappingURL=condition.d.ts.map