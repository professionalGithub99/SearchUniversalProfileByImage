var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Identity_client;
import { Grant } from './grant.js';
import { Permission } from './permission.js';
const IDENTITIES_EP = 'identities';
const IDENTITIES_ME = `${IDENTITIES_EP}/me`;
const endpointForId = (id) => `${IDENTITIES_EP}/${id}`;
const endpointForPermissions = (id) => `${endpointForId(id)}/permissions`;
const endpointForPermission = (identityId, permissionId) => `${endpointForPermissions(identityId)}/${permissionId}`;
const endpointForLinkedEthAddrs = (id) => `${endpointForId(id)}/links/ethereum`;
const endpointForLinkedEthAddr = (id, ethAddr) => `${endpointForLinkedEthAddrs(id)}/links/ethereum/${ethAddr}`;
const endpointForTokens = (id) => `${endpointForId(id)}/tokens`;
const endpointForToken = (id, token) => `${endpointForTokens(id)}/tokens/${token}`;
export class Identity {
    constructor(client, pod) {
        _Identity_client.set(this, void 0);
        __classPrivateFieldSet(this, _Identity_client, client, "f");
        this.id = pod.id;
        this.createdAt = new Date(pod.createdAt);
        this.tokenVerifiers = pod.tokenVerifiers;
    }
    async update(params) {
        Object.assign(this, await IdentityImpl.update(__classPrivateFieldGet(this, _Identity_client, "f"), this.id, params));
        return this;
    }
    async delete() {
        return IdentityImpl.delete_(__classPrivateFieldGet(this, _Identity_client, "f"), this.id);
    }
    /** Links an Ethereum address to this Parcel identity.
     * `ethAddr` - the '0x' prefixed, hex-encoded Eth address (e.g., `web3.eth.accounts[0]`).
     * `proof` - (optional) the signature produced by web3's `personal_sign` over the string
     *           `parcel identity = <your identity id>`. If left unspecified, this library will
     *           attempt to make the signature using the global web3 provider.
     */
    async linkEthereumAddress(ethAddr, proof) {
        return IdentityImpl.linkEthereumAddress(__classPrivateFieldGet(this, _Identity_client, "f"), this.id, ethAddr, proof);
    }
    async unlinkEthereumAddress(ethAddr) {
        return IdentityImpl.unlinkEthereumAddress(__classPrivateFieldGet(this, _Identity_client, "f"), this.id, ethAddr);
    }
    async listLinkedEthereumAddresses(filter) {
        return IdentityImpl.listLinkedEthereumAddresses(__classPrivateFieldGet(this, _Identity_client, "f"), this.id, filter);
    }
    /** Fetches permissions to which this identity has agreed.  */
    async listGrantedPermissions(filter) {
        return IdentityImpl.listGrantedPermissions(__classPrivateFieldGet(this, _Identity_client, "f"), this.id, filter);
    }
    async grantPermission(id) {
        return IdentityImpl.grantPermission(__classPrivateFieldGet(this, _Identity_client, "f"), this.id, id);
    }
    /** Gets a granted permission by id. Useful for checking if a permission has been granted. */
    async getGrantedPermission(id) {
        return IdentityImpl.getGrantedPermission(__classPrivateFieldGet(this, _Identity_client, "f"), this.id, id);
    }
    async revokePermission(id) {
        return IdentityImpl.revokePermission(__classPrivateFieldGet(this, _Identity_client, "f"), this.id, id);
    }
    // Tokenization
    async listTokens(filter) {
        return IdentityImpl.listHeldTokens(__classPrivateFieldGet(this, _Identity_client, "f"), this.id, filter);
    }
    async getTokenBalance(token) {
        return IdentityImpl.getTokenBalance(__classPrivateFieldGet(this, _Identity_client, "f"), this.id, token);
    }
}
_Identity_client = new WeakMap();
export var IdentityImpl;
(function (IdentityImpl) {
    async function create(client, params) {
        const podIdentity = await client.create(IDENTITIES_EP, params);
        return new Identity(client, podIdentity);
    }
    IdentityImpl.create = create;
    async function current(client) {
        const podIdentity = await client.get(IDENTITIES_ME);
        return new Identity(client, podIdentity);
    }
    IdentityImpl.current = current;
    async function get(client, id) {
        const podIdentity = await client.get(endpointForId(id));
        return new Identity(client, podIdentity);
    }
    IdentityImpl.get = get;
    async function update(client, id, params) {
        const podIdentity = await client.update(endpointForId(id), params);
        return new Identity(client, podIdentity);
    }
    IdentityImpl.update = update;
    async function delete_(client, id) {
        return client.delete(endpointForId(id));
    }
    IdentityImpl.delete_ = delete_;
    async function linkEthereumAddress(client, identity, ethAddr, proof) {
        if (!proof) {
            const { web3 } = globalThis;
            if (!web3) {
                throw new Error('`linkEthereumAddress` must be provided a `proof` when a web3 provider is not present');
            }
            proof = await new Promise((resolve, reject) => {
                const req = {
                    method: 'personal_sign',
                    params: [`parcel identity = ${identity}`, ethAddr],
                    from: ethAddr,
                };
                web3.currentProvider.sendAsync(req, (err, { result }) => {
                    if (err) {
                        reject(err);
                        return;
                    }
                    resolve(result);
                });
            });
        }
        return client.create(endpointForLinkedEthAddrs(identity), { proof });
    }
    IdentityImpl.linkEthereumAddress = linkEthereumAddress;
    async function listLinkedEthereumAddresses(client, identityId, filter) {
        const podPage = await client.get(endpointForLinkedEthAddrs(identityId), filter);
        const results = podPage.results.map(({ address, linkedAt }) => ({
            address,
            linkedAt: new Date(linkedAt),
        }));
        return {
            results,
            nextPageToken: podPage.nextPageToken,
        };
    }
    IdentityImpl.listLinkedEthereumAddresses = listLinkedEthereumAddresses;
    async function unlinkEthereumAddress(client, identity, ethAddr) {
        await client.delete(endpointForLinkedEthAddr(identity, ethAddr));
    }
    IdentityImpl.unlinkEthereumAddress = unlinkEthereumAddress;
    /** Grants permission to an app. */
    async function grantPermission(client, identityId, permissionId) {
        const { grants } = await client.create(endpointForPermission(identityId, permissionId), {});
        return {
            grants: grants.map((g) => new Grant(client, g)),
        };
    }
    IdentityImpl.grantPermission = grantPermission;
    async function listGrantedPermissions(client, identityId, filter) {
        const podPage = await client.get(endpointForPermissions(identityId), filter);
        const results = podPage.results.map((podPermission) => new Permission(client, podPermission));
        return {
            results,
            nextPageToken: podPage.nextPageToken,
        };
    }
    IdentityImpl.listGrantedPermissions = listGrantedPermissions;
    async function getGrantedPermission(client, identityId, permissionId) {
        const podPermission = await client.get(endpointForPermission(identityId, permissionId));
        return new Permission(client, podPermission);
    }
    IdentityImpl.getGrantedPermission = getGrantedPermission;
    async function revokePermission(client, identityId, permissionId) {
        await client.delete(endpointForPermission(identityId, permissionId));
    }
    IdentityImpl.revokePermission = revokePermission;
    async function listHeldTokens(client, identityId, filter) {
        return client.get(endpointForTokens(identityId), filter);
    }
    IdentityImpl.listHeldTokens = listHeldTokens;
    async function getTokenBalance(client, identityId, tokenId) {
        return client.get(endpointForToken(identityId, tokenId));
    }
    IdentityImpl.getTokenBalance = getTokenBalance;
})(IdentityImpl || (IdentityImpl = {}));
//# sourceMappingURL=identity.js.map