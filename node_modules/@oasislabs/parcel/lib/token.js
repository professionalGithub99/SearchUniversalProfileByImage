var _a, _b;
import jsrsasign from 'jsrsasign';
import ky, { HTTPError } from 'ky';
import { appendAsLastBeforeRequest, dontCloneForAfterResponses } from './http.js';
import './polyfill.js'; // eslint-disable-line import/no-unassigned-import
export class TokenError extends HTTPError {
    constructor(request, options, response, 
    // Workaround for https://github.com/sindresorhus/ky/issues/148.
    responseJson) {
        var _a;
        super(response, request, options);
        this.responseJson = responseJson;
        this.name = 'TokenError';
        this.message = (_a = this.responseJson.error_description) !== null && _a !== void 0 ? _a : this.responseJson.error;
    }
}
const tokenKy = ky.create({
    hooks: {
        beforeRequest: [appendAsLastBeforeRequest(dontCloneForAfterResponses())],
        afterResponse: [
            async (req, opts, res) => {
                var _a, _b;
                // Wrap errors, for easier client handling (and maybe better messages).
                const isJson = (_b = (_a = res.headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.startsWith('application/json')) !== null && _b !== void 0 ? _b : false;
                if (!res.ok && isJson) {
                    throw new TokenError(req, opts, res, await res.json());
                }
            },
        ],
    },
});
const DEFAULT_TOKEN_ENDPOINT = ((_b = (_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.process) === null || _a === void 0 ? void 0 : _a.env) === null || _b === void 0 ? void 0 : _b.PARCEL_AUTH_URL)
    ? `${globalThis.process.env.PARCEL_AUTH_URL}/oauth/token`
    : 'https://auth.oasislabs.com/oauth/token';
export const PARCEL_RUNTIME_AUD = 'https://api.oasislabs.com/parcel'; // TODO(#326)
const DEFAULT_SCOPES = ['parcel.full'];
export class TokenProvider {
    static fromSource(source) {
        if (typeof source === 'string')
            return new StaticTokenProvider(source);
        if ('principal' in source)
            return new SelfIssuedTokenProvider(source);
        if ('refreshToken' in source)
            return new RefreshingTokenProvider(source);
        if ('clientId' in source)
            return new RenewingTokenProvider(source);
        throw new Error(`unrecognized \`tokenSource\`: ${JSON.stringify(source)}`);
    }
}
/** A `TokenProvider` hands out OIDC access tokens. */
export class ExpiringTokenProvider {
    static isTokenProvider(thing) {
        return thing && typeof thing.getToken === 'function';
    }
    /** Returns a valid Bearer token to be presented to the Parcel gateway. */
    async getToken() {
        if (this.token === undefined || this.token.isExpired())
            this.token = await this.renewToken();
        return this.token.toString();
    }
}
/** A `TokenProvider` that always returns the same, initially provided token. */
export class StaticTokenProvider {
    constructor(token) {
        this.token = token;
    }
    async getToken() {
        return this.token;
    }
}
/** A `TokenProvider` that obtains a new token by re-authenticating to the issuer. */
export class RenewingTokenProvider extends ExpiringTokenProvider {
    constructor({ clientId, privateKey, scopes, tokenEndpoint, audience, }) {
        super();
        this.clientAssertionLifetime = 1 * 60 * 60; // 1 hour
        if (privateKey.kty !== 'EC') {
            throw new Error('Private key should be an ECDSA key.');
        }
        this.privateKey = privateKey;
        const privateKeyPEM = jwkToPem(privateKey);
        this.privateKeyPEM = privateKeyPEM;
        this.clientId = clientId;
        this.tokenEndpoint = tokenEndpoint !== null && tokenEndpoint !== void 0 ? tokenEndpoint : DEFAULT_TOKEN_ENDPOINT;
        this.audience = audience !== null && audience !== void 0 ? audience : PARCEL_RUNTIME_AUD;
        this.scopes = scopes !== null && scopes !== void 0 ? scopes : DEFAULT_SCOPES;
    }
    async renewToken() {
        const clientAssertion = makeJWT({
            privateKey: this.privateKeyPEM,
            keyId: this.privateKey.kid,
            payload: {
                sub: this.clientId,
                iss: this.clientId,
                aud: this.tokenEndpoint,
                jti: jsrsasign.KJUR.crypto.Util.getRandomHexOfNbytes(8),
            },
            lifetime: this.clientAssertionLifetime,
        });
        const authParams = new URLSearchParams();
        authParams.append('grant_type', 'client_credentials');
        authParams.append('client_assertion', clientAssertion);
        authParams.append('client_assertion_type', 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer');
        authParams.append('scope', this.scopes.join(' '));
        authParams.append('audience', this.audience);
        return Token.fromResponse(tokenKy.post(this.tokenEndpoint, { body: authParams }));
    }
}
/** A `TokenProvider` that obtains a new token using a refresh token. */
export class RefreshingTokenProvider extends ExpiringTokenProvider {
    constructor({ refreshToken, tokenEndpoint, audience }) {
        super();
        this.refreshToken = refreshToken;
        this.tokenEndpoint = tokenEndpoint;
        this.audience = audience;
    }
    async renewToken() {
        const refreshParams = new URLSearchParams();
        refreshParams.append('grant_type', 'refresh_token');
        refreshParams.append('refresh_token', this.refreshToken);
        refreshParams.append('audience', this.audience);
        const res = tokenKy.post(this.tokenEndpoint, { body: refreshParams });
        res
            // eslint-disable-next-line promise/prefer-await-to-then
            .then(async (refreshResponse) => {
            this.refreshToken = (await refreshResponse.clone().json()).refresh_token;
        })
            // eslint-disable-next-line promise/prefer-await-to-then
            .catch(() => {
            // Do nothing. The promise lives on.
        });
        return Token.fromResponse(res);
    }
}
/** A `TokenProvider` that self-signs an access token. */
export class SelfIssuedTokenProvider extends ExpiringTokenProvider {
    constructor({ principal, privateKey, scopes, tokenLifetime, }) {
        super();
        this.privateKey = privateKey;
        const privateKeyPEM = jwkToPem(privateKey);
        this.privateKeyPEM = privateKeyPEM;
        this.principal = principal;
        this.scopes = scopes !== null && scopes !== void 0 ? scopes : DEFAULT_SCOPES;
        this.tokenLifetime = tokenLifetime !== null && tokenLifetime !== void 0 ? tokenLifetime : 1 * 60 * 60 /* one hour */;
    }
    async renewToken() {
        const expiry = Date.now() / 1000 + this.tokenLifetime;
        const token = makeJWT({
            privateKey: this.privateKeyPEM,
            keyId: this.privateKey.kid,
            payload: {
                sub: this.principal,
                iss: this.principal,
                aud: PARCEL_RUNTIME_AUD,
                scope: this.scopes.join(' '),
            },
            lifetime: this.tokenLifetime,
        });
        return new Token(token, expiry);
    }
}
class Token {
    constructor(token, expiry) {
        this.token = token;
        this.expiry = expiry;
    }
    static async fromResponse(response) {
        const requestTime = Date.now();
        const body = await (await response).json();
        return new Token(body.access_token, requestTime + body.expires_in * 1000);
    }
    isExpired() {
        return this.expiry <= Date.now();
    }
    toString() {
        return this.token;
    }
}
/** Returns the PKCS8-encoded private key and the JWK"s key id. */
function jwkToPem(jwk) {
    if (jwk.kty !== 'EC' || jwk.alg !== 'ES256') {
        throw new Error(`Unsupported private key. Expected \`alg: 'ES256'\` but was \`${jwk.alg}\` }`);
    }
    const kjurJWK = JSON.parse(JSON.stringify(jwk));
    kjurJWK.crv = 'secp256r1'; // KJUR's preferred name for name for P-256
    const privateKey = jsrsasign.KEYUTIL.getPEM(jsrsasign.KEYUTIL.getKey(kjurJWK), 'PKCS8PRV'); // The type definitions are wrong: they say `void` but it's actually `string`.
    return privateKey;
}
function makeJWT({ privateKey, keyId, payload, lifetime, }) {
    const header = {
        alg: 'ES256',
        typ: 'JWT',
        kid: keyId,
    };
    const now = Math.floor(Date.now() / 1000);
    payload.iat = now - 2 * 60; // Take off a couple of minutes to account for clock skew.
    payload.exp = now + lifetime;
    return jsrsasign.KJUR.jws.JWS.sign(null, header, payload, privateKey);
}
//# sourceMappingURL=token.js.map