var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Token_client;
import { AssetImpl } from './asset.js';
import { makePage } from './model.js';
const TOKENS_EP = 'tokens';
const RECEIPTS_EP = 'receipts';
const endpointForId = (id) => `${TOKENS_EP}/${id}`;
const endpointForAssets = (token) => `${endpointForId(token)}/assets`;
const endpointForAsset = (token, asset) => `${endpointForAssets(token)}/${asset}`;
const endpointForTransfers = (id) => `${endpointForId(id)}/transfers`;
const endpointForTransfer = (token, receipt) => `${endpointForTransfers(token)}/${receipt}`;
export class Token {
    constructor(client, pod) {
        _Token_client.set(this, void 0);
        __classPrivateFieldSet(this, _Token_client, client, "f");
        this.id = pod.id;
        this.creator = pod.creator;
        this.createdAt = new Date(pod.createdAt);
        this.grant = pod.grant;
        this.supply = pod.supply;
        this.consumesAssets = pod.consumesAssets;
        this.ethBridge = pod.ethBridge;
    }
    async delete() {
        return TokenImpl.delete_(__classPrivateFieldGet(this, _Token_client, "f"), this.id);
    }
    async searchAssets(filter) {
        return AssetImpl.search(__classPrivateFieldGet(this, _Token_client, "f"), {
            ...filter,
            token: this.id,
        });
    }
    /**
     * Adds an asset to this token.
     * The asset must be held by the escrow identity and not have been consumed by another token.
     */
    async addAsset(asset) {
        return TokenImpl.addAsset(__classPrivateFieldGet(this, _Token_client, "f"), this.id, asset);
    }
    /**
     * Removes an asset from this token. You must hold the entire supply of the token to do this.
     * If this token previously consumed the asset, it will again become available to tokenize.
     */
    async removeAsset(asset) {
        return TokenImpl.removeAsset(__classPrivateFieldGet(this, _Token_client, "f"), this.id, asset);
    }
    async transfer(amount, recipient) {
        return TokenImpl.transfer(__classPrivateFieldGet(this, _Token_client, "f"), this.id, amount, recipient);
    }
    async listTransfers(filter) {
        return TokenImpl.listTransferReceipts(__classPrivateFieldGet(this, _Token_client, "f"), this.id, filter);
    }
}
_Token_client = new WeakMap();
export var TokenImpl;
(function (TokenImpl) {
    async function mint(client, params) {
        const podToken = await client.create(TOKENS_EP, params);
        return new Token(client, podToken);
    }
    TokenImpl.mint = mint;
    async function get(client, id) {
        const podToken = await client.get(endpointForId(id));
        return new Token(client, podToken);
    }
    TokenImpl.get = get;
    async function delete_(client, id) {
        return client.delete(endpointForId(id));
    }
    TokenImpl.delete_ = delete_;
    async function search(client, params) {
        const podPage = await client.search(TOKENS_EP, params);
        return makePage(Token, podPage, client);
    }
    TokenImpl.search = search;
    async function addAsset(client, token, asset) {
        return client.post(endpointForAsset(token, asset), undefined);
    }
    TokenImpl.addAsset = addAsset;
    async function removeAsset(client, token, asset) {
        await client.delete(endpointForAsset(token, asset));
    }
    TokenImpl.removeAsset = removeAsset;
    async function transfer(client, token, amount, recipient) {
        if (amount % 1 !== 0 || amount < 0) {
            throw new Error(`invalid token amount ${amount}. must be a positive integer`);
        }
        const podReceipt = await client.post(endpointForTransfers(token), {
            recipient,
            amount,
        });
        return {
            ...podReceipt,
            completedAt: new Date(podReceipt.completedAt),
        };
    }
    TokenImpl.transfer = transfer;
    async function listTransferReceipts(client, tokenId, filter) {
        const podPage = await client.get(endpointForTransfers(tokenId), filter);
        return {
            ...podPage,
            results: podPage.results.map((podReceipt) => ({
                ...podReceipt,
                completedAt: new Date(podReceipt.completedAt),
            })),
        };
    }
    TokenImpl.listTransferReceipts = listTransferReceipts;
    async function getTransferReceipt(client, receipt, token) {
        const url = token ? endpointForTransfer(token, receipt) : `${RECEIPTS_EP}/${receipt}`;
        const podReceipt = await client.get(url);
        return {
            ...podReceipt,
            completedAt: new Date(podReceipt.completedAt),
        };
    }
    TokenImpl.getTransferReceipt = getTransferReceipt;
})(TokenImpl || (TokenImpl = {}));
//# sourceMappingURL=tokenization.js.map