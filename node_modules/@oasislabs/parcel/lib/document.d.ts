/// <reference types="node" />
import type { ReadStream } from 'fs';
import EventEmitter from 'eventemitter3';
import type { Readable } from 'readable-stream';
import type { Opaque, SetOptional } from 'type-fest';
import type { AppId } from './app.js';
import type { AccessContext } from './asset.js';
import type { JobId } from './compute.js';
import type { Condition } from './condition.js';
import type { HttpClient, Download } from './http.js';
import type { IdentityId } from './identity.js';
import type { Model, Page, PageParams, PODModel, ResourceId, WritableExcluding } from './model.js';
export declare type DocumentId = Opaque<ResourceId, 'DocumentId'>;
export declare type PODDocument = Readonly<PODModel & {
    creator: ResourceId;
    owner: ResourceId;
    size: number;
    details: DocumentDetails;
    originatingJob?: JobId;
}>;
export declare type PODAccessEvent = Readonly<{
    createdAt: string;
    document: ResourceId;
    accessor: ResourceId;
}>;
declare type DocumentDetails = {
    title?: string;
    tags?: string[];
};
export declare class Document implements Model {
    #private;
    readonly id: DocumentId;
    readonly createdAt: Date;
    readonly creator: IdentityId;
    readonly size: number;
    readonly owner: IdentityId;
    readonly details: DocumentDetails;
    /** Additional, optional information about the document. */
    readonly originatingJob?: JobId;
    constructor(client: HttpClient, pod: PODDocument);
    /**
     * Downloads the private data referenced by the document if the authorized identity
     * has been granted access.
     * @returns the decrypted data as a pipeable stream and AsyncIterable
     */
    download(): Download;
    update(params: DocumentUpdateParams): Promise<Document>;
    delete(): Promise<void>;
    history(filter?: ListAccessLogFilter & PageParams): Promise<Page<AccessEvent>>;
}
export declare namespace DocumentImpl {
    function get(client: HttpClient, id: DocumentId): Promise<Document>;
    function search(client: HttpClient, params?: DocumentSearchParams & PageParams): Promise<Page<Document>>;
    function upload(client: HttpClient, data: Storable, params: DocumentUploadParams | undefined | null): Upload;
    function download(client: HttpClient, id: DocumentId): Download;
    function history(client: HttpClient, id: DocumentId, filter?: ListAccessLogFilter & PageParams): Promise<Page<AccessEvent>>;
    function update(client: HttpClient, id: DocumentId, params: DocumentUpdateParams): Promise<Document>;
    function delete_(client: HttpClient, id: DocumentId): Promise<void>;
}
export declare type DocumentUpdateParams = WritableExcluding<Document, 'creator' | 'size' | 'originatingJob'>;
export declare type DocumentUploadParams = SetOptional<DocumentUpdateParams, 'owner' | 'details'> & {
    toApp: AppId | undefined;
};
export declare type Storable = Uint8Array | Readable | ReadStream | Blob | string;
/**
 * A very flexible document search interface.
 *
 * ## Examples:
 *
 * ### Search for documents you own
 *
 * ```
 * {
 *   selectedByCondition: { 'document.owner': { $eq: (await parcel.getCurrentIdentity()).id } },
 * }
 * ```
 *
 * ### Search for documents shared with you
 *
 * ```
 * let me = (await parcel.getCurrentIdentity()).id;
 * {
 *   selectedByCondition: { 'document.owner': { $ne: me } },
 *   accessibleInContext: { accessor: me },
 * }
 * ```
 *
 * ### Search for documents with tags
 *
 * ```
 * {
 *   selectedByCondition: {
 *     'document.tags': { $intersects: ['csv', 'json'] }
 *   },
 * }
 * ```
 *
 */
export declare type DocumentSearchParams = {
    /**
     * Searches for documents that would be selected if a grant with the
     * specified condition were created. Use this field for simulating a grant.
     *
     * If `accessibleInContext` is also specified, this field selects documents
     * both accessible in the context and selected by the condition (i.e. existing
     * conditions apply).
     */
    selectedByCondition?: Condition;
    /**
     * Searches for documents that can be accessed in the provided context.
     * This field allows you to discover documents that you can access either
     * yourself, or from a job.
     */
    accessibleInContext?: AccessContext;
};
export declare type AccessEvent = {
    createdAt: Date;
    document: DocumentId;
    accessor: IdentityId;
};
export declare type ListAccessLogFilter = Partial<{
    accessor: IdentityId;
    after: Date;
    before: Date;
}>;
/**
 * An `Upload` is the result of calling `parcel.uploadDocument`.
 *
 * During upload, emits `progress` events, each with a `ProgressEvent` as its argument.
 *
 * When the document has been uploaded, the `finish` event is emitted with the `Document`
 * reference as its argument.
 */
export declare class Upload extends EventEmitter {
    private readonly abortController;
    constructor(client: HttpClient, data: Storable, sdkParams?: DocumentUploadParams);
    /** Aborts the upload. Emits an `abort` event and sets the `aborted` flag. */
    abort(): void;
    get aborted(): boolean;
    /**
     * @returns a `Promise` that resolves when the upload stream has finished.
     */
    get finished(): Promise<Document>;
}
export {};
//# sourceMappingURL=document.d.ts.map