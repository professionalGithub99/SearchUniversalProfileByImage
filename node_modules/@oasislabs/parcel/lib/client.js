var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BaseClient_client;
import { endpointForApp } from './app.js';
export var ClientType;
(function (ClientType) {
    ClientType["Frontend"] = "frontend";
    ClientType["Backend"] = "backend";
    ClientType["Service"] = "service";
})(ClientType || (ClientType = {}));
class BaseClient {
    constructor(client, pod) {
        _BaseClient_client.set(this, void 0);
        __classPrivateFieldSet(this, _BaseClient_client, client, "f");
        this.id = pod.id;
        this.createdAt = new Date(pod.createdAt);
        this.creator = pod.creator;
        this.appId = pod.appId;
        this.name = pod.name;
        this.type = pod.type;
    }
    async delete() {
        return __classPrivateFieldGet(this, _BaseClient_client, "f").delete(endpointForId(this.appId, this.id));
    }
    isFrontend() {
        return this.type === ClientType.Frontend;
    }
    isBackend() {
        return this.type === ClientType.Backend;
    }
    isService() {
        return this.type === ClientType.Service;
    }
}
_BaseClient_client = new WeakMap();
function makeClient(client, pod) {
    if (pod.type === ClientType.Frontend)
        return new FrontendClient(client, pod);
    if (pod.type === ClientType.Backend)
        return new BackendClient(client, pod);
    if (pod.type === ClientType.Service)
        return new ServiceClient(client, pod);
    throw new Error(`unrecognized client type`);
}
export class FrontendClient extends BaseClient {
    constructor(client, pod) {
        super(client, pod);
        this.type = ClientType.Frontend;
        this.redirectUris = pod.redirectUris;
        this.postLogoutRedirectUris = pod.postLogoutRedirectUris;
    }
}
export class BackendClient extends BaseClient {
    constructor(client, pod) {
        super(client, pod);
        this.type = ClientType.Backend;
        this.redirectUris = pod.redirectUris;
        this.postLogoutRedirectUris = pod.postLogoutRedirectUris;
        this.publicKeys = pod.publicKeys;
    }
}
export class ServiceClient extends BaseClient {
    constructor(client, pod) {
        super(client, pod);
        this.type = ClientType.Service;
        this.publicKeys = pod.publicKeys;
    }
}
export var ClientImpl;
(function (ClientImpl) {
    async function create(client, appId, params) {
        const podClient = await client.create(endpointForCollection(appId), params);
        return makeClient(client, podClient);
    }
    ClientImpl.create = create;
    async function get(client, appId, clientId) {
        const podClient = await client.get(endpointForId(appId, clientId));
        return makeClient(client, podClient);
    }
    ClientImpl.get = get;
    async function list(client, appId, filter) {
        const podPage = await client.get(endpointForCollection(appId), filter);
        const results = podPage.results.map((podClient) => makeClient(client, podClient));
        return {
            results,
            nextPageToken: podPage.nextPageToken,
        };
    }
    ClientImpl.list = list;
    async function update(client, appId, clientId, params) {
        const podClient = await client.update(endpointForId(appId, clientId), params);
        return makeClient(client, podClient);
    }
    ClientImpl.update = update;
    async function delete_(client, appId, clientId) {
        return client.delete(endpointForId(appId, clientId));
    }
    ClientImpl.delete_ = delete_;
})(ClientImpl || (ClientImpl = {}));
const endpointForCollection = (appId) => `${endpointForApp(appId)}/clients`;
const endpointForId = (appId, clientId) => `${endpointForCollection(appId)}/${clientId}`;
//# sourceMappingURL=client.js.map