import type { NormalizedOptions, ResponsePromise } from 'ky';
import { HTTPError } from 'ky';
import type { Merge } from 'type-fest';
import type { IdentityId } from './identity.js';
import './polyfill.js';
export declare class TokenError extends HTTPError {
    responseJson: {
        error: string;
        error_description?: string;
        error_verbose?: string;
        error_hint?: string;
    };
    name: string;
    message: string;
    constructor(request: Request, options: NormalizedOptions, response: Response, responseJson: {
        error: string;
        error_description?: string;
        error_verbose?: string;
        error_hint?: string;
    });
}
declare type ScopeResource = 'identity' | 'dataset' | 'app' | 'grant' | 'permission' | 'job' | '*';
declare type ScopeAction = 'create' | 'read' | 'update' | 'delete' | '*';
export declare type Scope = 'parcel.full' | `parcel.${ScopeResource}.${ScopeAction}`;
export declare const PARCEL_RUNTIME_AUD = "https://api.oasislabs.com/parcel";
export declare abstract class TokenProvider {
    static fromSource(source: TokenSource): TokenProvider;
    /** Returns a valid Bearer token to be presented to the Parcel gateway. */
    abstract getToken(): Promise<string>;
}
export declare type TokenSource = string | RenewingTokenProviderParams | RefreshingTokenProviderParams | SelfIssuedTokenProviderParams;
/** A `TokenProvider` hands out OIDC access tokens. */
export declare abstract class ExpiringTokenProvider implements TokenProvider {
    protected token?: Token;
    static isTokenProvider(thing: any): thing is TokenProvider;
    /** Returns a valid Bearer token to be presented to the Parcel gateway. */
    getToken(): Promise<string>;
    /** Returns a renewed `Token`. */
    protected abstract renewToken(): Promise<Token>;
}
/** A `TokenProvider` that always returns the same, initially provided token. */
export declare class StaticTokenProvider implements TokenProvider {
    private readonly token;
    constructor(token: string);
    getToken(): Promise<string>;
}
/** Parameters of a token provider that fetches access tokens via OAuth using a client key. */
export declare type RenewingTokenProviderParams = {
    clientId: string;
    privateKey: PrivateJWK;
    /**
     * The identity provider's OAuth token retrieval endpoint.
     */
    tokenEndpoint?: string;
    /**
     * The audience to use when using provider's OAuth token retrieval endpoint.
     */
    audience?: string;
    /**
     * A list of scopes that will be requested from the identity provider, which
     * may be different from the scopes that the identity provider actually returns.
     */
    scopes?: Scope[];
};
/** A `TokenProvider` that obtains a new token by re-authenticating to the issuer. */
export declare class RenewingTokenProvider extends ExpiringTokenProvider {
    private readonly clientId;
    private readonly tokenEndpoint;
    private readonly audience;
    private readonly scopes;
    private readonly privateKey;
    private readonly privateKeyPEM;
    private readonly clientAssertionLifetime;
    constructor({ clientId, privateKey, scopes, tokenEndpoint, audience, }: RenewingTokenProviderParams);
    protected renewToken(): Promise<Token>;
}
/** Parameters of a token provider that fetches access tokens via OAuth using a refresh token. */
export declare type RefreshingTokenProviderParams = {
    refreshToken: string;
    tokenEndpoint: string;
    audience: string;
};
/** A `TokenProvider` that obtains a new token using a refresh token. */
export declare class RefreshingTokenProvider extends ExpiringTokenProvider {
    private refreshToken;
    private readonly tokenEndpoint;
    private readonly audience;
    constructor({ refreshToken, tokenEndpoint, audience }: RefreshingTokenProviderParams);
    protected renewToken(): Promise<Token>;
}
/** Parameters of a token provider that signs its own access tokens using a private key. */
export declare type SelfIssuedTokenProviderParams = {
    /** The `sub` and `iss` claims of the provided access token. */
    principal: string | IdentityId;
    /** The private key that will be used to sign the access token. */
    privateKey: PrivateJWK;
    /**
     * A list of scopes that will be added as claims.
     * The default is all scopes.
     */
    scopes?: Scope[];
    /**
     * Duration for which the issued token is valid, in seconds.
     * Defaults to one hour;
     */
    tokenLifetime?: number;
};
/** A `TokenProvider` that self-signs an access token. */
export declare class SelfIssuedTokenProvider extends ExpiringTokenProvider {
    private readonly principal;
    private readonly privateKey;
    private readonly privateKeyPEM;
    private readonly scopes;
    private readonly tokenLifetime;
    constructor({ principal, privateKey, scopes, tokenLifetime, }: SelfIssuedTokenProviderParams);
    protected renewToken(): Promise<Token>;
}
declare class Token {
    private readonly token;
    private readonly expiry;
    constructor(token: string, expiry: number);
    static fromResponse(response: ResponsePromise): Promise<Token>;
    isExpired(): boolean;
    toString(): string;
}
declare type BaseJWK = {
    kty: string;
    alg: string;
    use?: 'sig';
    kid?: string;
};
export declare type PrivateES256JWK = BaseJWK & {
    kty: 'EC';
    alg: 'ES256';
    crv: 'P-256';
    x: string;
    y: string;
    d: string;
};
export declare type PublicES256JWK = Merge<PrivateES256JWK, {
    d?: void;
}>;
export declare type PublicJWK = PublicES256JWK;
export declare type PrivateJWK = PrivateES256JWK;
export declare type IdentityTokenClaims = {
    /** The token's subject. */
    sub: string;
    /** The token's issuer. */
    iss: string;
};
export declare type ClientCredentials = IdentityTokenClaims & {
    privateKey: PrivateJWK;
};
export {};
//# sourceMappingURL=token.d.ts.map