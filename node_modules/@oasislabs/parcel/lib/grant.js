var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Grant_client;
import { makePage } from './model.js';
const GRANTS_EP = 'grants';
const endpointForId = (id) => `${GRANTS_EP}/${id}`;
export class Grant {
    constructor(client, pod) {
        var _a;
        _Grant_client.set(this, void 0);
        __classPrivateFieldSet(this, _Grant_client, client, "f");
        this.id = pod.id;
        this.createdAt = new Date(pod.createdAt);
        this.granter = pod.granter;
        this.grantee = (_a = pod.grantee) !== null && _a !== void 0 ? _a : 'everyone';
        this.condition = pod.condition;
        this.permission = pod.permission;
        this.capabilities = pod.capabilities ? parseCaps(pod.capabilities) : undefined;
        this.delegating = pod.delegating;
    }
    async delete() {
        return __classPrivateFieldGet(this, _Grant_client, "f").delete(endpointForId(this.id));
    }
}
_Grant_client = new WeakMap();
export var GrantImpl;
(function (GrantImpl) {
    async function create(client, params) {
        const podGrant = await client.create(GRANTS_EP, params);
        return new Grant(client, podGrant);
    }
    GrantImpl.create = create;
    async function get(client, id) {
        const podGrant = await client.get(endpointForId(id));
        return new Grant(client, podGrant);
    }
    GrantImpl.get = get;
    async function list(client, filter) {
        const podPage = await client.get(GRANTS_EP, filter);
        return makePage(Grant, podPage, client);
    }
    GrantImpl.list = list;
    async function delete_(client, id) {
        return client.delete(endpointForId(id));
    }
    GrantImpl.delete_ = delete_;
})(GrantImpl || (GrantImpl = {}));
/**
 * `Capabilities` is a collection of bit flags.
 * To test if a capability is set, you can do something like
 * ```
 * const requiredCaps = (Capabilities.Read | Capabilities.Extend);
 * caps & requiredCaps === requiredCaps;
 * ```
 */
/* eslint-disable @typescript-eslint/prefer-literal-enum-member */
export var Capabilities;
(function (Capabilities) {
    Capabilities[Capabilities["None"] = 0] = "None";
    /** The ability to read/view the target. */
    Capabilities[Capabilities["Read"] = 1] = "Read";
    // /** The ability to write the target. */
    // Write = 1 << 1,
    /** The ability to delegate this grant's capabilities to someone else. */
    Capabilities[Capabilities["Extend"] = 4] = "Extend";
})(Capabilities || (Capabilities = {}));
/* eslint-enable @typescript-eslint/prefer-literal-enum-member */
export function parseCaps(strCaps) {
    if (strCaps === undefined)
        return Capabilities.None;
    let caps = Capabilities.None;
    for (const strCap of strCaps.trim().split(/\s+/)) {
        switch (strCap) {
            case 'read':
                caps |= Capabilities.Read;
                break;
            case 'extend':
                caps |= Capabilities.Extend;
                break;
            case '':
                break;
            default:
                throw new Error(`unknown capability "${strCap}"`);
        }
    }
    return caps;
}
export function stringifyCaps(caps) {
    if (caps === undefined)
        return '';
    const capsStrs = [];
    for (const [name, bit] of Object.entries(Capabilities)) {
        if (typeof bit !== 'number')
            continue;
        if ((caps & bit) !== 0) {
            capsStrs.push(name.toLowerCase());
        }
    }
    return capsStrs.join(' ');
}
//# sourceMappingURL=grant.js.map