var _a, _b, _c, _d, _e, _f;
import AbortController from 'abort-controller';
import FormData from 'form-data';
import ky, { HTTPError } from 'ky';
import { paramCase } from 'param-case';
import { pipeToPolyfill } from './polyfill.js';
const DEFAULT_API_URL = (_c = (_b = (_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.process) === null || _a === void 0 ? void 0 : _a.env) === null || _b === void 0 ? void 0 : _b.PARCEL_API_URL) !== null && _c !== void 0 ? _c : 'https://api.oasislabs.com/parcel/v1';
const DEFAULT_STORAGE_URL = (_f = (_e = (_d = globalThis === null || globalThis === void 0 ? void 0 : globalThis.process) === null || _d === void 0 ? void 0 : _d.env) === null || _e === void 0 ? void 0 : _e.PARCEL_STORAGE_URL) !== null && _f !== void 0 ? _f : 'https://storage.oasislabs.com/v1/parcel';
const DEFAULT_RESPONSE_CODES = new Map([
    ['POST', 200],
    ['PUT', 200],
    ['PATCH', 200],
    ['DELETE', 204],
]);
export class HttpClient {
    constructor(tokenProvider, config) {
        var _a, _b;
        this.tokenProvider = tokenProvider;
        this.apiUrl = (_b = (_a = config === null || config === void 0 ? void 0 : config.apiUrl) === null || _a === void 0 ? void 0 : _a.replace(/\/$/, '')) !== null && _b !== void 0 ? _b : DEFAULT_API_URL;
        if (config === null || config === void 0 ? void 0 : config.storageUrl) {
            this.storageUrl = config.storageUrl;
        }
        else if (config === null || config === void 0 ? void 0 : config.apiUrl) {
            const apiUrl = new URL(this.apiUrl);
            if (/local/g.test(apiUrl.host) || /^parcel-(run|gate)way/g.test(apiUrl.host)) {
                this.storageUrl = `${this.apiUrl}/documents`; // Intranet can use the endpoint directly.
            }
            else {
                const storageHost = apiUrl.host.replace(/^\w+\./, 'storage.');
                this.storageUrl = `${apiUrl.protocol}//${storageHost}/v1/parcel`;
            }
        }
        else {
            this.storageUrl = DEFAULT_STORAGE_URL;
        }
        this.apiKy = ky.create({
            ...config === null || config === void 0 ? void 0 : config.httpClientConfig,
            // Default timeout is 10s, and that might be too short for chain. Upload
            // request should override this.
            timeout: 30000,
            prefixUrl: this.apiUrl,
            headers: {
                'x-requested-with': '@oasislabs/parcel',
            },
            hooks: {
                beforeRequest: [
                    appendAsLastBeforeRequest(dontCloneForAfterResponses()),
                    async (req) => {
                        req.headers.set('authorization', `Bearer ${await this.tokenProvider.getToken()}`);
                    },
                ],
                afterResponse: [
                    async (req, opts, res) => {
                        var _a, _b;
                        // The `authorization` header is not re-sent by the browser, so redirects fail,
                        // and must be retried manually.
                        if (res.redirected &&
                            (res.status === 401 || res.status === 403) &&
                            (res.url.startsWith(this.apiUrl) || res.url.startsWith(this.storageUrl))) {
                            return this.apiKy(res.url, {
                                method: req.method,
                                prefixUrl: '',
                            });
                        }
                        // Wrap errors, for easier client handling (and maybe better messages).
                        if (isApiErrorResponse(res)) {
                            throw new ApiError(req, opts, res, `Error from ${req.url}: ${(await res.json()).error}`);
                        }
                        const allowedStatusCodes = (_a = req.allowedStatusCodes) !== null && _a !== void 0 ? _a : [];
                        allowedStatusCodes.push((_b = DEFAULT_RESPONSE_CODES.get(req.method)) !== null && _b !== void 0 ? _b : 200);
                        if (res.ok && !allowedStatusCodes.includes(res.status)) {
                            const endpoint = res.url.replace(this.apiUrl, '');
                            throw new ApiError(req, opts, res, `${req.method} ${endpoint} returned unexpected status ${res.status}. expected: ${allowedStatusCodes.join(' | ')}.`);
                        }
                    },
                ],
            },
        });
    }
    async get(endpoint, params = {}, requestOptions) {
        let hasParams = false;
        const kebabCaseParams = {};
        for (const [k, v] of Object.entries(params)) {
            if (v !== undefined) {
                hasParams = true;
                kebabCaseParams[paramCase(k)] = v instanceof Date ? v.getTime() : v;
            }
        }
        const response = await this.apiKy.get(endpoint, {
            searchParams: hasParams ? kebabCaseParams : undefined,
            ...requestOptions,
        });
        return response.json();
    }
    async upload(data, requestOptions) {
        return this.create(this.storageUrl, data, {
            prefixUrl: '',
            ...requestOptions,
        });
    }
    /** Convenience method for POSTing and expecting a 201 response */
    async create(endpoint, data, requestOptions) {
        var _a, _b;
        return this.post(endpoint, data, {
            ...requestOptions,
            hooks: {
                beforeRequest: [...((_b = (_a = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.hooks) === null || _a === void 0 ? void 0 : _a.beforeRequest) !== null && _b !== void 0 ? _b : []), addAllowedStatusCode(201)],
            },
        });
    }
    /** Convenience method for POSTing and expecting a 200 response */
    async search(baseEndpoint, // Without the `/search` suffix.
    params, requestOptions) {
        return this.post(`${baseEndpoint}/search`, params, requestOptions);
    }
    async post(endpoint, data, requestOptions) {
        const opts = requestOptions !== null && requestOptions !== void 0 ? requestOptions : {};
        if (data !== undefined) {
            if (('getBuffer' in data && typeof data.getBuffer === 'function') /* form-data polyfill */ ||
                data instanceof FormData) {
                opts.body = data;
            }
            else {
                opts.json = data;
            }
        }
        return (await this.apiKy.post(endpoint, opts)).json();
    }
    async update(endpoint, params) {
        return this.put(endpoint, params);
    }
    async put(endpoint, params) {
        return (await this.apiKy.put(endpoint, { json: params })).json();
    }
    async delete(endpoint) {
        await this.apiKy.delete(endpoint);
    }
    download(endpoint) {
        return new Download(this.apiKy, endpoint);
    }
}
/**
 * Workaround to fix `afterResponse` breaking >20MB file downloads.
 *
 * Ky clones the response when using afterResponse. Cloning causes requests to
 * stop requesting data after 2x highWaterMark (we use 10 MB) unless all clones
 * consume data at the same time. This workaround uses beforeRequest hook to
 * skip ky's fetch call + afterResponse handling, and reimplements both.
 *
 * WARNING: Use caution if modifying response.json or response.body in hooks. In
 * vanilla ky every hook receives its own clone of the response; with this
 * workaround, the same response object is passed to all hooks, so changes
 * propagate (somewhat mitigated by readonly fields on Response). In addition,
 * response.body can only be read once.
 *
 * Related issues:
 * - https://github.com/node-fetch/node-fetch#custom-highwatermark
 * - https://github.com/sindresorhus/ky-universal/issues/8
 * - https://github.com/sindresorhus/ky/issues/135
 * - https://github.com/node-fetch/node-fetch/issues/386
 *
 * TODO: remove if fixed by https://github.com/sindresorhus/ky/pull/356
 */
export function dontCloneForAfterResponses() {
    return async (req, opts) => {
        var _a, _b;
        if (!((_b = (_a = opts.hooks) === null || _a === void 0 ? void 0 : _a.afterResponse) === null || _b === void 0 ? void 0 : _b.length))
            return;
        const { afterResponse } = opts.hooks;
        opts.hooks.afterResponse = [];
        let response = await opts.fetch(req.clone());
        // https://github.com/sindresorhus/ky/blob/5f3c3158af5c7efbb6a1cfd9e5f16fc71dd26e36/source/core/Ky.ts#L112-L123
        for (const hook of afterResponse) {
            const modifiedResponse = await hook(req, opts, response);
            if (modifiedResponse instanceof globalThis.Response) {
                response = modifiedResponse;
            }
        }
        return response;
    };
}
/** Attaches a hook to end of hooks.beforeRequest (incl. after one-off hooks specified in the call to fetch(), e.g. setExpectedStatus) */
export function appendAsLastBeforeRequest(hookToSchedule) {
    return (req, opts) => {
        if (!opts.hooks)
            opts.hooks = {};
        if (!opts.hooks.beforeRequest)
            opts.hooks.beforeRequest = [];
        opts.hooks.beforeRequest.push(hookToSchedule);
    };
}
/** A beforeRequest hook that attaches context to the Request, for displaying in errors. */
function attachContext(context) {
    return (req) => {
        req.context = context;
    };
}
export function addAllowedStatusCode(status) {
    return (req) => {
        var _a;
        req.allowedStatusCodes = (_a = req.allowedStatusCodes) !== null && _a !== void 0 ? _a : [];
        req.allowedStatusCodes.push(status);
    };
}
/**
 * A `Download` is the result of calling `parcel.downloadDocument` or `document.download()`.
 *
 * The downloaded data can be read using async iterable `for await (const chunk of download)`,
 * or by calling `await download.pipeTo(sink)`.
 *
 * The download may be aborted by calling `download.destroy()`, as with any `Readable`.
 */
export class Download {
    constructor(client, endpoint) {
        this.client = client;
        this.endpoint = endpoint;
        this.abortController = new AbortController();
    }
    async *[Symbol.asyncIterator]() {
        var _a;
        const body = (_a = (await this.makeRequest())) === null || _a === void 0 ? void 0 : _a.body;
        if (!body)
            return;
        /* istanbul ignore else: tested using Cypress */
        if (body.getReader === undefined) {
            // https://github.com/node-fetch/node-fetch/issues/930
            const bodyReadable = body;
            yield* bodyReadable;
        }
        else {
            const rdr = body.getReader();
            let chunk;
            do {
                chunk = await rdr.read();
                if (chunk.value)
                    yield chunk.value;
            } while (!chunk.done);
        }
    }
    abort() {
        this.abortController.abort();
    }
    get aborted() {
        return this.abortController.signal.aborted;
    }
    /**
     * Convenience method for piping to a sink and waiting for writing to finish.
     * This method must not be used alongside `getStream` or `AsyncIterable`.
     */
    async pipeTo(sink) {
        if ('getWriter' in sink) {
            const { body } = await this.makeRequest();
            if (!body)
                return;
            if (body.pipeTo) {
                return body.pipeTo(sink);
            }
            // Firefox's native ReadableStream is missing pipeTo.
            return pipeToPolyfill(body, sink);
        }
        // eslint-disable-next-line node/no-unsupported-features/es-syntax
        const { Readable } = (await import('stream')).default; // This only happens in node.
        return new Promise((resolve, reject) => {
            Readable.from(this, { objectMode: false })
                .on('error', reject)
                .pipe(sink)
                .on('error', reject)
                .on('finish', resolve);
        });
    }
    /**
     * Lazily make the request. Helps avoid unhandled promise rejections when the request
     * fails before a pipe or iterator handler is attached.
     */
    // This function returns double promise to make both xo and TS happy. V8 doesn't care.
    async makeRequest() {
        if (!this.res) {
            this.res = this.client.get(this.endpoint, {
                signal: this.abortController.signal,
                hooks: {
                    beforeRequest: [attachContext('document download')],
                },
            });
        }
        return this.res;
    }
}
export class ApiError extends HTTPError {
    constructor(
    /** @see attachContext */
    request, options, response, message) {
        super(response, request, options);
        this.name = 'ApiError';
        this.message = request.context ? `error in ${request.context}: ${message}` : message;
    }
    static async fromHTTPError(error) {
        const res = error.response;
        return new ApiError(error.request, error.options, res, (await res.json()).error);
    }
}
function isApiErrorResponse(response) {
    var _a, _b;
    const isJson = (_b = (_a = response.headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.startsWith('application/json')) !== null && _b !== void 0 ? _b : false;
    return !response.ok && isJson;
}
//# sourceMappingURL=http.js.map