import type { Opaque } from 'type-fest';
import type { DocumentId } from './document.js';
import type { HttpClient } from './http.js';
import type { IdentityId } from './identity.js';
import type { Page, PageParams, PODModel } from './model.js';
import { ResourceId } from './model.js';
export declare type JobId = Opaque<ResourceId, 'JobId'>;
/**
 * Filters for specifying the subset of jobs to be listed/fetched.
 */
export declare type ListJobsFilter = {
    /** Selects jobs that were submitted by this identity. */
    submitter?: IdentityId;
    /** Selects jobs that used documents owned by this identity. */
    inputOwner?: IdentityId;
};
/**
 * Input document for a compute job.
 */
export declare type InputDocumentSpec = {
    /** ID of the document to mount. */
    id: DocumentId;
    /** Path where the input document will be mounted inside the job. Interpreted relative to `/parcel/data/in`. */
    mountPath: string;
};
/**
 * Specification for a compute job for outputting a document.
 */
export declare type OutputDocumentSpec = {
    /** Path to the file that should be uploaded as an output document. Interpreted relative to `/parcel/data/out`. */
    mountPath: string;
    /** Owner to assign to the output document. */
    owner?: IdentityId;
};
/**
 * An output document produced in the context of running a job.
 */
export declare type OutputDocument = {
    mountPath: string;
    id: DocumentId;
};
/**
 * A specification/manifest for the job. This is a complete description of what
 * and how the job should run.
 */
export declare type JobSpec = {
    /**
     * A human-readable name for the job. Intended to help with monitoring and
     * debugging. The name SHOULD be unique among jobs submitted by the same
     * user. */
    name: string;
    /**
     * The command-line arguments to the command that should be run to start the
     * job. This corresponds to `CMD` in Docker terminology; note that images
     * running on Parcel are required to have a non-empty `ENTRYPOINT`, so the
     * actual command that runs will be the
     * [concatenation](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact)
     * of `ENTRYPOINT` and this field.
     */
    cmd: string[];
    /**
     * The name of the docker image to use, optionally prefixed with an image
     * repository hostname. See [docker
     * pull](https://docs.docker.com/engine/reference/commandline/pull/)
     * documentation for a full description of allowable formats.
     */
    image: string;
    /**
     * Environment variables to use when running the image. Setting `PATH` is
     * not allowed.
     */
    env?: Record<string, string>;
    /**
     * Documents to download and mount into the job's container before `cmd` runs.
     * If any of these documents do not exist or you do not have permission to access them, the job will fail.
     */
    inputDocuments?: InputDocumentSpec[];
    /**
     * Files to be uploaded from the job's container as documents after `cmd` runs.
     * Files that do not exist will be silently skipped; the job will not fail.
     */
    outputDocuments?: OutputDocumentSpec[];
    /**
     * The (fractional) number of cpus requested to run the job. This is clamped by a per-worker
     * maximum.
     */
    cpus?: number;
    /**
     * The amount of memory requested to run the job. This is clamped by a per-worker
     * maximum. Memory limit (format: <number>[<unit>]). Number is a positive integer.
     * Unit can be one of M or G. Minimum is 4M.
     */
    memory?: string;
};
export declare type JobStatus = {
    phase: JobPhase;
    /**
     * A human readable message indicating details about why the pod is in this
     * condition.
     */
    message?: string;
    /**
     * Documents that were accessed by the job. Includes both the prespecified
     * `JobSpec.input_documents` as well as any dynamically accessed documents.
     */
    accessedDocuments: DocumentId[];
    /**
     * Documents that were generated by the job and uploaded by the Parcel
     * Worker.
     */
    outputDocuments: OutputDocument[];
    /**
     * A reference to the worker hosting (running) this job, if any. This field
     * is intended for human reference/debugging only for now, so no semantics
     * are prescribed for the endpoint at the `host` address.
     */
    host?: string;
};
export declare enum JobPhase {
    PENDING = "Pending",
    RUNNING = "Running",
    SUCCEEDED = "Succeeded",
    FAILED = "Failed"
}
export declare type PODJob = Readonly<PODModel & {
    id: JobId;
    spec: JobSpec;
    /**
     * Most recently observed status of the pod. May be missing if the job is no
     * longer tracked by the system; this will typically happen for older jobs.
     * This data may not be up to date. The data type is a mostly subset of
     * [Kubernetes' PodStatus](https://www.k8sref.io/docs/workloads/pod-v1/#podstatus).
     */
    status?: JobStatus;
}>;
export declare type PODJobStatusReport = Readonly<PODModel & {
    id: JobId;
    /** Most recently observed status of the pod. */
    status: JobStatus;
}>;
/**
 * An existing, already-submitted job. The job might also be already completed.
 */
export declare class Job {
    #private;
    readonly id: JobId;
    readonly createdAt: Date;
    readonly spec: JobSpec;
    readonly status?: JobStatus;
    constructor(client: HttpClient, pod: PODJob);
}
/**
 * An existing, already-submitted job. The job might also be already completed.
 */
export declare class JobStatusReport {
    #private;
    readonly id: JobId;
    readonly status: JobStatus;
    constructor(client: HttpClient, pod: PODJobStatusReport);
}
export declare namespace ComputeImpl {
    function submitJob(client: HttpClient, spec: JobSpec): Promise<Job>;
    function listJobs(client: HttpClient, filter?: PageParams): Promise<Page<Job>>;
    function getJob(client: HttpClient, jobId: JobId): Promise<Job>;
    function getJobStatus(client: HttpClient, jobId: JobId): Promise<JobStatusReport>;
    function terminateJob(client: HttpClient, jobId: JobId): Promise<void>;
}
//# sourceMappingURL=compute.d.ts.map