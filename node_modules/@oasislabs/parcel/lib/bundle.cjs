var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if (typeof module2 !== "undefined") {
      module2.exports = EventEmitter2;
    }
  }
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "node_modules/delayed-stream/lib/delayed_stream.js"(exports, module2) {
    var Stream3 = require("stream").Stream;
    var util = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util.inherits(DelayedStream, Stream3);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream3.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "node_modules/combined-stream/lib/combined_stream.js"(exports, module2) {
    var util = require("util");
    var Stream3 = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util.inherits(CombinedStream, Stream3);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream) {
      return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
    };
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream.on("data", this._checkDataSize.bind(this));
          stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
          stream.pause();
        }
      }
      this._streams.push(stream);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream3.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream = this._streams.shift();
      if (typeof stream == "undefined") {
        this.end();
        return;
      }
      if (typeof stream !== "function") {
        this._pipeNext(stream);
        return;
      }
      var getStream = stream;
      getStream(function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream2);
        }
        this._pipeNext(stream2);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on("end", this._getNext.bind(this));
        stream.pipe(this, { end: false });
        return;
      }
      var value = stream;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream) {
      var self2 = this;
      stream.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
        this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
        this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
        self2.dataSize += stream.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana"
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana"
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana"
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana"
      },
      "image/avcs": {
        source: "iana"
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports, module2) {
    module2.exports = require_db();
  }
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/mime-types/index.js"(exports) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports.charset = charset;
    exports.charsets = { lookup: charset };
    exports.contentType = contentType;
    exports.extension = extension;
    exports.extensions = Object.create(null);
    exports.lookup = lookup;
    exports.types = Object.create(null);
    populateMaps(exports.extensions, exports.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports.types[extension2] || false;
    }
    function populateMaps(extensions, types3) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types3[extension2]) {
            var from = preference.indexOf(db[types3[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types3[extension2] !== "application/octet-stream" && (from > to || from === to && types3[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types3[extension2] = type;
        }
      });
    }
  }
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "node_modules/asynckit/lib/defer.js"(exports, module2) {
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "node_modules/asynckit/lib/async.js"(exports, module2) {
    var defer = require_defer();
    module2.exports = async;
    function async(callback) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result2) {
        if (isAsync) {
          callback(err, result2);
        } else {
          defer(function nextTick_callback() {
            callback(err, result2);
          });
        }
      };
    }
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "node_modules/asynckit/lib/abort.js"(exports, module2) {
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "node_modules/asynckit/lib/iterate.js"(exports, module2) {
    var async = require_async();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "node_modules/asynckit/lib/state.js"(exports, module2) {
    module2.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "node_modules/asynckit/lib/terminator.js"(exports, module2) {
    var abort = require_abort();
    var async = require_async();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "node_modules/asynckit/parallel.js"(exports, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error, result2) {
          if (error) {
            callback(error, result2);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "node_modules/asynckit/serialOrdered.js"(exports, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error, result2) {
        if (error) {
          callback(error, result2);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "node_modules/asynckit/serial.js"(exports, module2) {
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator, callback) {
      return serialOrdered(list, iterator, null, callback);
    }
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "node_modules/asynckit/index.js"(exports, module2) {
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "node_modules/form-data/lib/populate.js"(exports, module2) {
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "node_modules/form-data/lib/form_data.js"(exports, module2) {
    var CombinedStream = require_combined_stream();
    var util = require("util");
    var path = require("path");
    var http3 = require("http");
    var https2 = require("https");
    var parseUrl = require("url").parse;
    var fs = require("fs");
    var Stream3 = require("stream").Stream;
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var populate = require_populate();
    module2.exports = FormData4;
    util.inherits(FormData4, CombinedStream);
    function FormData4(options) {
      if (!(this instanceof FormData4)) {
        return new FormData4(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    FormData4.LINE_BREAK = "\r\n";
    FormData4.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData4.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options == "string") {
        options = { filename: options };
      }
      var append = CombinedStream.prototype.append.bind(this);
      if (typeof value == "number") {
        value = "" + value;
      }
      if (util.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append(header);
      append(value);
      append(footer);
      this._trackLength(header, value, options);
    };
    FormData4.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += +options.knownLength;
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData4.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion")) && !(value instanceof Stream3)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData4.prototype._lengthRetriever = function(value, callback) {
      if (value.hasOwnProperty("fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs.stat(value.path, function(err, stat) {
            var fileSize;
            if (err) {
              callback(err);
              return;
            }
            fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (value.hasOwnProperty("httpVersion")) {
        callback(null, +value.headers["content-length"]);
      } else if (value.hasOwnProperty("httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, +response.headers["content-length"]);
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData4.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header == "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header == "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (!headers.hasOwnProperty(prop))
          continue;
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData4.LINE_BREAK;
        }
      }
      return "--" + this.getBoundary() + FormData4.LINE_BREAK + contents + FormData4.LINE_BREAK;
    };
    FormData4.prototype._getContentDisposition = function(value, options) {
      var filename, contentDisposition;
      if (typeof options.filepath === "string") {
        filename = path.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value.name || value.path) {
        filename = path.basename(options.filename || value.name || value.path);
      } else if (value.readable && value.hasOwnProperty("httpVersion")) {
        filename = path.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        contentDisposition = 'filename="' + filename + '"';
      }
      return contentDisposition;
    };
    FormData4.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && typeof value == "object") {
        contentType = FormData4.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData4.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData4.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData4.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData4.LINE_BREAK;
    };
    FormData4.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (userHeaders.hasOwnProperty(header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData4.prototype.setBoundary = function(boundary) {
      this._boundary = boundary;
    };
    FormData4.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData4.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData4.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData4.prototype._generateBoundary = function() {
      var boundary = "--------------------------";
      for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
      }
      this._boundary = boundary;
    };
    FormData4.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData4.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData4.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData4.prototype.submit = function(params, cb) {
      var request, options, defaults = { method: "post" };
      if (typeof params == "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults);
      } else {
        options = populate(params, defaults);
        if (!options.port) {
          options.port = options.protocol == "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol == "https:") {
        request = https2.request(options);
      } else {
        request = http3.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request.setHeader("Content-Length", length);
        }
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback = function(error, responce) {
            request.removeListener("error", callback);
            request.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          };
          onResponse = callback.bind(this, null);
          request.on("error", callback);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData4.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData4.prototype.toString = function() {
      return "[object FormData]";
    };
  }
});

// node_modules/event-target-shim/dist/event-target-shim.js
var require_event_target_shim = __commonJS({
  "node_modules/event-target-shim/dist/event-target-shim.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var privateData = new WeakMap();
    var wrappers = new WeakMap();
    function pd(event) {
      const retv = privateData.get(event);
      console.assert(retv != null, "'this' is expected an Event object, but got", event);
      return retv;
    }
    function setCancelFlag(data) {
      if (data.passiveListener != null) {
        if (typeof console !== "undefined" && typeof console.error === "function") {
          console.error("Unable to preventDefault inside passive event listener invocation.", data.passiveListener);
        }
        return;
      }
      if (!data.event.cancelable) {
        return;
      }
      data.canceled = true;
      if (typeof data.event.preventDefault === "function") {
        data.event.preventDefault();
      }
    }
    function Event(eventTarget, event) {
      privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        immediateStopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now()
      });
      Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
      const keys = Object.keys(event);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in this)) {
          Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
      }
    }
    Event.prototype = {
      get type() {
        return pd(this).event.type;
      },
      get target() {
        return pd(this).eventTarget;
      },
      get currentTarget() {
        return pd(this).currentTarget;
      },
      composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
          return [];
        }
        return [currentTarget];
      },
      get NONE() {
        return 0;
      },
      get CAPTURING_PHASE() {
        return 1;
      },
      get AT_TARGET() {
        return 2;
      },
      get BUBBLING_PHASE() {
        return 3;
      },
      get eventPhase() {
        return pd(this).eventPhase;
      },
      stopPropagation() {
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.stopPropagation === "function") {
          data.event.stopPropagation();
        }
      },
      stopImmediatePropagation() {
        const data = pd(this);
        data.stopped = true;
        data.immediateStopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
          data.event.stopImmediatePropagation();
        }
      },
      get bubbles() {
        return Boolean(pd(this).event.bubbles);
      },
      get cancelable() {
        return Boolean(pd(this).event.cancelable);
      },
      preventDefault() {
        setCancelFlag(pd(this));
      },
      get defaultPrevented() {
        return pd(this).canceled;
      },
      get composed() {
        return Boolean(pd(this).event.composed);
      },
      get timeStamp() {
        return pd(this).timeStamp;
      },
      get srcElement() {
        return pd(this).eventTarget;
      },
      get cancelBubble() {
        return pd(this).stopped;
      },
      set cancelBubble(value) {
        if (!value) {
          return;
        }
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.cancelBubble === "boolean") {
          data.event.cancelBubble = true;
        }
      },
      get returnValue() {
        return !pd(this).canceled;
      },
      set returnValue(value) {
        if (!value) {
          setCancelFlag(pd(this));
        }
      },
      initEvent() {
      }
    };
    Object.defineProperty(Event.prototype, "constructor", {
      value: Event,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
      Object.setPrototypeOf(Event.prototype, window.Event.prototype);
      wrappers.set(window.Event.prototype, Event);
    }
    function defineRedirectDescriptor(key) {
      return {
        get() {
          return pd(this).event[key];
        },
        set(value) {
          pd(this).event[key] = value;
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineCallDescriptor(key) {
      return {
        value() {
          const event = pd(this).event;
          return event[key].apply(event, arguments);
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineWrapper(BaseEvent, proto) {
      const keys = Object.keys(proto);
      if (keys.length === 0) {
        return BaseEvent;
      }
      function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
      }
      CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true }
      });
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in BaseEvent.prototype)) {
          const descriptor = Object.getOwnPropertyDescriptor(proto, key);
          const isFunc = typeof descriptor.value === "function";
          Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));
        }
      }
      return CustomEvent;
    }
    function getWrapper(proto) {
      if (proto == null || proto === Object.prototype) {
        return Event;
      }
      let wrapper = wrappers.get(proto);
      if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
      }
      return wrapper;
    }
    function wrapEvent(eventTarget, event) {
      const Wrapper = getWrapper(Object.getPrototypeOf(event));
      return new Wrapper(eventTarget, event);
    }
    function isStopped(event) {
      return pd(event).immediateStopped;
    }
    function setEventPhase(event, eventPhase) {
      pd(event).eventPhase = eventPhase;
    }
    function setCurrentTarget(event, currentTarget) {
      pd(event).currentTarget = currentTarget;
    }
    function setPassiveListener(event, passiveListener) {
      pd(event).passiveListener = passiveListener;
    }
    var listenersMap = new WeakMap();
    var CAPTURE = 1;
    var BUBBLE = 2;
    var ATTRIBUTE = 3;
    function isObject2(x) {
      return x !== null && typeof x === "object";
    }
    function getListeners(eventTarget) {
      const listeners = listenersMap.get(eventTarget);
      if (listeners == null) {
        throw new TypeError("'this' is expected an EventTarget object, but got another value.");
      }
      return listeners;
    }
    function defineEventAttributeDescriptor(eventName) {
      return {
        get() {
          const listeners = getListeners(this);
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              return node.listener;
            }
            node = node.next;
          }
          return null;
        },
        set(listener) {
          if (typeof listener !== "function" && !isObject2(listener)) {
            listener = null;
          }
          const listeners = getListeners(this);
          let prev = null;
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              if (prev !== null) {
                prev.next = node.next;
              } else if (node.next !== null) {
                listeners.set(eventName, node.next);
              } else {
                listeners.delete(eventName);
              }
            } else {
              prev = node;
            }
            node = node.next;
          }
          if (listener !== null) {
            const newNode = {
              listener,
              listenerType: ATTRIBUTE,
              passive: false,
              once: false,
              next: null
            };
            if (prev === null) {
              listeners.set(eventName, newNode);
            } else {
              prev.next = newNode;
            }
          }
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineEventAttribute(eventTargetPrototype, eventName) {
      Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));
    }
    function defineCustomEventTarget(eventNames) {
      function CustomEventTarget() {
        EventTarget.call(this);
      }
      CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: {
          value: CustomEventTarget,
          configurable: true,
          writable: true
        }
      });
      for (let i = 0; i < eventNames.length; ++i) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
      }
      return CustomEventTarget;
    }
    function EventTarget() {
      if (this instanceof EventTarget) {
        listenersMap.set(this, new Map());
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0]);
      }
      if (arguments.length > 0) {
        const types3 = new Array(arguments.length);
        for (let i = 0; i < arguments.length; ++i) {
          types3[i] = arguments[i];
        }
        return defineCustomEventTarget(types3);
      }
      throw new TypeError("Cannot call a class as a function");
    }
    EventTarget.prototype = {
      addEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        if (typeof listener !== "function" && !isObject2(listener)) {
          throw new TypeError("'listener' should be a function or an object.");
        }
        const listeners = getListeners(this);
        const optionsIsObj = isObject2(options);
        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        const newNode = {
          listener,
          listenerType,
          passive: optionsIsObj && Boolean(options.passive),
          once: optionsIsObj && Boolean(options.once),
          next: null
        };
        let node = listeners.get(eventName);
        if (node === void 0) {
          listeners.set(eventName, newNode);
          return;
        }
        let prev = null;
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            return;
          }
          prev = node;
          node = node.next;
        }
        prev.next = newNode;
      },
      removeEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        const listeners = getListeners(this);
        const capture = isObject2(options) ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
            return;
          }
          prev = node;
          node = node.next;
        }
      },
      dispatchEvent(event) {
        if (event == null || typeof event.type !== "string") {
          throw new TypeError('"event.type" should be a string.');
        }
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) {
          return true;
        }
        const wrappedEvent = wrapEvent(this, event);
        let prev = null;
        while (node != null) {
          if (node.once) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
          } else {
            prev = node;
          }
          setPassiveListener(wrappedEvent, node.passive ? node.listener : null);
          if (typeof node.listener === "function") {
            try {
              node.listener.call(this, wrappedEvent);
            } catch (err) {
              if (typeof console !== "undefined" && typeof console.error === "function") {
                console.error(err);
              }
            }
          } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
            node.listener.handleEvent(wrappedEvent);
          }
          if (isStopped(wrappedEvent)) {
            break;
          }
          node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);
        return !wrappedEvent.defaultPrevented;
      }
    };
    Object.defineProperty(EventTarget.prototype, "constructor", {
      value: EventTarget,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
      Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
    }
    exports.defineEventAttribute = defineEventAttribute;
    exports.EventTarget = EventTarget;
    exports.default = EventTarget;
    module2.exports = EventTarget;
    module2.exports.EventTarget = module2.exports["default"] = EventTarget;
    module2.exports.defineEventAttribute = defineEventAttribute;
  }
});

// node_modules/abort-controller/dist/abort-controller.js
var require_abort_controller = __commonJS({
  "node_modules/abort-controller/dist/abort-controller.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var eventTargetShim = require_event_target_shim();
    var AbortSignal = class extends eventTargetShim.EventTarget {
      constructor() {
        super();
        throw new TypeError("AbortSignal cannot be constructed directly");
      }
      get aborted() {
        const aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean") {
          throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        }
        return aborted;
      }
    };
    eventTargetShim.defineEventAttribute(AbortSignal.prototype, "abort");
    function createAbortSignal() {
      const signal = Object.create(AbortSignal.prototype);
      eventTargetShim.EventTarget.call(signal);
      abortedFlags.set(signal, false);
      return signal;
    }
    function abortSignal(signal) {
      if (abortedFlags.get(signal) !== false) {
        return;
      }
      abortedFlags.set(signal, true);
      signal.dispatchEvent({ type: "abort" });
    }
    var abortedFlags = new WeakMap();
    Object.defineProperties(AbortSignal.prototype, {
      aborted: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortSignal"
      });
    }
    var AbortController4 = class {
      constructor() {
        signals.set(this, createAbortSignal());
      }
      get signal() {
        return getSignal(this);
      }
      abort() {
        abortSignal(getSignal(this));
      }
    };
    var signals = new WeakMap();
    function getSignal(controller) {
      const signal = signals.get(controller);
      if (signal == null) {
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
      }
      return signal;
    }
    Object.defineProperties(AbortController4.prototype, {
      signal: { enumerable: true },
      abort: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortController4.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortController"
      });
    }
    exports.AbortController = AbortController4;
    exports.AbortSignal = AbortSignal;
    exports.default = AbortController4;
    module2.exports = AbortController4;
    module2.exports.AbortController = module2.exports["default"] = AbortController4;
    module2.exports.AbortSignal = AbortSignal;
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports, module2) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __spreadArray;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      __extends = function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      __rest = function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      __decorate = function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result2) {
            result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar = function(m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding(o, m, p);
      };
      __createBinding = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __values = function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read(arguments[i]));
        return ar;
      };
      __spreadArrays = function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      };
      __spreadArray = function(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
          to[j] = from[i];
        return to;
      };
      __await = function(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result2 = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result2, mod, k);
        }
        __setModuleDefault(result2, mod);
        return result2;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__spreadArray", __spreadArray);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// node_modules/lower-case/dist/index.js
var require_dist = __commonJS({
  "node_modules/lower-case/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lowerCase = exports.localeLowerCase = void 0;
    var SUPPORTED_LOCALE = {
      tr: {
        regexp: /\u0130|\u0049|\u0049\u0307/g,
        map: {
          \u0130: "i",
          I: "\u0131",
          I\u0307: "i"
        }
      },
      az: {
        regexp: /\u0130/g,
        map: {
          \u0130: "i",
          I: "\u0131",
          I\u0307: "i"
        }
      },
      lt: {
        regexp: /\u0049|\u004A|\u012E|\u00CC|\u00CD|\u0128/g,
        map: {
          I: "i\u0307",
          J: "j\u0307",
          \u012E: "\u012F\u0307",
          \u00CC: "i\u0307\u0300",
          \u00CD: "i\u0307\u0301",
          \u0128: "i\u0307\u0303"
        }
      }
    };
    function localeLowerCase(str, locale) {
      var lang = SUPPORTED_LOCALE[locale.toLowerCase()];
      if (lang)
        return lowerCase(str.replace(lang.regexp, function(m) {
          return lang.map[m];
        }));
      return lowerCase(str);
    }
    exports.localeLowerCase = localeLowerCase;
    function lowerCase(str) {
      return str.toLowerCase();
    }
    exports.lowerCase = lowerCase;
  }
});

// node_modules/no-case/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/no-case/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.noCase = void 0;
    var lower_case_1 = require_dist();
    var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
    var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
    function noCase(input, options) {
      if (options === void 0) {
        options = {};
      }
      var _a13 = options.splitRegexp, splitRegexp = _a13 === void 0 ? DEFAULT_SPLIT_REGEXP : _a13, _b4 = options.stripRegexp, stripRegexp = _b4 === void 0 ? DEFAULT_STRIP_REGEXP : _b4, _c3 = options.transform, transform = _c3 === void 0 ? lower_case_1.lowerCase : _c3, _d = options.delimiter, delimiter = _d === void 0 ? " " : _d;
      var result2 = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
      var start = 0;
      var end = result2.length;
      while (result2.charAt(start) === "\0")
        start++;
      while (result2.charAt(end - 1) === "\0")
        end--;
      return result2.slice(start, end).split("\0").map(transform).join(delimiter);
    }
    exports.noCase = noCase;
    function replace(input, re, value) {
      if (re instanceof RegExp)
        return input.replace(re, value);
      return re.reduce(function(input2, re2) {
        return input2.replace(re2, value);
      }, input);
    }
  }
});

// node_modules/dot-case/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/dot-case/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dotCase = void 0;
    var tslib_1 = require_tslib();
    var no_case_1 = require_dist2();
    function dotCase(input, options) {
      if (options === void 0) {
        options = {};
      }
      return no_case_1.noCase(input, tslib_1.__assign({ delimiter: "." }, options));
    }
    exports.dotCase = dotCase;
  }
});

// node_modules/param-case/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/param-case/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.paramCase = void 0;
    var tslib_1 = require_tslib();
    var dot_case_1 = require_dist3();
    function paramCase2(input, options) {
      if (options === void 0) {
        options = {};
      }
      return dot_case_1.dotCase(input, tslib_1.__assign({ delimiter: "-" }, options));
    }
    exports.paramCase = paramCase2;
  }
});

// node_modules/@mattiasbuelens/web-streams-adapter/dist/web-streams-adapter.js
var require_web_streams_adapter = __commonJS({
  "node_modules/@mattiasbuelens/web-streams-adapter/dist/web-streams-adapter.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.WebStreamsAdapter = {}));
    })(exports, function(exports2) {
      "use strict";
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      }
      function assert(test) {
        if (!test) {
          throw new TypeError("Assertion failed");
        }
      }
      function noop() {
        return;
      }
      function typeIsObject(x) {
        return typeof x === "object" && x !== null || typeof x === "function";
      }
      function isStreamConstructor(ctor) {
        if (typeof ctor !== "function") {
          return false;
        }
        var startCalled = false;
        try {
          new ctor({
            start: function() {
              startCalled = true;
            }
          });
        } catch (e) {
        }
        return startCalled;
      }
      function isReadableStream(readable) {
        if (!typeIsObject(readable)) {
          return false;
        }
        if (typeof readable.getReader !== "function") {
          return false;
        }
        return true;
      }
      function isReadableStreamConstructor(ctor) {
        if (!isStreamConstructor(ctor)) {
          return false;
        }
        if (!isReadableStream(new ctor())) {
          return false;
        }
        return true;
      }
      function isWritableStream(writable) {
        if (!typeIsObject(writable)) {
          return false;
        }
        if (typeof writable.getWriter !== "function") {
          return false;
        }
        return true;
      }
      function isWritableStreamConstructor(ctor) {
        if (!isStreamConstructor(ctor)) {
          return false;
        }
        if (!isWritableStream(new ctor())) {
          return false;
        }
        return true;
      }
      function isTransformStream(transform) {
        if (!typeIsObject(transform)) {
          return false;
        }
        if (!isReadableStream(transform.readable)) {
          return false;
        }
        if (!isWritableStream(transform.writable)) {
          return false;
        }
        return true;
      }
      function isTransformStreamConstructor(ctor) {
        if (!isStreamConstructor(ctor)) {
          return false;
        }
        if (!isTransformStream(new ctor())) {
          return false;
        }
        return true;
      }
      function supportsByobReader(readable) {
        try {
          var reader = readable.getReader({ mode: "byob" });
          reader.releaseLock();
          return true;
        } catch (_a13) {
          return false;
        }
      }
      function supportsByteSource(ctor) {
        try {
          new ctor({ type: "bytes" });
          return true;
        } catch (_a13) {
          return false;
        }
      }
      function createReadableStreamWrapper2(ctor) {
        assert(isReadableStreamConstructor(ctor));
        var byteSourceSupported = supportsByteSource(ctor);
        return function(readable, _a13) {
          var _b4 = _a13 === void 0 ? {} : _a13, type = _b4.type;
          type = parseReadableType(type);
          if (type === "bytes" && !byteSourceSupported) {
            type = void 0;
          }
          if (readable.constructor === ctor) {
            if (type !== "bytes" || supportsByobReader(readable)) {
              return readable;
            }
          }
          if (type === "bytes") {
            var source = createWrappingReadableSource(readable, { type });
            return new ctor(source);
          } else {
            var source = createWrappingReadableSource(readable);
            return new ctor(source);
          }
        };
      }
      function createWrappingReadableSource(readable, _a13) {
        var _b4 = _a13 === void 0 ? {} : _a13, type = _b4.type;
        assert(isReadableStream(readable));
        assert(readable.locked === false);
        type = parseReadableType(type);
        var source;
        if (type === "bytes") {
          source = new WrappingReadableByteStreamSource(readable);
        } else {
          source = new WrappingReadableStreamDefaultSource(readable);
        }
        return source;
      }
      function parseReadableType(type) {
        var typeString = String(type);
        if (typeString === "bytes") {
          return typeString;
        } else if (type === void 0) {
          return type;
        } else {
          throw new RangeError("Invalid type is specified");
        }
      }
      var AbstractWrappingReadableStreamSource = function() {
        function AbstractWrappingReadableStreamSource2(underlyingStream) {
          this._underlyingReader = void 0;
          this._readerMode = void 0;
          this._readableStreamController = void 0;
          this._pendingRead = void 0;
          this._underlyingStream = underlyingStream;
          this._attachDefaultReader();
        }
        AbstractWrappingReadableStreamSource2.prototype.start = function(controller) {
          this._readableStreamController = controller;
        };
        AbstractWrappingReadableStreamSource2.prototype.cancel = function(reason) {
          assert(this._underlyingReader !== void 0);
          return this._underlyingReader.cancel(reason);
        };
        AbstractWrappingReadableStreamSource2.prototype._attachDefaultReader = function() {
          if (this._readerMode === "default") {
            return;
          }
          this._detachReader();
          var reader = this._underlyingStream.getReader();
          this._readerMode = "default";
          this._attachReader(reader);
        };
        AbstractWrappingReadableStreamSource2.prototype._attachReader = function(reader) {
          var _this = this;
          assert(this._underlyingReader === void 0);
          this._underlyingReader = reader;
          var closed = this._underlyingReader.closed;
          if (!closed) {
            return;
          }
          closed.then(function() {
            return _this._finishPendingRead();
          }).then(function() {
            if (reader === _this._underlyingReader) {
              _this._readableStreamController.close();
            }
          }, function(reason) {
            if (reader === _this._underlyingReader) {
              _this._readableStreamController.error(reason);
            }
          }).catch(noop);
        };
        AbstractWrappingReadableStreamSource2.prototype._detachReader = function() {
          if (this._underlyingReader === void 0) {
            return;
          }
          this._underlyingReader.releaseLock();
          this._underlyingReader = void 0;
          this._readerMode = void 0;
        };
        AbstractWrappingReadableStreamSource2.prototype._pullWithDefaultReader = function() {
          var _this = this;
          this._attachDefaultReader();
          var read = this._underlyingReader.read().then(function(result2) {
            var controller = _this._readableStreamController;
            if (result2.done) {
              _this._tryClose();
            } else {
              controller.enqueue(result2.value);
            }
          });
          this._setPendingRead(read);
          return read;
        };
        AbstractWrappingReadableStreamSource2.prototype._tryClose = function() {
          try {
            this._readableStreamController.close();
          } catch (_a13) {
          }
        };
        AbstractWrappingReadableStreamSource2.prototype._setPendingRead = function(readPromise) {
          var _this = this;
          var pendingRead;
          var finishRead = function() {
            if (_this._pendingRead === pendingRead) {
              _this._pendingRead = void 0;
            }
          };
          this._pendingRead = pendingRead = readPromise.then(finishRead, finishRead);
        };
        AbstractWrappingReadableStreamSource2.prototype._finishPendingRead = function() {
          var _this = this;
          if (!this._pendingRead) {
            return void 0;
          }
          var afterRead = function() {
            return _this._finishPendingRead();
          };
          return this._pendingRead.then(afterRead, afterRead);
        };
        return AbstractWrappingReadableStreamSource2;
      }();
      var WrappingReadableStreamDefaultSource = function(_super) {
        __extends(WrappingReadableStreamDefaultSource2, _super);
        function WrappingReadableStreamDefaultSource2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        WrappingReadableStreamDefaultSource2.prototype.pull = function() {
          return this._pullWithDefaultReader();
        };
        return WrappingReadableStreamDefaultSource2;
      }(AbstractWrappingReadableStreamSource);
      function toUint8Array(view) {
        return new Uint8Array(view.buffer, view.byteOffset, view.byteLength);
      }
      function copyArrayBufferView(from, to) {
        var fromArray = toUint8Array(from);
        var toArray = toUint8Array(to);
        toArray.set(fromArray, 0);
      }
      var WrappingReadableByteStreamSource = function(_super) {
        __extends(WrappingReadableByteStreamSource2, _super);
        function WrappingReadableByteStreamSource2(underlyingStream) {
          var _this = this;
          var supportsByob = supportsByobReader(underlyingStream);
          _this = _super.call(this, underlyingStream) || this;
          _this._supportsByob = supportsByob;
          return _this;
        }
        Object.defineProperty(WrappingReadableByteStreamSource2.prototype, "type", {
          get: function() {
            return "bytes";
          },
          enumerable: false,
          configurable: true
        });
        WrappingReadableByteStreamSource2.prototype._attachByobReader = function() {
          if (this._readerMode === "byob") {
            return;
          }
          assert(this._supportsByob);
          this._detachReader();
          var reader = this._underlyingStream.getReader({ mode: "byob" });
          this._readerMode = "byob";
          this._attachReader(reader);
        };
        WrappingReadableByteStreamSource2.prototype.pull = function() {
          if (this._supportsByob) {
            var byobRequest = this._readableStreamController.byobRequest;
            if (byobRequest) {
              return this._pullWithByobRequest(byobRequest);
            }
          }
          return this._pullWithDefaultReader();
        };
        WrappingReadableByteStreamSource2.prototype._pullWithByobRequest = function(byobRequest) {
          var _this = this;
          this._attachByobReader();
          var buffer = new Uint8Array(byobRequest.view.byteLength);
          var read = this._underlyingReader.read(buffer).then(function(result2) {
            _this._readableStreamController;
            if (result2.done) {
              _this._tryClose();
              byobRequest.respond(0);
            } else {
              copyArrayBufferView(result2.value, byobRequest.view);
              byobRequest.respond(result2.value.byteLength);
            }
          });
          this._setPendingRead(read);
          return read;
        };
        return WrappingReadableByteStreamSource2;
      }(AbstractWrappingReadableStreamSource);
      function createWritableStreamWrapper2(ctor) {
        assert(isWritableStreamConstructor(ctor));
        return function(writable) {
          if (writable.constructor === ctor) {
            return writable;
          }
          var sink = createWrappingWritableSink(writable);
          return new ctor(sink);
        };
      }
      function createWrappingWritableSink(writable) {
        assert(isWritableStream(writable));
        assert(writable.locked === false);
        var writer = writable.getWriter();
        return new WrappingWritableStreamSink(writer);
      }
      var WrappingWritableStreamSink = function() {
        function WrappingWritableStreamSink2(underlyingWriter) {
          var _this = this;
          this._writableStreamController = void 0;
          this._pendingWrite = void 0;
          this._state = "writable";
          this._storedError = void 0;
          this._underlyingWriter = underlyingWriter;
          this._errorPromise = new Promise(function(resolve, reject) {
            _this._errorPromiseReject = reject;
          });
          this._errorPromise.catch(noop);
        }
        WrappingWritableStreamSink2.prototype.start = function(controller) {
          var _this = this;
          this._writableStreamController = controller;
          this._underlyingWriter.closed.then(function() {
            _this._state = "closed";
          }).catch(function(reason) {
            return _this._finishErroring(reason);
          });
        };
        WrappingWritableStreamSink2.prototype.write = function(chunk) {
          var _this = this;
          var writer = this._underlyingWriter;
          if (writer.desiredSize === null) {
            return writer.ready;
          }
          var writeRequest = writer.write(chunk);
          writeRequest.catch(function(reason) {
            return _this._finishErroring(reason);
          });
          writer.ready.catch(function(reason) {
            return _this._startErroring(reason);
          });
          var write = Promise.race([writeRequest, this._errorPromise]);
          this._setPendingWrite(write);
          return write;
        };
        WrappingWritableStreamSink2.prototype.close = function() {
          var _this = this;
          if (this._pendingWrite === void 0) {
            return this._underlyingWriter.close();
          }
          return this._finishPendingWrite().then(function() {
            return _this.close();
          });
        };
        WrappingWritableStreamSink2.prototype.abort = function(reason) {
          if (this._state === "errored") {
            return void 0;
          }
          var writer = this._underlyingWriter;
          return writer.abort(reason);
        };
        WrappingWritableStreamSink2.prototype._setPendingWrite = function(writePromise) {
          var _this = this;
          var pendingWrite;
          var finishWrite = function() {
            if (_this._pendingWrite === pendingWrite) {
              _this._pendingWrite = void 0;
            }
          };
          this._pendingWrite = pendingWrite = writePromise.then(finishWrite, finishWrite);
        };
        WrappingWritableStreamSink2.prototype._finishPendingWrite = function() {
          var _this = this;
          if (this._pendingWrite === void 0) {
            return Promise.resolve();
          }
          var afterWrite = function() {
            return _this._finishPendingWrite();
          };
          return this._pendingWrite.then(afterWrite, afterWrite);
        };
        WrappingWritableStreamSink2.prototype._startErroring = function(reason) {
          var _this = this;
          if (this._state === "writable") {
            this._state = "erroring";
            this._storedError = reason;
            var afterWrite = function() {
              return _this._finishErroring(reason);
            };
            if (this._pendingWrite === void 0) {
              afterWrite();
            } else {
              this._finishPendingWrite().then(afterWrite, afterWrite);
            }
            this._writableStreamController.error(reason);
          }
        };
        WrappingWritableStreamSink2.prototype._finishErroring = function(reason) {
          if (this._state === "writable") {
            this._startErroring(reason);
          }
          if (this._state === "erroring") {
            this._state = "errored";
            this._errorPromiseReject(this._storedError);
          }
        };
        return WrappingWritableStreamSink2;
      }();
      function createTransformStreamWrapper(ctor) {
        assert(isTransformStreamConstructor(ctor));
        return function(transform) {
          if (transform.constructor === ctor) {
            return transform;
          }
          var transformer = createWrappingTransformer(transform);
          return new ctor(transformer);
        };
      }
      function createWrappingTransformer(transform) {
        assert(isTransformStream(transform));
        var readable = transform.readable, writable = transform.writable;
        assert(readable.locked === false);
        assert(writable.locked === false);
        var reader = readable.getReader();
        var writer;
        try {
          writer = writable.getWriter();
        } catch (e) {
          reader.releaseLock();
          throw e;
        }
        return new WrappingTransformStreamTransformer(reader, writer);
      }
      var WrappingTransformStreamTransformer = function() {
        function WrappingTransformStreamTransformer2(reader, writer) {
          var _this = this;
          this._transformStreamController = void 0;
          this._onRead = function(result2) {
            if (result2.done) {
              return;
            }
            _this._transformStreamController.enqueue(result2.value);
            return _this._reader.read().then(_this._onRead);
          };
          this._onError = function(reason) {
            _this._flushReject(reason);
            _this._transformStreamController.error(reason);
            _this._reader.cancel(reason).catch(noop);
            _this._writer.abort(reason).catch(noop);
          };
          this._onTerminate = function() {
            _this._flushResolve();
            _this._transformStreamController.terminate();
            var error = new TypeError("TransformStream terminated");
            _this._writer.abort(error).catch(noop);
          };
          this._reader = reader;
          this._writer = writer;
          this._flushPromise = new Promise(function(resolve, reject) {
            _this._flushResolve = resolve;
            _this._flushReject = reject;
          });
        }
        WrappingTransformStreamTransformer2.prototype.start = function(controller) {
          this._transformStreamController = controller;
          this._reader.read().then(this._onRead).then(this._onTerminate, this._onError);
          var readerClosed = this._reader.closed;
          if (readerClosed) {
            readerClosed.then(this._onTerminate, this._onError);
          }
        };
        WrappingTransformStreamTransformer2.prototype.transform = function(chunk) {
          return this._writer.write(chunk);
        };
        WrappingTransformStreamTransformer2.prototype.flush = function() {
          var _this = this;
          return this._writer.close().then(function() {
            return _this._flushPromise;
          });
        };
        return WrappingTransformStreamTransformer2;
      }();
      exports2.createReadableStreamWrapper = createReadableStreamWrapper2;
      exports2.createTransformStreamWrapper = createTransformStreamWrapper;
      exports2.createWrappingReadableSource = createWrappingReadableSource;
      exports2.createWrappingTransformer = createWrappingTransformer;
      exports2.createWrappingWritableSink = createWrappingWritableSink;
      exports2.createWritableStreamWrapper = createWritableStreamWrapper2;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/data-uri-to-buffer/dist/src/index.js
var require_src = __commonJS({
  "node_modules/data-uri-to-buffer/dist/src/index.js"(exports, module2) {
    "use strict";
    function dataUriToBuffer2(uri) {
      if (!/^data:/i.test(uri)) {
        throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
      }
      uri = uri.replace(/\r?\n/g, "");
      const firstComma = uri.indexOf(",");
      if (firstComma === -1 || firstComma <= 4) {
        throw new TypeError("malformed data: URI");
      }
      const meta = uri.substring(5, firstComma).split(";");
      let charset = "";
      let base64 = false;
      const type = meta[0] || "text/plain";
      let typeFull = type;
      for (let i = 1; i < meta.length; i++) {
        if (meta[i] === "base64") {
          base64 = true;
        } else {
          typeFull += `;${meta[i]}`;
          if (meta[i].indexOf("charset=") === 0) {
            charset = meta[i].substring(8);
          }
        }
      }
      if (!meta[0] && !charset.length) {
        typeFull += ";charset=US-ASCII";
        charset = "US-ASCII";
      }
      const encoding = base64 ? "base64" : "ascii";
      const data = unescape(uri.substring(firstComma + 1));
      const buffer = Buffer.from(data, encoding);
      buffer.type = type;
      buffer.typeFull = typeFull;
      buffer.charset = charset;
      return buffer;
    }
    module2.exports = dataUriToBuffer2;
  }
});

// node_modules/fetch-blob/index.js
var require_fetch_blob = __commonJS({
  "node_modules/fetch-blob/index.js"(exports, module2) {
    var { Readable } = require("stream");
    var wm = new WeakMap();
    async function* read(parts) {
      for (const part of parts) {
        if ("stream" in part) {
          yield* part.stream();
        } else {
          yield part;
        }
      }
    }
    var Blob3 = class {
      constructor(blobParts = [], options = {}) {
        let size = 0;
        const parts = blobParts.map((element) => {
          let buffer;
          if (element instanceof Buffer) {
            buffer = element;
          } else if (ArrayBuffer.isView(element)) {
            buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
          } else if (element instanceof ArrayBuffer) {
            buffer = Buffer.from(element);
          } else if (element instanceof Blob3) {
            buffer = element;
          } else {
            buffer = Buffer.from(typeof element === "string" ? element : String(element));
          }
          size += buffer.length || buffer.size || 0;
          return buffer;
        });
        const type = options.type === void 0 ? "" : String(options.type).toLowerCase();
        wm.set(this, {
          type: /[^\u0020-\u007E]/.test(type) ? "" : type,
          size,
          parts
        });
      }
      get size() {
        return wm.get(this).size;
      }
      get type() {
        return wm.get(this).type;
      }
      async text() {
        return Buffer.from(await this.arrayBuffer()).toString();
      }
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of this.stream()) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        return Readable.from(read(wm.get(this).parts));
      }
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = wm.get(this).parts.values();
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            const chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
            blobParts.push(chunk);
            added += ArrayBuffer.isView(chunk) ? chunk.byteLength : chunk.size;
            relativeStart = 0;
            if (added >= span) {
              break;
            }
          }
        }
        const blob = new Blob3([], { type: String(type).toLowerCase() });
        Object.assign(wm.get(blob), { size: span, parts: blobParts });
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.stream === "function" && object.stream.length === 0 && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    };
    Object.defineProperties(Blob3.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    module2.exports = Blob3;
  }
});

// node_modules/web-streams-polyfill/dist/ponyfill.es2018.js
var require_ponyfill_es2018 = __commonJS({
  "node_modules/web-streams-polyfill/dist/ponyfill.es2018.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.WebStreamsPolyfill = {}));
    })(exports, function(exports2) {
      "use strict";
      const SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : (description) => `Symbol(${description})`;
      function noop() {
        return void 0;
      }
      function getGlobals() {
        if (typeof self !== "undefined") {
          return self;
        } else if (typeof window !== "undefined") {
          return window;
        } else if (typeof global !== "undefined") {
          return global;
        }
        return void 0;
      }
      const globals = getGlobals();
      function typeIsObject(x) {
        return typeof x === "object" && x !== null || typeof x === "function";
      }
      const rethrowAssertionErrorRejection = noop;
      const originalPromise = Promise;
      const originalPromiseThen = Promise.prototype.then;
      const originalPromiseResolve = Promise.resolve.bind(originalPromise);
      const originalPromiseReject = Promise.reject.bind(originalPromise);
      function newPromise(executor) {
        return new originalPromise(executor);
      }
      function promiseResolvedWith(value) {
        return originalPromiseResolve(value);
      }
      function promiseRejectedWith(reason) {
        return originalPromiseReject(reason);
      }
      function PerformPromiseThen(promise, onFulfilled, onRejected) {
        return originalPromiseThen.call(promise, onFulfilled, onRejected);
      }
      function uponPromise(promise, onFulfilled, onRejected) {
        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
      }
      function uponFulfillment(promise, onFulfilled) {
        uponPromise(promise, onFulfilled);
      }
      function uponRejection(promise, onRejected) {
        uponPromise(promise, void 0, onRejected);
      }
      function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
      }
      function setPromiseIsHandledToTrue(promise) {
        PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
      }
      const queueMicrotask = (() => {
        const globalQueueMicrotask = globals && globals.queueMicrotask;
        if (typeof globalQueueMicrotask === "function") {
          return globalQueueMicrotask;
        }
        const resolvedPromise = promiseResolvedWith(void 0);
        return (fn) => PerformPromiseThen(resolvedPromise, fn);
      })();
      function reflectCall(F, V, args) {
        if (typeof F !== "function") {
          throw new TypeError("Argument is not a function");
        }
        return Function.prototype.apply.call(F, V, args);
      }
      function promiseCall(F, V, args) {
        try {
          return promiseResolvedWith(reflectCall(F, V, args));
        } catch (value) {
          return promiseRejectedWith(value);
        }
      }
      const QUEUE_MAX_ARRAY_SIZE = 16384;
      class SimpleQueue {
        constructor() {
          this._cursor = 0;
          this._size = 0;
          this._front = {
            _elements: [],
            _next: void 0
          };
          this._back = this._front;
          this._cursor = 0;
          this._size = 0;
        }
        get length() {
          return this._size;
        }
        push(element) {
          const oldBack = this._back;
          let newBack = oldBack;
          if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
            newBack = {
              _elements: [],
              _next: void 0
            };
          }
          oldBack._elements.push(element);
          if (newBack !== oldBack) {
            this._back = newBack;
            oldBack._next = newBack;
          }
          ++this._size;
        }
        shift() {
          const oldFront = this._front;
          let newFront = oldFront;
          const oldCursor = this._cursor;
          let newCursor = oldCursor + 1;
          const elements = oldFront._elements;
          const element = elements[oldCursor];
          if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
            newFront = oldFront._next;
            newCursor = 0;
          }
          --this._size;
          this._cursor = newCursor;
          if (oldFront !== newFront) {
            this._front = newFront;
          }
          elements[oldCursor] = void 0;
          return element;
        }
        forEach(callback) {
          let i = this._cursor;
          let node = this._front;
          let elements = node._elements;
          while (i !== elements.length || node._next !== void 0) {
            if (i === elements.length) {
              node = node._next;
              elements = node._elements;
              i = 0;
              if (elements.length === 0) {
                break;
              }
            }
            callback(elements[i]);
            ++i;
          }
        }
        peek() {
          const front = this._front;
          const cursor = this._cursor;
          return front._elements[cursor];
        }
      }
      function ReadableStreamReaderGenericInitialize(reader, stream) {
        reader._ownerReadableStream = stream;
        stream._reader = reader;
        if (stream._state === "readable") {
          defaultReaderClosedPromiseInitialize(reader);
        } else if (stream._state === "closed") {
          defaultReaderClosedPromiseInitializeAsResolved(reader);
        } else {
          defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
        }
      }
      function ReadableStreamReaderGenericCancel(reader, reason) {
        const stream = reader._ownerReadableStream;
        return ReadableStreamCancel(stream, reason);
      }
      function ReadableStreamReaderGenericRelease(reader) {
        if (reader._ownerReadableStream._state === "readable") {
          defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        } else {
          defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        }
        reader._ownerReadableStream._reader = void 0;
        reader._ownerReadableStream = void 0;
      }
      function readerLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released reader");
      }
      function defaultReaderClosedPromiseInitialize(reader) {
        reader._closedPromise = newPromise((resolve, reject) => {
          reader._closedPromise_resolve = resolve;
          reader._closedPromise_reject = reject;
        });
      }
      function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseReject(reader, reason);
      }
      function defaultReaderClosedPromiseInitializeAsResolved(reader) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseResolve(reader);
      }
      function defaultReaderClosedPromiseReject(reader, reason) {
        if (reader._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(reader._closedPromise);
        reader._closedPromise_reject(reason);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      function defaultReaderClosedPromiseResetToRejected(reader, reason) {
        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
      }
      function defaultReaderClosedPromiseResolve(reader) {
        if (reader._closedPromise_resolve === void 0) {
          return;
        }
        reader._closedPromise_resolve(void 0);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      const AbortSteps = SymbolPolyfill("[[AbortSteps]]");
      const ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
      const CancelSteps = SymbolPolyfill("[[CancelSteps]]");
      const PullSteps = SymbolPolyfill("[[PullSteps]]");
      const NumberIsFinite = Number.isFinite || function(x) {
        return typeof x === "number" && isFinite(x);
      };
      const MathTrunc = Math.trunc || function(v) {
        return v < 0 ? Math.ceil(v) : Math.floor(v);
      };
      function isDictionary(x) {
        return typeof x === "object" || typeof x === "function";
      }
      function assertDictionary(obj, context) {
        if (obj !== void 0 && !isDictionary(obj)) {
          throw new TypeError(`${context} is not an object.`);
        }
      }
      function assertFunction(x, context) {
        if (typeof x !== "function") {
          throw new TypeError(`${context} is not a function.`);
        }
      }
      function isObject2(x) {
        return typeof x === "object" && x !== null || typeof x === "function";
      }
      function assertObject(x, context) {
        if (!isObject2(x)) {
          throw new TypeError(`${context} is not an object.`);
        }
      }
      function assertRequiredArgument(x, position, context) {
        if (x === void 0) {
          throw new TypeError(`Parameter ${position} is required in '${context}'.`);
        }
      }
      function assertRequiredField(x, field, context) {
        if (x === void 0) {
          throw new TypeError(`${field} is required in '${context}'.`);
        }
      }
      function convertUnrestrictedDouble(value) {
        return Number(value);
      }
      function censorNegativeZero(x) {
        return x === 0 ? 0 : x;
      }
      function integerPart(x) {
        return censorNegativeZero(MathTrunc(x));
      }
      function convertUnsignedLongLongWithEnforceRange(value, context) {
        const lowerBound = 0;
        const upperBound = Number.MAX_SAFE_INTEGER;
        let x = Number(value);
        x = censorNegativeZero(x);
        if (!NumberIsFinite(x)) {
          throw new TypeError(`${context} is not a finite number`);
        }
        x = integerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
        }
        if (!NumberIsFinite(x) || x === 0) {
          return 0;
        }
        return x;
      }
      function assertReadableStream(x, context) {
        if (!IsReadableStream(x)) {
          throw new TypeError(`${context} is not a ReadableStream.`);
        }
      }
      function AcquireReadableStreamDefaultReader(stream) {
        return new ReadableStreamDefaultReader(stream);
      }
      function ReadableStreamAddReadRequest(stream, readRequest) {
        stream._reader._readRequests.push(readRequest);
      }
      function ReadableStreamFulfillReadRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readRequest = reader._readRequests.shift();
        if (done) {
          readRequest._closeSteps();
        } else {
          readRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadRequests(stream) {
        return stream._reader._readRequests.length;
      }
      function ReadableStreamHasDefaultReader(stream) {
        const reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamDefaultReader(reader)) {
          return false;
        }
        return true;
      }
      class ReadableStreamDefaultReader {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readRequests = new SimpleQueue();
        }
        get closed() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        cancel(reason = void 0) {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        }
        read() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("read"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve, reject) => {
            resolvePromise = resolve;
            rejectPromise = reject;
          });
          const readRequest = {
            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
            _closeSteps: () => resolvePromise({ value: void 0, done: true }),
            _errorSteps: (e) => rejectPromise(e)
          };
          ReadableStreamDefaultReaderRead(this, readRequest);
          return promise;
        }
        releaseLock() {
          if (!IsReadableStreamDefaultReader(this)) {
            throw defaultReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === void 0) {
            return;
          }
          if (this._readRequests.length > 0) {
            throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
          }
          ReadableStreamReaderGenericRelease(this);
        }
      }
      Object.defineProperties(ReadableStreamDefaultReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamDefaultReader",
          configurable: true
        });
      }
      function IsReadableStreamDefaultReader(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_readRequests")) {
          return false;
        }
        return x instanceof ReadableStreamDefaultReader;
      }
      function ReadableStreamDefaultReaderRead(reader, readRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "closed") {
          readRequest._closeSteps();
        } else if (stream._state === "errored") {
          readRequest._errorSteps(stream._storedError);
        } else {
          stream._readableStreamController[PullSteps](readRequest);
        }
      }
      function defaultReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
      }
      const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
      }).prototype);
      class ReadableStreamAsyncIteratorImpl {
        constructor(reader, preventCancel) {
          this._ongoingPromise = void 0;
          this._isFinished = false;
          this._reader = reader;
          this._preventCancel = preventCancel;
        }
        next() {
          const nextSteps = () => this._nextSteps();
          this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
          return this._ongoingPromise;
        }
        return(value) {
          const returnSteps = () => this._returnSteps(value);
          return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
        }
        _nextSteps() {
          if (this._isFinished) {
            return Promise.resolve({ value: void 0, done: true });
          }
          const reader = this._reader;
          if (reader._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("iterate"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve, reject) => {
            resolvePromise = resolve;
            rejectPromise = reject;
          });
          const readRequest = {
            _chunkSteps: (chunk) => {
              this._ongoingPromise = void 0;
              queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
            },
            _closeSteps: () => {
              this._ongoingPromise = void 0;
              this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              resolvePromise({ value: void 0, done: true });
            },
            _errorSteps: (reason) => {
              this._ongoingPromise = void 0;
              this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              rejectPromise(reason);
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promise;
        }
        _returnSteps(value) {
          if (this._isFinished) {
            return Promise.resolve({ value, done: true });
          }
          this._isFinished = true;
          const reader = this._reader;
          if (reader._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("finish iterating"));
          }
          if (!this._preventCancel) {
            const result2 = ReadableStreamReaderGenericCancel(reader, value);
            ReadableStreamReaderGenericRelease(reader);
            return transformPromiseWith(result2, () => ({ value, done: true }));
          }
          ReadableStreamReaderGenericRelease(reader);
          return promiseResolvedWith({ value, done: true });
        }
      }
      const ReadableStreamAsyncIteratorPrototype = {
        next() {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
          }
          return this._asyncIteratorImpl.next();
        },
        return(value) {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
          }
          return this._asyncIteratorImpl.return(value);
        }
      };
      if (AsyncIteratorPrototype !== void 0) {
        Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
      }
      function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
        const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
        iterator._asyncIteratorImpl = impl;
        return iterator;
      }
      function IsReadableStreamAsyncIterator(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_asyncIteratorImpl")) {
          return false;
        }
        try {
          return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
        } catch (_a13) {
          return false;
        }
      }
      function streamAsyncIteratorBrandCheckException(name) {
        return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
      }
      const NumberIsNaN = Number.isNaN || function(x) {
        return x !== x;
      };
      function CreateArrayFromList(elements) {
        return elements.slice();
      }
      function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
      }
      function TransferArrayBuffer(O) {
        return O;
      }
      function IsDetachedBuffer(O) {
        return false;
      }
      function ArrayBufferSlice(buffer, begin, end) {
        if (buffer.slice) {
          return buffer.slice(begin, end);
        }
        const length = end - begin;
        const slice = new ArrayBuffer(length);
        CopyDataBlockBytes(slice, 0, buffer, begin, length);
        return slice;
      }
      function IsNonNegativeNumber(v) {
        if (typeof v !== "number") {
          return false;
        }
        if (NumberIsNaN(v)) {
          return false;
        }
        if (v < 0) {
          return false;
        }
        return true;
      }
      function CloneAsUint8Array(O) {
        const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
        return new Uint8Array(buffer);
      }
      function DequeueValue(container) {
        const pair = container._queue.shift();
        container._queueTotalSize -= pair.size;
        if (container._queueTotalSize < 0) {
          container._queueTotalSize = 0;
        }
        return pair.value;
      }
      function EnqueueValueWithSize(container, value, size) {
        if (!IsNonNegativeNumber(size) || size === Infinity) {
          throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
        }
        container._queue.push({ value, size });
        container._queueTotalSize += size;
      }
      function PeekQueueValue(container) {
        const pair = container._queue.peek();
        return pair.value;
      }
      function ResetQueue(container) {
        container._queue = new SimpleQueue();
        container._queueTotalSize = 0;
      }
      class ReadableStreamBYOBRequest {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get view() {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("view");
          }
          return this._view;
        }
        respond(bytesWritten) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respond");
          }
          assertRequiredArgument(bytesWritten, 1, "respond");
          bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
          if (this._associatedReadableByteStreamController === void 0) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          if (IsDetachedBuffer(this._view.buffer))
            ;
          ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
        }
        respondWithNewView(view) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respondWithNewView");
          }
          assertRequiredArgument(view, 1, "respondWithNewView");
          if (!ArrayBuffer.isView(view)) {
            throw new TypeError("You can only respond with array buffer views");
          }
          if (this._associatedReadableByteStreamController === void 0) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          if (IsDetachedBuffer(view.buffer))
            ;
          ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
        }
      }
      Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
        respond: { enumerable: true },
        respondWithNewView: { enumerable: true },
        view: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamBYOBRequest",
          configurable: true
        });
      }
      class ReadableByteStreamController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get byobRequest() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("byobRequest");
          }
          return ReadableByteStreamControllerGetBYOBRequest(this);
        }
        get desiredSize() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("desiredSize");
          }
          return ReadableByteStreamControllerGetDesiredSize(this);
        }
        close() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("close");
          }
          if (this._closeRequested) {
            throw new TypeError("The stream has already been closed; do not close it again!");
          }
          const state = this._controlledReadableByteStream._state;
          if (state !== "readable") {
            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
          }
          ReadableByteStreamControllerClose(this);
        }
        enqueue(chunk) {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("enqueue");
          }
          assertRequiredArgument(chunk, 1, "enqueue");
          if (!ArrayBuffer.isView(chunk)) {
            throw new TypeError("chunk must be an array buffer view");
          }
          if (chunk.byteLength === 0) {
            throw new TypeError("chunk must have non-zero byteLength");
          }
          if (chunk.buffer.byteLength === 0) {
            throw new TypeError(`chunk's buffer must have non-zero byteLength`);
          }
          if (this._closeRequested) {
            throw new TypeError("stream is closed or draining");
          }
          const state = this._controlledReadableByteStream._state;
          if (state !== "readable") {
            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
          }
          ReadableByteStreamControllerEnqueue(this, chunk);
        }
        error(e = void 0) {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("error");
          }
          ReadableByteStreamControllerError(this, e);
        }
        [CancelSteps](reason) {
          ReadableByteStreamControllerClearPendingPullIntos(this);
          ResetQueue(this);
          const result2 = this._cancelAlgorithm(reason);
          ReadableByteStreamControllerClearAlgorithms(this);
          return result2;
        }
        [PullSteps](readRequest) {
          const stream = this._controlledReadableByteStream;
          if (this._queueTotalSize > 0) {
            const entry = this._queue.shift();
            this._queueTotalSize -= entry.byteLength;
            ReadableByteStreamControllerHandleQueueDrain(this);
            const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
            readRequest._chunkSteps(view);
            return;
          }
          const autoAllocateChunkSize = this._autoAllocateChunkSize;
          if (autoAllocateChunkSize !== void 0) {
            let buffer;
            try {
              buffer = new ArrayBuffer(autoAllocateChunkSize);
            } catch (bufferE) {
              readRequest._errorSteps(bufferE);
              return;
            }
            const pullIntoDescriptor = {
              buffer,
              bufferByteLength: autoAllocateChunkSize,
              byteOffset: 0,
              byteLength: autoAllocateChunkSize,
              bytesFilled: 0,
              elementSize: 1,
              viewConstructor: Uint8Array,
              readerType: "default"
            };
            this._pendingPullIntos.push(pullIntoDescriptor);
          }
          ReadableStreamAddReadRequest(stream, readRequest);
          ReadableByteStreamControllerCallPullIfNeeded(this);
        }
      }
      Object.defineProperties(ReadableByteStreamController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        byobRequest: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableByteStreamController",
          configurable: true
        });
      }
      function IsReadableByteStreamController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableByteStream")) {
          return false;
        }
        return x instanceof ReadableByteStreamController;
      }
      function IsReadableStreamBYOBRequest(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController")) {
          return false;
        }
        return x instanceof ReadableStreamBYOBRequest;
      }
      function ReadableByteStreamControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
        }, (e) => {
          ReadableByteStreamControllerError(controller, e);
        });
      }
      function ReadableByteStreamControllerClearPendingPullIntos(controller) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        controller._pendingPullIntos = new SimpleQueue();
      }
      function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
        let done = false;
        if (stream._state === "closed") {
          done = true;
        }
        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === "default") {
          ReadableStreamFulfillReadRequest(stream, filledView, done);
        } else {
          ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
        }
      }
      function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
        const bytesFilled = pullIntoDescriptor.bytesFilled;
        const elementSize = pullIntoDescriptor.elementSize;
        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
      }
      function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
        controller._queue.push({ buffer, byteOffset, byteLength });
        controller._queueTotalSize += byteLength;
      }
      function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
        const elementSize = pullIntoDescriptor.elementSize;
        const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
        const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
        const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
        const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
        let totalBytesToCopyRemaining = maxBytesToCopy;
        let ready = false;
        if (maxAlignedBytes > currentAlignedBytes) {
          totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
          ready = true;
        }
        const queue = controller._queue;
        while (totalBytesToCopyRemaining > 0) {
          const headOfQueue = queue.peek();
          const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
          const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
          if (headOfQueue.byteLength === bytesToCopy) {
            queue.shift();
          } else {
            headOfQueue.byteOffset += bytesToCopy;
            headOfQueue.byteLength -= bytesToCopy;
          }
          controller._queueTotalSize -= bytesToCopy;
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
          totalBytesToCopyRemaining -= bytesToCopy;
        }
        return ready;
      }
      function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
        pullIntoDescriptor.bytesFilled += size;
      }
      function ReadableByteStreamControllerHandleQueueDrain(controller) {
        if (controller._queueTotalSize === 0 && controller._closeRequested) {
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(controller._controlledReadableByteStream);
        } else {
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
      }
      function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
        if (controller._byobRequest === null) {
          return;
        }
        controller._byobRequest._associatedReadableByteStreamController = void 0;
        controller._byobRequest._view = null;
        controller._byobRequest = null;
      }
      function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
        while (controller._pendingPullIntos.length > 0) {
          if (controller._queueTotalSize === 0) {
            return;
          }
          const pullIntoDescriptor = controller._pendingPullIntos.peek();
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
        const stream = controller._controlledReadableByteStream;
        let elementSize = 1;
        if (view.constructor !== DataView) {
          elementSize = view.constructor.BYTES_PER_ELEMENT;
        }
        const ctor = view.constructor;
        const buffer = TransferArrayBuffer(view.buffer);
        const pullIntoDescriptor = {
          buffer,
          bufferByteLength: buffer.byteLength,
          byteOffset: view.byteOffset,
          byteLength: view.byteLength,
          bytesFilled: 0,
          elementSize,
          viewConstructor: ctor,
          readerType: "byob"
        };
        if (controller._pendingPullIntos.length > 0) {
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          return;
        }
        if (stream._state === "closed") {
          const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
          readIntoRequest._closeSteps(emptyView);
          return;
        }
        if (controller._queueTotalSize > 0) {
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
            ReadableByteStreamControllerHandleQueueDrain(controller);
            readIntoRequest._chunkSteps(filledView);
            return;
          }
          if (controller._closeRequested) {
            const e = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e);
            readIntoRequest._errorSteps(e);
            return;
          }
        }
        controller._pendingPullIntos.push(pullIntoDescriptor);
        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
        const stream = controller._controlledReadableByteStream;
        if (ReadableStreamHasBYOBReader(stream)) {
          while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
          return;
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
        if (remainderSize > 0) {
          const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
        }
        pullIntoDescriptor.bytesFilled -= remainderSize;
        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
      }
      function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          ReadableByteStreamControllerRespondInClosedState(controller);
        } else {
          ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerShiftPendingPullInto(controller) {
        const descriptor = controller._pendingPullIntos.shift();
        return descriptor;
      }
      function ReadableByteStreamControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return false;
        }
        if (controller._closeRequested) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
          return true;
        }
        const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableByteStreamControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
      }
      function ReadableByteStreamControllerClose(controller) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        if (controller._queueTotalSize > 0) {
          controller._closeRequested = true;
          return;
        }
        if (controller._pendingPullIntos.length > 0) {
          const firstPendingPullInto = controller._pendingPullIntos.peek();
          if (firstPendingPullInto.bytesFilled > 0) {
            const e = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e);
            throw e;
          }
        }
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamClose(stream);
      }
      function ReadableByteStreamControllerEnqueue(controller, chunk) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        const buffer = chunk.buffer;
        const byteOffset = chunk.byteOffset;
        const byteLength = chunk.byteLength;
        const transferredBuffer = TransferArrayBuffer(buffer);
        if (controller._pendingPullIntos.length > 0) {
          const firstPendingPullInto = controller._pendingPullIntos.peek();
          if (IsDetachedBuffer(firstPendingPullInto.buffer))
            ;
          firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
        }
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        if (ReadableStreamHasDefaultReader(stream)) {
          if (ReadableStreamGetNumReadRequests(stream) === 0) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          } else {
            const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
            ReadableStreamFulfillReadRequest(stream, transferredView, false);
          }
        } else if (ReadableStreamHasBYOBReader(stream)) {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        } else {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerError(controller, e) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return;
        }
        ReadableByteStreamControllerClearPendingPullIntos(controller);
        ResetQueue(controller);
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e);
      }
      function ReadableByteStreamControllerGetBYOBRequest(controller) {
        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
          const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
          SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
          controller._byobRequest = byobRequest;
        }
        return controller._byobRequest;
      }
      function ReadableByteStreamControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableByteStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableByteStreamControllerRespond(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (bytesWritten !== 0) {
            throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
          }
        } else {
          if (bytesWritten === 0) {
            throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
          }
          if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
            throw new RangeError("bytesWritten out of range");
          }
        }
        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
      }
      function ReadableByteStreamControllerRespondWithNewView(controller, view) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (view.byteLength !== 0) {
            throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
          }
        } else {
          if (view.byteLength === 0) {
            throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
          }
        }
        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
          throw new RangeError("The region specified by view does not match byobRequest");
        }
        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
          throw new RangeError("The buffer of view has different capacity than byobRequest");
        }
        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
          throw new RangeError("The region specified by view is larger than byobRequest");
        }
        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
        ReadableByteStreamControllerRespondInternal(controller, view.byteLength);
      }
      function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
        controller._controlledReadableByteStream = stream;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._byobRequest = null;
        controller._queue = controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._closeRequested = false;
        controller._started = false;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._autoAllocateChunkSize = autoAllocateChunkSize;
        controller._pendingPullIntos = new SimpleQueue();
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
          controller._started = true;
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }, (r) => {
          ReadableByteStreamControllerError(controller, r);
        });
      }
      function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
        const controller = Object.create(ReadableByteStreamController.prototype);
        let startAlgorithm = () => void 0;
        let pullAlgorithm = () => promiseResolvedWith(void 0);
        let cancelAlgorithm = () => promiseResolvedWith(void 0);
        if (underlyingByteSource.start !== void 0) {
          startAlgorithm = () => underlyingByteSource.start(controller);
        }
        if (underlyingByteSource.pull !== void 0) {
          pullAlgorithm = () => underlyingByteSource.pull(controller);
        }
        if (underlyingByteSource.cancel !== void 0) {
          cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
        }
        const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (autoAllocateChunkSize === 0) {
          throw new TypeError("autoAllocateChunkSize must be greater than 0");
        }
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
      }
      function SetUpReadableStreamBYOBRequest(request, controller, view) {
        request._associatedReadableByteStreamController = controller;
        request._view = view;
      }
      function byobRequestBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
      }
      function byteStreamControllerBrandCheckException(name) {
        return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
      }
      function AcquireReadableStreamBYOBReader(stream) {
        return new ReadableStreamBYOBReader(stream);
      }
      function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
        stream._reader._readIntoRequests.push(readIntoRequest);
      }
      function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readIntoRequest = reader._readIntoRequests.shift();
        if (done) {
          readIntoRequest._closeSteps(chunk);
        } else {
          readIntoRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadIntoRequests(stream) {
        return stream._reader._readIntoRequests.length;
      }
      function ReadableStreamHasBYOBReader(stream) {
        const reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamBYOBReader(reader)) {
          return false;
        }
        return true;
      }
      class ReadableStreamBYOBReader {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          }
          if (!IsReadableByteStreamController(stream._readableStreamController)) {
            throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readIntoRequests = new SimpleQueue();
        }
        get closed() {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        cancel(reason = void 0) {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        }
        read(view) {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("read"));
          }
          if (!ArrayBuffer.isView(view)) {
            return promiseRejectedWith(new TypeError("view must be an array buffer view"));
          }
          if (view.byteLength === 0) {
            return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
          }
          if (view.buffer.byteLength === 0) {
            return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
          }
          if (IsDetachedBuffer(view.buffer))
            ;
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve, reject) => {
            resolvePromise = resolve;
            rejectPromise = reject;
          });
          const readIntoRequest = {
            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
            _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
            _errorSteps: (e) => rejectPromise(e)
          };
          ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
          return promise;
        }
        releaseLock() {
          if (!IsReadableStreamBYOBReader(this)) {
            throw byobReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === void 0) {
            return;
          }
          if (this._readIntoRequests.length > 0) {
            throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
          }
          ReadableStreamReaderGenericRelease(this);
        }
      }
      Object.defineProperties(ReadableStreamBYOBReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamBYOBReader",
          configurable: true
        });
      }
      function IsReadableStreamBYOBReader(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests")) {
          return false;
        }
        return x instanceof ReadableStreamBYOBReader;
      }
      function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "errored") {
          readIntoRequest._errorSteps(stream._storedError);
        } else {
          ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
        }
      }
      function byobReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
      }
      function ExtractHighWaterMark(strategy, defaultHWM) {
        const { highWaterMark } = strategy;
        if (highWaterMark === void 0) {
          return defaultHWM;
        }
        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
          throw new RangeError("Invalid highWaterMark");
        }
        return highWaterMark;
      }
      function ExtractSizeAlgorithm(strategy) {
        const { size } = strategy;
        if (!size) {
          return () => 1;
        }
        return size;
      }
      function convertQueuingStrategy(init, context) {
        assertDictionary(init, context);
        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        const size = init === null || init === void 0 ? void 0 : init.size;
        return {
          highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
          size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
        };
      }
      function convertQueuingStrategySize(fn, context) {
        assertFunction(fn, context);
        return (chunk) => convertUnrestrictedDouble(fn(chunk));
      }
      function convertUnderlyingSink(original, context) {
        assertDictionary(original, context);
        const abort = original === null || original === void 0 ? void 0 : original.abort;
        const close = original === null || original === void 0 ? void 0 : original.close;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type = original === null || original === void 0 ? void 0 : original.type;
        const write = original === null || original === void 0 ? void 0 : original.write;
        return {
          abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
          close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
          start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
          write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
          type
        };
      }
      function convertUnderlyingSinkAbortCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSinkCloseCallback(fn, original, context) {
        assertFunction(fn, context);
        return () => promiseCall(fn, original, []);
      }
      function convertUnderlyingSinkStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertUnderlyingSinkWriteCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
      }
      function assertWritableStream(x, context) {
        if (!IsWritableStream(x)) {
          throw new TypeError(`${context} is not a WritableStream.`);
        }
      }
      function isAbortSignal2(value) {
        if (typeof value !== "object" || value === null) {
          return false;
        }
        try {
          return typeof value.aborted === "boolean";
        } catch (_a13) {
          return false;
        }
      }
      const supportsAbortController2 = typeof AbortController === "function";
      function createAbortController() {
        if (supportsAbortController2) {
          return new AbortController();
        }
        return void 0;
      }
      class WritableStream2 {
        constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
          if (rawUnderlyingSink === void 0) {
            rawUnderlyingSink = null;
          } else {
            assertObject(rawUnderlyingSink, "First parameter");
          }
          const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
          const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
          InitializeWritableStream(this);
          const type = underlyingSink.type;
          if (type !== void 0) {
            throw new RangeError("Invalid type is specified");
          }
          const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
          const highWaterMark = ExtractHighWaterMark(strategy, 1);
          SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
        }
        get locked() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("locked");
          }
          return IsWritableStreamLocked(this);
        }
        abort(reason = void 0) {
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("abort"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
          }
          return WritableStreamAbort(this, reason);
        }
        close() {
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("close"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
          }
          if (WritableStreamCloseQueuedOrInFlight(this)) {
            return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
          }
          return WritableStreamClose(this);
        }
        getWriter() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("getWriter");
          }
          return AcquireWritableStreamDefaultWriter(this);
        }
      }
      Object.defineProperties(WritableStream2.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        getWriter: { enumerable: true },
        locked: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStream2.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStream",
          configurable: true
        });
      }
      function AcquireWritableStreamDefaultWriter(stream) {
        return new WritableStreamDefaultWriter(stream);
      }
      function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(WritableStream2.prototype);
        InitializeWritableStream(stream);
        const controller = Object.create(WritableStreamDefaultController.prototype);
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function InitializeWritableStream(stream) {
        stream._state = "writable";
        stream._storedError = void 0;
        stream._writer = void 0;
        stream._writableStreamController = void 0;
        stream._writeRequests = new SimpleQueue();
        stream._inFlightWriteRequest = void 0;
        stream._closeRequest = void 0;
        stream._inFlightCloseRequest = void 0;
        stream._pendingAbortRequest = void 0;
        stream._backpressure = false;
      }
      function IsWritableStream(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_writableStreamController")) {
          return false;
        }
        return x instanceof WritableStream2;
      }
      function IsWritableStreamLocked(stream) {
        if (stream._writer === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamAbort(stream, reason) {
        var _a13;
        if (stream._state === "closed" || stream._state === "errored") {
          return promiseResolvedWith(void 0);
        }
        stream._writableStreamController._abortReason = reason;
        (_a13 = stream._writableStreamController._abortController) === null || _a13 === void 0 ? void 0 : _a13.abort();
        const state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseResolvedWith(void 0);
        }
        if (stream._pendingAbortRequest !== void 0) {
          return stream._pendingAbortRequest._promise;
        }
        let wasAlreadyErroring = false;
        if (state === "erroring") {
          wasAlreadyErroring = true;
          reason = void 0;
        }
        const promise = newPromise((resolve, reject) => {
          stream._pendingAbortRequest = {
            _promise: void 0,
            _resolve: resolve,
            _reject: reject,
            _reason: reason,
            _wasAlreadyErroring: wasAlreadyErroring
          };
        });
        stream._pendingAbortRequest._promise = promise;
        if (!wasAlreadyErroring) {
          WritableStreamStartErroring(stream, reason);
        }
        return promise;
      }
      function WritableStreamClose(stream) {
        const state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
        }
        const promise = newPromise((resolve, reject) => {
          const closeRequest = {
            _resolve: resolve,
            _reject: reject
          };
          stream._closeRequest = closeRequest;
        });
        const writer = stream._writer;
        if (writer !== void 0 && stream._backpressure && state === "writable") {
          defaultWriterReadyPromiseResolve(writer);
        }
        WritableStreamDefaultControllerClose(stream._writableStreamController);
        return promise;
      }
      function WritableStreamAddWriteRequest(stream) {
        const promise = newPromise((resolve, reject) => {
          const writeRequest = {
            _resolve: resolve,
            _reject: reject
          };
          stream._writeRequests.push(writeRequest);
        });
        return promise;
      }
      function WritableStreamDealWithRejection(stream, error) {
        const state = stream._state;
        if (state === "writable") {
          WritableStreamStartErroring(stream, error);
          return;
        }
        WritableStreamFinishErroring(stream);
      }
      function WritableStreamStartErroring(stream, reason) {
        const controller = stream._writableStreamController;
        stream._state = "erroring";
        stream._storedError = reason;
        const writer = stream._writer;
        if (writer !== void 0) {
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
        }
        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
          WritableStreamFinishErroring(stream);
        }
      }
      function WritableStreamFinishErroring(stream) {
        stream._state = "errored";
        stream._writableStreamController[ErrorSteps]();
        const storedError = stream._storedError;
        stream._writeRequests.forEach((writeRequest) => {
          writeRequest._reject(storedError);
        });
        stream._writeRequests = new SimpleQueue();
        if (stream._pendingAbortRequest === void 0) {
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        const abortRequest = stream._pendingAbortRequest;
        stream._pendingAbortRequest = void 0;
        if (abortRequest._wasAlreadyErroring) {
          abortRequest._reject(storedError);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
        uponPromise(promise, () => {
          abortRequest._resolve();
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        }, (reason) => {
          abortRequest._reject(reason);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        });
      }
      function WritableStreamFinishInFlightWrite(stream) {
        stream._inFlightWriteRequest._resolve(void 0);
        stream._inFlightWriteRequest = void 0;
      }
      function WritableStreamFinishInFlightWriteWithError(stream, error) {
        stream._inFlightWriteRequest._reject(error);
        stream._inFlightWriteRequest = void 0;
        WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamFinishInFlightClose(stream) {
        stream._inFlightCloseRequest._resolve(void 0);
        stream._inFlightCloseRequest = void 0;
        const state = stream._state;
        if (state === "erroring") {
          stream._storedError = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._resolve();
            stream._pendingAbortRequest = void 0;
          }
        }
        stream._state = "closed";
        const writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseResolve(writer);
        }
      }
      function WritableStreamFinishInFlightCloseWithError(stream, error) {
        stream._inFlightCloseRequest._reject(error);
        stream._inFlightCloseRequest = void 0;
        if (stream._pendingAbortRequest !== void 0) {
          stream._pendingAbortRequest._reject(error);
          stream._pendingAbortRequest = void 0;
        }
        WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamCloseQueuedOrInFlight(stream) {
        if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamHasOperationMarkedInFlight(stream) {
        if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamMarkCloseRequestInFlight(stream) {
        stream._inFlightCloseRequest = stream._closeRequest;
        stream._closeRequest = void 0;
      }
      function WritableStreamMarkFirstWriteRequestInFlight(stream) {
        stream._inFlightWriteRequest = stream._writeRequests.shift();
      }
      function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
        if (stream._closeRequest !== void 0) {
          stream._closeRequest._reject(stream._storedError);
          stream._closeRequest = void 0;
        }
        const writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseReject(writer, stream._storedError);
        }
      }
      function WritableStreamUpdateBackpressure(stream, backpressure) {
        const writer = stream._writer;
        if (writer !== void 0 && backpressure !== stream._backpressure) {
          if (backpressure) {
            defaultWriterReadyPromiseReset(writer);
          } else {
            defaultWriterReadyPromiseResolve(writer);
          }
        }
        stream._backpressure = backpressure;
      }
      class WritableStreamDefaultWriter {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
          assertWritableStream(stream, "First parameter");
          if (IsWritableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive writing by another writer");
          }
          this._ownerWritableStream = stream;
          stream._writer = this;
          const state = stream._state;
          if (state === "writable") {
            if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
              defaultWriterReadyPromiseInitialize(this);
            } else {
              defaultWriterReadyPromiseInitializeAsResolved(this);
            }
            defaultWriterClosedPromiseInitialize(this);
          } else if (state === "erroring") {
            defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
            defaultWriterClosedPromiseInitialize(this);
          } else if (state === "closed") {
            defaultWriterReadyPromiseInitializeAsResolved(this);
            defaultWriterClosedPromiseInitializeAsResolved(this);
          } else {
            const storedError = stream._storedError;
            defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
            defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
          }
        }
        get closed() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        get desiredSize() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("desiredSize");
          }
          if (this._ownerWritableStream === void 0) {
            throw defaultWriterLockException("desiredSize");
          }
          return WritableStreamDefaultWriterGetDesiredSize(this);
        }
        get ready() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
          }
          return this._readyPromise;
        }
        abort(reason = void 0) {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
          }
          if (this._ownerWritableStream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("abort"));
          }
          return WritableStreamDefaultWriterAbort(this, reason);
        }
        close() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("close"));
          }
          const stream = this._ownerWritableStream;
          if (stream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("close"));
          }
          if (WritableStreamCloseQueuedOrInFlight(stream)) {
            return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
          }
          return WritableStreamDefaultWriterClose(this);
        }
        releaseLock() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("releaseLock");
          }
          const stream = this._ownerWritableStream;
          if (stream === void 0) {
            return;
          }
          WritableStreamDefaultWriterRelease(this);
        }
        write(chunk = void 0) {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("write"));
          }
          if (this._ownerWritableStream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          return WritableStreamDefaultWriterWrite(this, chunk);
        }
      }
      Object.defineProperties(WritableStreamDefaultWriter.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        releaseLock: { enumerable: true },
        write: { enumerable: true },
        closed: { enumerable: true },
        desiredSize: { enumerable: true },
        ready: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStreamDefaultWriter",
          configurable: true
        });
      }
      function IsWritableStreamDefaultWriter(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_ownerWritableStream")) {
          return false;
        }
        return x instanceof WritableStreamDefaultWriter;
      }
      function WritableStreamDefaultWriterAbort(writer, reason) {
        const stream = writer._ownerWritableStream;
        return WritableStreamAbort(stream, reason);
      }
      function WritableStreamDefaultWriterClose(writer) {
        const stream = writer._ownerWritableStream;
        return WritableStreamClose(stream);
      }
      function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        return WritableStreamDefaultWriterClose(writer);
      }
      function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
        if (writer._closedPromiseState === "pending") {
          defaultWriterClosedPromiseReject(writer, error);
        } else {
          defaultWriterClosedPromiseResetToRejected(writer, error);
        }
      }
      function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
        if (writer._readyPromiseState === "pending") {
          defaultWriterReadyPromiseReject(writer, error);
        } else {
          defaultWriterReadyPromiseResetToRejected(writer, error);
        }
      }
      function WritableStreamDefaultWriterGetDesiredSize(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (state === "errored" || state === "erroring") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
      }
      function WritableStreamDefaultWriterRelease(writer) {
        const stream = writer._ownerWritableStream;
        const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
        stream._writer = void 0;
        writer._ownerWritableStream = void 0;
      }
      function WritableStreamDefaultWriterWrite(writer, chunk) {
        const stream = writer._ownerWritableStream;
        const controller = stream._writableStreamController;
        const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
        if (stream !== writer._ownerWritableStream) {
          return promiseRejectedWith(defaultWriterLockException("write to"));
        }
        const state = stream._state;
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
        }
        if (state === "erroring") {
          return promiseRejectedWith(stream._storedError);
        }
        const promise = WritableStreamAddWriteRequest(stream);
        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
        return promise;
      }
      const closeSentinel = {};
      class WritableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get abortReason() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("abortReason");
          }
          return this._abortReason;
        }
        get signal() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("signal");
          }
          if (this._abortController === void 0) {
            throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
          }
          return this._abortController.signal;
        }
        error(e = void 0) {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("error");
          }
          const state = this._controlledWritableStream._state;
          if (state !== "writable") {
            return;
          }
          WritableStreamDefaultControllerError(this, e);
        }
        [AbortSteps](reason) {
          const result2 = this._abortAlgorithm(reason);
          WritableStreamDefaultControllerClearAlgorithms(this);
          return result2;
        }
        [ErrorSteps]() {
          ResetQueue(this);
        }
      }
      Object.defineProperties(WritableStreamDefaultController.prototype, {
        error: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStreamDefaultController",
          configurable: true
        });
      }
      function IsWritableStreamDefaultController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledWritableStream")) {
          return false;
        }
        return x instanceof WritableStreamDefaultController;
      }
      function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledWritableStream = stream;
        stream._writableStreamController = controller;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._abortReason = void 0;
        controller._abortController = createAbortController();
        controller._started = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._writeAlgorithm = writeAlgorithm;
        controller._closeAlgorithm = closeAlgorithm;
        controller._abortAlgorithm = abortAlgorithm;
        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
        const startResult = startAlgorithm();
        const startPromise = promiseResolvedWith(startResult);
        uponPromise(startPromise, () => {
          controller._started = true;
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, (r) => {
          controller._started = true;
          WritableStreamDealWithRejection(stream, r);
        });
      }
      function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(WritableStreamDefaultController.prototype);
        let startAlgorithm = () => void 0;
        let writeAlgorithm = () => promiseResolvedWith(void 0);
        let closeAlgorithm = () => promiseResolvedWith(void 0);
        let abortAlgorithm = () => promiseResolvedWith(void 0);
        if (underlyingSink.start !== void 0) {
          startAlgorithm = () => underlyingSink.start(controller);
        }
        if (underlyingSink.write !== void 0) {
          writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
        }
        if (underlyingSink.close !== void 0) {
          closeAlgorithm = () => underlyingSink.close();
        }
        if (underlyingSink.abort !== void 0) {
          abortAlgorithm = (reason) => underlyingSink.abort(reason);
        }
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function WritableStreamDefaultControllerClearAlgorithms(controller) {
        controller._writeAlgorithm = void 0;
        controller._closeAlgorithm = void 0;
        controller._abortAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function WritableStreamDefaultControllerClose(controller) {
        EnqueueValueWithSize(controller, closeSentinel, 0);
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
        try {
          return controller._strategySizeAlgorithm(chunk);
        } catch (chunkSizeE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
          return 1;
        }
      }
      function WritableStreamDefaultControllerGetDesiredSize(controller) {
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
        try {
          EnqueueValueWithSize(controller, chunk, chunkSize);
        } catch (enqueueE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
          return;
        }
        const stream = controller._controlledWritableStream;
        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
        const stream = controller._controlledWritableStream;
        if (!controller._started) {
          return;
        }
        if (stream._inFlightWriteRequest !== void 0) {
          return;
        }
        const state = stream._state;
        if (state === "erroring") {
          WritableStreamFinishErroring(stream);
          return;
        }
        if (controller._queue.length === 0) {
          return;
        }
        const value = PeekQueueValue(controller);
        if (value === closeSentinel) {
          WritableStreamDefaultControllerProcessClose(controller);
        } else {
          WritableStreamDefaultControllerProcessWrite(controller, value);
        }
      }
      function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
        if (controller._controlledWritableStream._state === "writable") {
          WritableStreamDefaultControllerError(controller, error);
        }
      }
      function WritableStreamDefaultControllerProcessClose(controller) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkCloseRequestInFlight(stream);
        DequeueValue(controller);
        const sinkClosePromise = controller._closeAlgorithm();
        WritableStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(sinkClosePromise, () => {
          WritableStreamFinishInFlightClose(stream);
        }, (reason) => {
          WritableStreamFinishInFlightCloseWithError(stream, reason);
        });
      }
      function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkFirstWriteRequestInFlight(stream);
        const sinkWritePromise = controller._writeAlgorithm(chunk);
        uponPromise(sinkWritePromise, () => {
          WritableStreamFinishInFlightWrite(stream);
          const state = stream._state;
          DequeueValue(controller);
          if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, (reason) => {
          if (stream._state === "writable") {
            WritableStreamDefaultControllerClearAlgorithms(controller);
          }
          WritableStreamFinishInFlightWriteWithError(stream, reason);
        });
      }
      function WritableStreamDefaultControllerGetBackpressure(controller) {
        const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize <= 0;
      }
      function WritableStreamDefaultControllerError(controller, error) {
        const stream = controller._controlledWritableStream;
        WritableStreamDefaultControllerClearAlgorithms(controller);
        WritableStreamStartErroring(stream, error);
      }
      function streamBrandCheckException$2(name) {
        return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
      }
      function defaultControllerBrandCheckException$2(name) {
        return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
      }
      function defaultWriterBrandCheckException(name) {
        return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
      }
      function defaultWriterLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released writer");
      }
      function defaultWriterClosedPromiseInitialize(writer) {
        writer._closedPromise = newPromise((resolve, reject) => {
          writer._closedPromise_resolve = resolve;
          writer._closedPromise_reject = reject;
          writer._closedPromiseState = "pending";
        });
      }
      function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseReject(writer, reason);
      }
      function defaultWriterClosedPromiseInitializeAsResolved(writer) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseResolve(writer);
      }
      function defaultWriterClosedPromiseReject(writer, reason) {
        if (writer._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._closedPromise);
        writer._closedPromise_reject(reason);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "rejected";
      }
      function defaultWriterClosedPromiseResetToRejected(writer, reason) {
        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterClosedPromiseResolve(writer) {
        if (writer._closedPromise_resolve === void 0) {
          return;
        }
        writer._closedPromise_resolve(void 0);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "resolved";
      }
      function defaultWriterReadyPromiseInitialize(writer) {
        writer._readyPromise = newPromise((resolve, reject) => {
          writer._readyPromise_resolve = resolve;
          writer._readyPromise_reject = reject;
        });
        writer._readyPromiseState = "pending";
      }
      function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseReject(writer, reason);
      }
      function defaultWriterReadyPromiseInitializeAsResolved(writer) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseResolve(writer);
      }
      function defaultWriterReadyPromiseReject(writer, reason) {
        if (writer._readyPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._readyPromise);
        writer._readyPromise_reject(reason);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "rejected";
      }
      function defaultWriterReadyPromiseReset(writer) {
        defaultWriterReadyPromiseInitialize(writer);
      }
      function defaultWriterReadyPromiseResetToRejected(writer, reason) {
        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterReadyPromiseResolve(writer) {
        if (writer._readyPromise_resolve === void 0) {
          return;
        }
        writer._readyPromise_resolve(void 0);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "fulfilled";
      }
      const NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
      function isDOMExceptionConstructor(ctor) {
        if (!(typeof ctor === "function" || typeof ctor === "object")) {
          return false;
        }
        try {
          new ctor();
          return true;
        } catch (_a13) {
          return false;
        }
      }
      function createDOMExceptionPolyfill() {
        const ctor = function DOMException2(message, name) {
          this.message = message || "";
          this.name = name || "Error";
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
        };
        ctor.prototype = Object.create(Error.prototype);
        Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
        return ctor;
      }
      const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
      function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
        const reader = AcquireReadableStreamDefaultReader(source);
        const writer = AcquireWritableStreamDefaultWriter(dest);
        source._disturbed = true;
        let shuttingDown = false;
        let currentWrite = promiseResolvedWith(void 0);
        return newPromise((resolve, reject) => {
          let abortAlgorithm;
          if (signal !== void 0) {
            abortAlgorithm = () => {
              const error = new DOMException$1("Aborted", "AbortError");
              const actions = [];
              if (!preventAbort) {
                actions.push(() => {
                  if (dest._state === "writable") {
                    return WritableStreamAbort(dest, error);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              if (!preventCancel) {
                actions.push(() => {
                  if (source._state === "readable") {
                    return ReadableStreamCancel(source, error);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error);
            };
            if (signal.aborted) {
              abortAlgorithm();
              return;
            }
            signal.addEventListener("abort", abortAlgorithm);
          }
          function pipeLoop() {
            return newPromise((resolveLoop, rejectLoop) => {
              function next(done) {
                if (done) {
                  resolveLoop();
                } else {
                  PerformPromiseThen(pipeStep(), next, rejectLoop);
                }
              }
              next(false);
            });
          }
          function pipeStep() {
            if (shuttingDown) {
              return promiseResolvedWith(true);
            }
            return PerformPromiseThen(writer._readyPromise, () => {
              return newPromise((resolveRead, rejectRead) => {
                ReadableStreamDefaultReaderRead(reader, {
                  _chunkSteps: (chunk) => {
                    currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop);
                    resolveRead(false);
                  },
                  _closeSteps: () => resolveRead(true),
                  _errorSteps: rejectRead
                });
              });
            });
          }
          isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
            if (!preventAbort) {
              shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
            } else {
              shutdown(true, storedError);
            }
          });
          isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
            if (!preventCancel) {
              shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
            } else {
              shutdown(true, storedError);
            }
          });
          isOrBecomesClosed(source, reader._closedPromise, () => {
            if (!preventClose) {
              shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
            } else {
              shutdown();
            }
          });
          if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
            const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
            if (!preventCancel) {
              shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
            } else {
              shutdown(true, destClosed);
            }
          }
          setPromiseIsHandledToTrue(pipeLoop());
          function waitForWritesToFinish() {
            const oldCurrentWrite = currentWrite;
            return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
          }
          function isOrBecomesErrored(stream, promise, action) {
            if (stream._state === "errored") {
              action(stream._storedError);
            } else {
              uponRejection(promise, action);
            }
          }
          function isOrBecomesClosed(stream, promise, action) {
            if (stream._state === "closed") {
              action();
            } else {
              uponFulfillment(promise, action);
            }
          }
          function shutdownWithAction(action, originalIsError, originalError) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), doTheRest);
            } else {
              doTheRest();
            }
            function doTheRest() {
              uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
            }
          }
          function shutdown(isError, error) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));
            } else {
              finalize(isError, error);
            }
          }
          function finalize(isError, error) {
            WritableStreamDefaultWriterRelease(writer);
            ReadableStreamReaderGenericRelease(reader);
            if (signal !== void 0) {
              signal.removeEventListener("abort", abortAlgorithm);
            }
            if (isError) {
              reject(error);
            } else {
              resolve(void 0);
            }
          }
        });
      }
      class ReadableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get desiredSize() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("desiredSize");
          }
          return ReadableStreamDefaultControllerGetDesiredSize(this);
        }
        close() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("close");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError("The stream is not in a state that permits close");
          }
          ReadableStreamDefaultControllerClose(this);
        }
        enqueue(chunk = void 0) {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("enqueue");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError("The stream is not in a state that permits enqueue");
          }
          return ReadableStreamDefaultControllerEnqueue(this, chunk);
        }
        error(e = void 0) {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("error");
          }
          ReadableStreamDefaultControllerError(this, e);
        }
        [CancelSteps](reason) {
          ResetQueue(this);
          const result2 = this._cancelAlgorithm(reason);
          ReadableStreamDefaultControllerClearAlgorithms(this);
          return result2;
        }
        [PullSteps](readRequest) {
          const stream = this._controlledReadableStream;
          if (this._queue.length > 0) {
            const chunk = DequeueValue(this);
            if (this._closeRequested && this._queue.length === 0) {
              ReadableStreamDefaultControllerClearAlgorithms(this);
              ReadableStreamClose(stream);
            } else {
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
            readRequest._chunkSteps(chunk);
          } else {
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableStreamDefaultControllerCallPullIfNeeded(this);
          }
        }
      }
      Object.defineProperties(ReadableStreamDefaultController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamDefaultController",
          configurable: true
        });
      }
      function IsReadableStreamDefaultController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableStream")) {
          return false;
        }
        return x instanceof ReadableStreamDefaultController;
      }
      function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }
        }, (e) => {
          ReadableStreamDefaultControllerError(controller, e);
        });
      }
      function ReadableStreamDefaultControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableStream;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableStreamDefaultControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function ReadableStreamDefaultControllerClose(controller) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        const stream = controller._controlledReadableStream;
        controller._closeRequested = true;
        if (controller._queue.length === 0) {
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
      }
      function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        const stream = controller._controlledReadableStream;
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          ReadableStreamFulfillReadRequest(stream, chunk, false);
        } else {
          let chunkSize;
          try {
            chunkSize = controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            ReadableStreamDefaultControllerError(controller, chunkSizeE);
            throw chunkSizeE;
          }
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            ReadableStreamDefaultControllerError(controller, enqueueE);
            throw enqueueE;
          }
        }
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
      }
      function ReadableStreamDefaultControllerError(controller, e) {
        const stream = controller._controlledReadableStream;
        if (stream._state !== "readable") {
          return;
        }
        ResetQueue(controller);
        ReadableStreamDefaultControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e);
      }
      function ReadableStreamDefaultControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableStreamDefaultControllerHasBackpressure(controller) {
        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
          return false;
        }
        return true;
      }
      function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
        const state = controller._controlledReadableStream._state;
        if (!controller._closeRequested && state === "readable") {
          return true;
        }
        return false;
      }
      function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledReadableStream = stream;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._started = false;
        controller._closeRequested = false;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
          controller._started = true;
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }, (r) => {
          ReadableStreamDefaultControllerError(controller, r);
        });
      }
      function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        let startAlgorithm = () => void 0;
        let pullAlgorithm = () => promiseResolvedWith(void 0);
        let cancelAlgorithm = () => promiseResolvedWith(void 0);
        if (underlyingSource.start !== void 0) {
          startAlgorithm = () => underlyingSource.start(controller);
        }
        if (underlyingSource.pull !== void 0) {
          pullAlgorithm = () => underlyingSource.pull(controller);
        }
        if (underlyingSource.cancel !== void 0) {
          cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
        }
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function defaultControllerBrandCheckException$1(name) {
        return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
      }
      function ReadableStreamTee(stream, cloneForBranch2) {
        if (IsReadableByteStreamController(stream._readableStreamController)) {
          return ReadableByteStreamTee(stream);
        }
        return ReadableStreamDefaultTee(stream);
      }
      function ReadableStreamDefaultTee(stream, cloneForBranch2) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise((resolve) => {
          resolveCancelPromise = resolve;
        });
        function pullAlgorithm() {
          if (reading) {
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const readRequest = {
            _chunkSteps: (chunk) => {
              queueMicrotask(() => {
                reading = false;
                const chunk1 = chunk;
                const chunk2 = chunk;
                if (!canceled1) {
                  ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                }
              });
            },
            _closeSteps: () => {
              reading = false;
              if (!canceled1) {
                ReadableStreamDefaultControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableStreamDefaultControllerClose(branch2._readableStreamController);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
        }
        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
        uponRejection(reader._closedPromise, (r) => {
          ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
          ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
          if (!canceled1 || !canceled2) {
            resolveCancelPromise(void 0);
          }
        });
        return [branch1, branch2];
      }
      function ReadableByteStreamTee(stream) {
        let reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise((resolve) => {
          resolveCancelPromise = resolve;
        });
        function forwardReaderError(thisReader) {
          uponRejection(thisReader._closedPromise, (r) => {
            if (thisReader !== reader) {
              return;
            }
            ReadableByteStreamControllerError(branch1._readableStreamController, r);
            ReadableByteStreamControllerError(branch2._readableStreamController, r);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
          });
        }
        function pullWithDefaultReader() {
          if (IsReadableStreamBYOBReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamDefaultReader(stream);
            forwardReaderError(reader);
          }
          const readRequest = {
            _chunkSteps: (chunk) => {
              queueMicrotask(() => {
                reading = false;
                const chunk1 = chunk;
                let chunk2 = chunk;
                if (!canceled1 && !canceled2) {
                  try {
                    chunk2 = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                }
                if (!canceled1) {
                  ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                }
              });
            },
            _closeSteps: () => {
              reading = false;
              if (!canceled1) {
                ReadableByteStreamControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableByteStreamControllerClose(branch2._readableStreamController);
              }
              if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
              }
              if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
        }
        function pullWithBYOBReader(view, forBranch2) {
          if (IsReadableStreamDefaultReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamBYOBReader(stream);
            forwardReaderError(reader);
          }
          const byobBranch = forBranch2 ? branch2 : branch1;
          const otherBranch = forBranch2 ? branch1 : branch2;
          const readIntoRequest = {
            _chunkSteps: (chunk) => {
              queueMicrotask(() => {
                reading = false;
                const byobCanceled = forBranch2 ? canceled2 : canceled1;
                const otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!otherCanceled) {
                  let clonedChunk;
                  try {
                    clonedChunk = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                } else if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
              });
            },
            _closeSteps: (chunk) => {
              reading = false;
              const byobCanceled = forBranch2 ? canceled2 : canceled1;
              const otherCanceled = forBranch2 ? canceled1 : canceled2;
              if (!byobCanceled) {
                ReadableByteStreamControllerClose(byobBranch._readableStreamController);
              }
              if (!otherCanceled) {
                ReadableByteStreamControllerClose(otherBranch._readableStreamController);
              }
              if (chunk !== void 0) {
                if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                }
              }
              if (!byobCanceled || !otherCanceled) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
        }
        function pull1Algorithm() {
          if (reading) {
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, false);
          }
          return promiseResolvedWith(void 0);
        }
        function pull2Algorithm() {
          if (reading) {
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, true);
          }
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
          return;
        }
        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
        forwardReaderError(reader);
        return [branch1, branch2];
      }
      function convertUnderlyingDefaultOrByteSource(source, context) {
        assertDictionary(source, context);
        const original = source;
        const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
        const cancel = original === null || original === void 0 ? void 0 : original.cancel;
        const pull = original === null || original === void 0 ? void 0 : original.pull;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type = original === null || original === void 0 ? void 0 : original.type;
        return {
          autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
          cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
          pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
          start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
          type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)
        };
      }
      function convertUnderlyingSourceCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSourcePullCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
      }
      function convertUnderlyingSourceStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertReadableStreamType(type, context) {
        type = `${type}`;
        if (type !== "bytes") {
          throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
        }
        return type;
      }
      function convertReaderOptions(options, context) {
        assertDictionary(options, context);
        const mode = options === null || options === void 0 ? void 0 : options.mode;
        return {
          mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
        };
      }
      function convertReadableStreamReaderMode(mode, context) {
        mode = `${mode}`;
        if (mode !== "byob") {
          throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
        }
        return mode;
      }
      function convertIteratorOptions(options, context) {
        assertDictionary(options, context);
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        return { preventCancel: Boolean(preventCancel) };
      }
      function convertPipeOptions(options, context) {
        assertDictionary(options, context);
        const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
        const signal = options === null || options === void 0 ? void 0 : options.signal;
        if (signal !== void 0) {
          assertAbortSignal(signal, `${context} has member 'signal' that`);
        }
        return {
          preventAbort: Boolean(preventAbort),
          preventCancel: Boolean(preventCancel),
          preventClose: Boolean(preventClose),
          signal
        };
      }
      function assertAbortSignal(signal, context) {
        if (!isAbortSignal2(signal)) {
          throw new TypeError(`${context} is not an AbortSignal.`);
        }
      }
      function convertReadableWritablePair(pair, context) {
        assertDictionary(pair, context);
        const readable = pair === null || pair === void 0 ? void 0 : pair.readable;
        assertRequiredField(readable, "readable", "ReadableWritablePair");
        assertReadableStream(readable, `${context} has member 'readable' that`);
        const writable = pair === null || pair === void 0 ? void 0 : pair.writable;
        assertRequiredField(writable, "writable", "ReadableWritablePair");
        assertWritableStream(writable, `${context} has member 'writable' that`);
        return { readable, writable };
      }
      class ReadableStream2 {
        constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
          if (rawUnderlyingSource === void 0) {
            rawUnderlyingSource = null;
          } else {
            assertObject(rawUnderlyingSource, "First parameter");
          }
          const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
          const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
          InitializeReadableStream(this);
          if (underlyingSource.type === "bytes") {
            if (strategy.size !== void 0) {
              throw new RangeError("The strategy for a byte stream cannot have a size function");
            }
            const highWaterMark = ExtractHighWaterMark(strategy, 0);
            SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
          } else {
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
          }
        }
        get locked() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("locked");
          }
          return IsReadableStreamLocked(this);
        }
        cancel(reason = void 0) {
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("cancel"));
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
          }
          return ReadableStreamCancel(this, reason);
        }
        getReader(rawOptions = void 0) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("getReader");
          }
          const options = convertReaderOptions(rawOptions, "First parameter");
          if (options.mode === void 0) {
            return AcquireReadableStreamDefaultReader(this);
          }
          return AcquireReadableStreamBYOBReader(this);
        }
        pipeThrough(rawTransform, rawOptions = {}) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("pipeThrough");
          }
          assertRequiredArgument(rawTransform, 1, "pipeThrough");
          const transform = convertReadableWritablePair(rawTransform, "First parameter");
          const options = convertPipeOptions(rawOptions, "Second parameter");
          if (IsReadableStreamLocked(this)) {
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
          }
          if (IsWritableStreamLocked(transform.writable)) {
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
          }
          const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
          setPromiseIsHandledToTrue(promise);
          return transform.readable;
        }
        pipeTo(destination, rawOptions = {}) {
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
          }
          if (destination === void 0) {
            return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
          }
          if (!IsWritableStream(destination)) {
            return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
          }
          let options;
          try {
            options = convertPipeOptions(rawOptions, "Second parameter");
          } catch (e) {
            return promiseRejectedWith(e);
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
          }
          if (IsWritableStreamLocked(destination)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
          }
          return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
        }
        tee() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("tee");
          }
          const branches = ReadableStreamTee(this);
          return CreateArrayFromList(branches);
        }
        values(rawOptions = void 0) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("values");
          }
          const options = convertIteratorOptions(rawOptions, "First parameter");
          return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
        }
      }
      Object.defineProperties(ReadableStream2.prototype, {
        cancel: { enumerable: true },
        getReader: { enumerable: true },
        pipeThrough: { enumerable: true },
        pipeTo: { enumerable: true },
        tee: { enumerable: true },
        values: { enumerable: true },
        locked: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStream",
          configurable: true
        });
      }
      if (typeof SymbolPolyfill.asyncIterator === "symbol") {
        Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
          value: ReadableStream2.prototype.values,
          writable: true,
          configurable: true
        });
      }
      function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
        const stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableByteStreamController.prototype);
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
        return stream;
      }
      function InitializeReadableStream(stream) {
        stream._state = "readable";
        stream._reader = void 0;
        stream._storedError = void 0;
        stream._disturbed = false;
      }
      function IsReadableStream(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_readableStreamController")) {
          return false;
        }
        return x instanceof ReadableStream2;
      }
      function IsReadableStreamLocked(stream) {
        if (stream._reader === void 0) {
          return false;
        }
        return true;
      }
      function ReadableStreamCancel(stream, reason) {
        stream._disturbed = true;
        if (stream._state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (stream._state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        ReadableStreamClose(stream);
        const reader = stream._reader;
        if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
          reader._readIntoRequests.forEach((readIntoRequest) => {
            readIntoRequest._closeSteps(void 0);
          });
          reader._readIntoRequests = new SimpleQueue();
        }
        const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
        return transformPromiseWith(sourceCancelPromise, noop);
      }
      function ReadableStreamClose(stream) {
        stream._state = "closed";
        const reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseResolve(reader);
        if (IsReadableStreamDefaultReader(reader)) {
          reader._readRequests.forEach((readRequest) => {
            readRequest._closeSteps();
          });
          reader._readRequests = new SimpleQueue();
        }
      }
      function ReadableStreamError(stream, e) {
        stream._state = "errored";
        stream._storedError = e;
        const reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseReject(reader, e);
        if (IsReadableStreamDefaultReader(reader)) {
          reader._readRequests.forEach((readRequest) => {
            readRequest._errorSteps(e);
          });
          reader._readRequests = new SimpleQueue();
        } else {
          reader._readIntoRequests.forEach((readIntoRequest) => {
            readIntoRequest._errorSteps(e);
          });
          reader._readIntoRequests = new SimpleQueue();
        }
      }
      function streamBrandCheckException$1(name) {
        return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
      }
      function convertQueuingStrategyInit(init, context) {
        assertDictionary(init, context);
        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
        return {
          highWaterMark: convertUnrestrictedDouble(highWaterMark)
        };
      }
      const byteLengthSizeFunction = (chunk) => {
        return chunk.byteLength;
      };
      Object.defineProperty(byteLengthSizeFunction, "name", {
        value: "size",
        configurable: true
      });
      class ByteLengthQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
          options = convertQueuingStrategyInit(options, "First parameter");
          this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        get highWaterMark() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("highWaterMark");
          }
          return this._byteLengthQueuingStrategyHighWaterMark;
        }
        get size() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("size");
          }
          return byteLengthSizeFunction;
        }
      }
      Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
          value: "ByteLengthQueuingStrategy",
          configurable: true
        });
      }
      function byteLengthBrandCheckException(name) {
        return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
      }
      function IsByteLengthQueuingStrategy(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_byteLengthQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x instanceof ByteLengthQueuingStrategy;
      }
      const countSizeFunction = () => {
        return 1;
      };
      Object.defineProperty(countSizeFunction, "name", {
        value: "size",
        configurable: true
      });
      class CountQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "CountQueuingStrategy");
          options = convertQueuingStrategyInit(options, "First parameter");
          this._countQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        get highWaterMark() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("highWaterMark");
          }
          return this._countQueuingStrategyHighWaterMark;
        }
        get size() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("size");
          }
          return countSizeFunction;
        }
      }
      Object.defineProperties(CountQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
          value: "CountQueuingStrategy",
          configurable: true
        });
      }
      function countBrandCheckException(name) {
        return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
      }
      function IsCountQueuingStrategy(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_countQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x instanceof CountQueuingStrategy;
      }
      function convertTransformer(original, context) {
        assertDictionary(original, context);
        const flush = original === null || original === void 0 ? void 0 : original.flush;
        const readableType = original === null || original === void 0 ? void 0 : original.readableType;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const transform = original === null || original === void 0 ? void 0 : original.transform;
        const writableType = original === null || original === void 0 ? void 0 : original.writableType;
        return {
          flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
          readableType,
          start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
          transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
          writableType
        };
      }
      function convertTransformerFlushCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
      }
      function convertTransformerStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertTransformerTransformCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
      }
      class TransformStream {
        constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
          if (rawTransformer === void 0) {
            rawTransformer = null;
          }
          const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
          const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
          const transformer = convertTransformer(rawTransformer, "First parameter");
          if (transformer.readableType !== void 0) {
            throw new RangeError("Invalid readableType specified");
          }
          if (transformer.writableType !== void 0) {
            throw new RangeError("Invalid writableType specified");
          }
          const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
          const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
          const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
          const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
          let startPromise_resolve;
          const startPromise = newPromise((resolve) => {
            startPromise_resolve = resolve;
          });
          InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
          if (transformer.start !== void 0) {
            startPromise_resolve(transformer.start(this._transformStreamController));
          } else {
            startPromise_resolve(void 0);
          }
        }
        get readable() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("readable");
          }
          return this._readable;
        }
        get writable() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("writable");
          }
          return this._writable;
        }
      }
      Object.defineProperties(TransformStream.prototype, {
        readable: { enumerable: true },
        writable: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
          value: "TransformStream",
          configurable: true
        });
      }
      function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
        function startAlgorithm() {
          return startPromise;
        }
        function writeAlgorithm(chunk) {
          return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
        }
        function abortAlgorithm(reason) {
          return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
        }
        function closeAlgorithm() {
          return TransformStreamDefaultSinkCloseAlgorithm(stream);
        }
        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
        function pullAlgorithm() {
          return TransformStreamDefaultSourcePullAlgorithm(stream);
        }
        function cancelAlgorithm(reason) {
          TransformStreamErrorWritableAndUnblockWrite(stream, reason);
          return promiseResolvedWith(void 0);
        }
        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
        stream._backpressure = void 0;
        stream._backpressureChangePromise = void 0;
        stream._backpressureChangePromise_resolve = void 0;
        TransformStreamSetBackpressure(stream, true);
        stream._transformStreamController = void 0;
      }
      function IsTransformStream(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_transformStreamController")) {
          return false;
        }
        return x instanceof TransformStream;
      }
      function TransformStreamError(stream, e) {
        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
        TransformStreamErrorWritableAndUnblockWrite(stream, e);
      }
      function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
        if (stream._backpressure) {
          TransformStreamSetBackpressure(stream, false);
        }
      }
      function TransformStreamSetBackpressure(stream, backpressure) {
        if (stream._backpressureChangePromise !== void 0) {
          stream._backpressureChangePromise_resolve();
        }
        stream._backpressureChangePromise = newPromise((resolve) => {
          stream._backpressureChangePromise_resolve = resolve;
        });
        stream._backpressure = backpressure;
      }
      class TransformStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get desiredSize() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("desiredSize");
          }
          const readableController = this._controlledTransformStream._readable._readableStreamController;
          return ReadableStreamDefaultControllerGetDesiredSize(readableController);
        }
        enqueue(chunk = void 0) {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("enqueue");
          }
          TransformStreamDefaultControllerEnqueue(this, chunk);
        }
        error(reason = void 0) {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("error");
          }
          TransformStreamDefaultControllerError(this, reason);
        }
        terminate() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("terminate");
          }
          TransformStreamDefaultControllerTerminate(this);
        }
      }
      Object.defineProperties(TransformStreamDefaultController.prototype, {
        enqueue: { enumerable: true },
        error: { enumerable: true },
        terminate: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
          value: "TransformStreamDefaultController",
          configurable: true
        });
      }
      function IsTransformStreamDefaultController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledTransformStream")) {
          return false;
        }
        return x instanceof TransformStreamDefaultController;
      }
      function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
        controller._controlledTransformStream = stream;
        stream._transformStreamController = controller;
        controller._transformAlgorithm = transformAlgorithm;
        controller._flushAlgorithm = flushAlgorithm;
      }
      function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
        const controller = Object.create(TransformStreamDefaultController.prototype);
        let transformAlgorithm = (chunk) => {
          try {
            TransformStreamDefaultControllerEnqueue(controller, chunk);
            return promiseResolvedWith(void 0);
          } catch (transformResultE) {
            return promiseRejectedWith(transformResultE);
          }
        };
        let flushAlgorithm = () => promiseResolvedWith(void 0);
        if (transformer.transform !== void 0) {
          transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
        }
        if (transformer.flush !== void 0) {
          flushAlgorithm = () => transformer.flush(controller);
        }
        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
      }
      function TransformStreamDefaultControllerClearAlgorithms(controller) {
        controller._transformAlgorithm = void 0;
        controller._flushAlgorithm = void 0;
      }
      function TransformStreamDefaultControllerEnqueue(controller, chunk) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
          throw new TypeError("Readable side is not in a state that permits enqueue");
        }
        try {
          ReadableStreamDefaultControllerEnqueue(readableController, chunk);
        } catch (e) {
          TransformStreamErrorWritableAndUnblockWrite(stream, e);
          throw stream._readable._storedError;
        }
        const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
        if (backpressure !== stream._backpressure) {
          TransformStreamSetBackpressure(stream, true);
        }
      }
      function TransformStreamDefaultControllerError(controller, e) {
        TransformStreamError(controller._controlledTransformStream, e);
      }
      function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
        const transformPromise = controller._transformAlgorithm(chunk);
        return transformPromiseWith(transformPromise, void 0, (r) => {
          TransformStreamError(controller._controlledTransformStream, r);
          throw r;
        });
      }
      function TransformStreamDefaultControllerTerminate(controller) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        ReadableStreamDefaultControllerClose(readableController);
        const error = new TypeError("TransformStream terminated");
        TransformStreamErrorWritableAndUnblockWrite(stream, error);
      }
      function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
        const controller = stream._transformStreamController;
        if (stream._backpressure) {
          const backpressureChangePromise = stream._backpressureChangePromise;
          return transformPromiseWith(backpressureChangePromise, () => {
            const writable = stream._writable;
            const state = writable._state;
            if (state === "erroring") {
              throw writable._storedError;
            }
            return TransformStreamDefaultControllerPerformTransform(controller, chunk);
          });
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
      }
      function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
        TransformStreamError(stream, reason);
        return promiseResolvedWith(void 0);
      }
      function TransformStreamDefaultSinkCloseAlgorithm(stream) {
        const readable = stream._readable;
        const controller = stream._transformStreamController;
        const flushPromise = controller._flushAlgorithm();
        TransformStreamDefaultControllerClearAlgorithms(controller);
        return transformPromiseWith(flushPromise, () => {
          if (readable._state === "errored") {
            throw readable._storedError;
          }
          ReadableStreamDefaultControllerClose(readable._readableStreamController);
        }, (r) => {
          TransformStreamError(stream, r);
          throw readable._storedError;
        });
      }
      function TransformStreamDefaultSourcePullAlgorithm(stream) {
        TransformStreamSetBackpressure(stream, false);
        return stream._backpressureChangePromise;
      }
      function defaultControllerBrandCheckException(name) {
        return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
      }
      function streamBrandCheckException(name) {
        return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
      }
      exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
      exports2.CountQueuingStrategy = CountQueuingStrategy;
      exports2.ReadableByteStreamController = ReadableByteStreamController;
      exports2.ReadableStream = ReadableStream2;
      exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
      exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
      exports2.ReadableStreamDefaultController = ReadableStreamDefaultController;
      exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
      exports2.TransformStream = TransformStream;
      exports2.TransformStreamDefaultController = TransformStreamDefaultController;
      exports2.WritableStream = WritableStream2;
      exports2.WritableStreamDefaultController = WritableStreamDefaultController;
      exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/jsrsasign/lib/jsrsasign.js
var require_jsrsasign = __commonJS({
  "node_modules/jsrsasign/lib/jsrsasign.js"(exports) {
    var navigator = {};
    navigator.userAgent = false;
    var window2 = {};
    var CryptoJS = CryptoJS || function(e, g) {
      var a = {};
      var b = a.lib = {};
      var j = b.Base = function() {
        function n() {
        }
        return { extend: function(p) {
          n.prototype = this;
          var o = new n();
          if (p) {
            o.mixIn(p);
          }
          if (!o.hasOwnProperty("init")) {
            o.init = function() {
              o.$super.init.apply(this, arguments);
            };
          }
          o.init.prototype = o;
          o.$super = this;
          return o;
        }, create: function() {
          var o = this.extend();
          o.init.apply(o, arguments);
          return o;
        }, init: function() {
        }, mixIn: function(p) {
          for (var o in p) {
            if (p.hasOwnProperty(o)) {
              this[o] = p[o];
            }
          }
          if (p.hasOwnProperty("toString")) {
            this.toString = p.toString;
          }
        }, clone: function() {
          return this.init.prototype.extend(this);
        } };
      }();
      var l = b.WordArray = j.extend({ init: function(o, n) {
        o = this.words = o || [];
        if (n != g) {
          this.sigBytes = n;
        } else {
          this.sigBytes = o.length * 4;
        }
      }, toString: function(n) {
        return (n || h).stringify(this);
      }, concat: function(t2) {
        var q = this.words;
        var p = t2.words;
        var n = this.sigBytes;
        var s = t2.sigBytes;
        this.clamp();
        if (n % 4) {
          for (var r = 0; r < s; r++) {
            var o = p[r >>> 2] >>> 24 - r % 4 * 8 & 255;
            q[n + r >>> 2] |= o << 24 - (n + r) % 4 * 8;
          }
        } else {
          for (var r = 0; r < s; r += 4) {
            q[n + r >>> 2] = p[r >>> 2];
          }
        }
        this.sigBytes += s;
        return this;
      }, clamp: function() {
        var o = this.words;
        var n = this.sigBytes;
        o[n >>> 2] &= 4294967295 << 32 - n % 4 * 8;
        o.length = e.ceil(n / 4);
      }, clone: function() {
        var n = j.clone.call(this);
        n.words = this.words.slice(0);
        return n;
      }, random: function(p) {
        var o = [];
        for (var n = 0; n < p; n += 4) {
          o.push(e.random() * 4294967296 | 0);
        }
        return new l.init(o, p);
      } });
      var m = a.enc = {};
      var h = m.Hex = { stringify: function(p) {
        var r = p.words;
        var o = p.sigBytes;
        var q = [];
        for (var n = 0; n < o; n++) {
          var s = r[n >>> 2] >>> 24 - n % 4 * 8 & 255;
          q.push((s >>> 4).toString(16));
          q.push((s & 15).toString(16));
        }
        return q.join("");
      }, parse: function(p) {
        var n = p.length;
        var q = [];
        for (var o = 0; o < n; o += 2) {
          q[o >>> 3] |= parseInt(p.substr(o, 2), 16) << 24 - o % 8 * 4;
        }
        return new l.init(q, n / 2);
      } };
      var d = m.Latin1 = { stringify: function(q) {
        var r = q.words;
        var p = q.sigBytes;
        var n = [];
        for (var o = 0; o < p; o++) {
          var s = r[o >>> 2] >>> 24 - o % 4 * 8 & 255;
          n.push(String.fromCharCode(s));
        }
        return n.join("");
      }, parse: function(p) {
        var n = p.length;
        var q = [];
        for (var o = 0; o < n; o++) {
          q[o >>> 2] |= (p.charCodeAt(o) & 255) << 24 - o % 4 * 8;
        }
        return new l.init(q, n);
      } };
      var c = m.Utf8 = { stringify: function(n) {
        try {
          return decodeURIComponent(escape(d.stringify(n)));
        } catch (o) {
          throw new Error("Malformed UTF-8 data");
        }
      }, parse: function(n) {
        return d.parse(unescape(encodeURIComponent(n)));
      } };
      var i = b.BufferedBlockAlgorithm = j.extend({ reset: function() {
        this._data = new l.init();
        this._nDataBytes = 0;
      }, _append: function(n) {
        if (typeof n == "string") {
          n = c.parse(n);
        }
        this._data.concat(n);
        this._nDataBytes += n.sigBytes;
      }, _process: function(w) {
        var q = this._data;
        var x = q.words;
        var n = q.sigBytes;
        var t2 = this.blockSize;
        var v = t2 * 4;
        var u = n / v;
        if (w) {
          u = e.ceil(u);
        } else {
          u = e.max((u | 0) - this._minBufferSize, 0);
        }
        var s = u * t2;
        var r = e.min(s * 4, n);
        if (s) {
          for (var p = 0; p < s; p += t2) {
            this._doProcessBlock(x, p);
          }
          var o = x.splice(0, s);
          q.sigBytes -= r;
        }
        return new l.init(o, r);
      }, clone: function() {
        var n = j.clone.call(this);
        n._data = this._data.clone();
        return n;
      }, _minBufferSize: 0 });
      var f = b.Hasher = i.extend({ cfg: j.extend(), init: function(n) {
        this.cfg = this.cfg.extend(n);
        this.reset();
      }, reset: function() {
        i.reset.call(this);
        this._doReset();
      }, update: function(n) {
        this._append(n);
        this._process();
        return this;
      }, finalize: function(n) {
        if (n) {
          this._append(n);
        }
        var o = this._doFinalize();
        return o;
      }, blockSize: 512 / 32, _createHelper: function(n) {
        return function(p, o) {
          return new n.init(o).finalize(p);
        };
      }, _createHmacHelper: function(n) {
        return function(p, o) {
          return new k.HMAC.init(n, o).finalize(p);
        };
      } });
      var k = a.algo = {};
      return a;
    }(Math);
    (function(g) {
      var a = CryptoJS, f = a.lib, e = f.Base, h = f.WordArray, a = a.x64 = {};
      a.Word = e.extend({ init: function(b, c) {
        this.high = b;
        this.low = c;
      } });
      a.WordArray = e.extend({ init: function(b, c) {
        b = this.words = b || [];
        this.sigBytes = c != g ? c : 8 * b.length;
      }, toX32: function() {
        for (var b = this.words, c = b.length, a2 = [], d = 0; d < c; d++) {
          var e2 = b[d];
          a2.push(e2.high);
          a2.push(e2.low);
        }
        return h.create(a2, this.sigBytes);
      }, clone: function() {
        for (var b = e.clone.call(this), c = b.words = this.words.slice(0), a2 = c.length, d = 0; d < a2; d++)
          c[d] = c[d].clone();
        return b;
      } });
    })();
    CryptoJS.lib.Cipher || function(u) {
      var g = CryptoJS, f = g.lib, k = f.Base, l = f.WordArray, q = f.BufferedBlockAlgorithm, r = g.enc.Base64, v = g.algo.EvpKDF, n = f.Cipher = q.extend({ cfg: k.extend(), createEncryptor: function(a, b) {
        return this.create(this._ENC_XFORM_MODE, a, b);
      }, createDecryptor: function(a, b) {
        return this.create(this._DEC_XFORM_MODE, a, b);
      }, init: function(a, b, c) {
        this.cfg = this.cfg.extend(c);
        this._xformMode = a;
        this._key = b;
        this.reset();
      }, reset: function() {
        q.reset.call(this);
        this._doReset();
      }, process: function(a) {
        this._append(a);
        return this._process();
      }, finalize: function(a) {
        a && this._append(a);
        return this._doFinalize();
      }, keySize: 4, ivSize: 4, _ENC_XFORM_MODE: 1, _DEC_XFORM_MODE: 2, _createHelper: function(a) {
        return { encrypt: function(b, c, d) {
          return (typeof c == "string" ? s : j).encrypt(a, b, c, d);
        }, decrypt: function(b, c, d) {
          return (typeof c == "string" ? s : j).decrypt(a, b, c, d);
        } };
      } });
      f.StreamCipher = n.extend({ _doFinalize: function() {
        return this._process(true);
      }, blockSize: 1 });
      var m = g.mode = {}, t2 = function(a, b, c) {
        var d = this._iv;
        d ? this._iv = u : d = this._prevBlock;
        for (var e = 0; e < c; e++)
          a[b + e] ^= d[e];
      }, h = (f.BlockCipherMode = k.extend({ createEncryptor: function(a, b) {
        return this.Encryptor.create(a, b);
      }, createDecryptor: function(a, b) {
        return this.Decryptor.create(a, b);
      }, init: function(a, b) {
        this._cipher = a;
        this._iv = b;
      } })).extend();
      h.Encryptor = h.extend({ processBlock: function(a, b) {
        var c = this._cipher, d = c.blockSize;
        t2.call(this, a, b, d);
        c.encryptBlock(a, b);
        this._prevBlock = a.slice(b, b + d);
      } });
      h.Decryptor = h.extend({ processBlock: function(a, b) {
        var c = this._cipher, d = c.blockSize, e = a.slice(b, b + d);
        c.decryptBlock(a, b);
        t2.call(this, a, b, d);
        this._prevBlock = e;
      } });
      m = m.CBC = h;
      h = (g.pad = {}).Pkcs7 = { pad: function(a, b) {
        for (var c = 4 * b, c = c - a.sigBytes % c, d = c << 24 | c << 16 | c << 8 | c, e = [], f2 = 0; f2 < c; f2 += 4)
          e.push(d);
        c = l.create(e, c);
        a.concat(c);
      }, unpad: function(a) {
        a.sigBytes -= a.words[a.sigBytes - 1 >>> 2] & 255;
      } };
      f.BlockCipher = n.extend({ cfg: n.cfg.extend({ mode: m, padding: h }), reset: function() {
        n.reset.call(this);
        var a = this.cfg, b = a.iv, a = a.mode;
        if (this._xformMode == this._ENC_XFORM_MODE)
          var c = a.createEncryptor;
        else
          c = a.createDecryptor, this._minBufferSize = 1;
        this._mode = c.call(a, this, b && b.words);
      }, _doProcessBlock: function(a, b) {
        this._mode.processBlock(a, b);
      }, _doFinalize: function() {
        var a = this.cfg.padding;
        if (this._xformMode == this._ENC_XFORM_MODE) {
          a.pad(this._data, this.blockSize);
          var b = this._process(true);
        } else
          b = this._process(true), a.unpad(b);
        return b;
      }, blockSize: 4 });
      var p = f.CipherParams = k.extend({ init: function(a) {
        this.mixIn(a);
      }, toString: function(a) {
        return (a || this.formatter).stringify(this);
      } }), m = (g.format = {}).OpenSSL = { stringify: function(a) {
        var b = a.ciphertext;
        a = a.salt;
        return (a ? l.create([1398893684, 1701076831]).concat(a).concat(b) : b).toString(r);
      }, parse: function(a) {
        a = r.parse(a);
        var b = a.words;
        if (b[0] == 1398893684 && b[1] == 1701076831) {
          var c = l.create(b.slice(2, 4));
          b.splice(0, 4);
          a.sigBytes -= 16;
        }
        return p.create({ ciphertext: a, salt: c });
      } }, j = f.SerializableCipher = k.extend({ cfg: k.extend({ format: m }), encrypt: function(a, b, c, d) {
        d = this.cfg.extend(d);
        var e = a.createEncryptor(c, d);
        b = e.finalize(b);
        e = e.cfg;
        return p.create({
          ciphertext: b,
          key: c,
          iv: e.iv,
          algorithm: a,
          mode: e.mode,
          padding: e.padding,
          blockSize: a.blockSize,
          formatter: d.format
        });
      }, decrypt: function(a, b, c, d) {
        d = this.cfg.extend(d);
        b = this._parse(b, d.format);
        return a.createDecryptor(c, d).finalize(b.ciphertext);
      }, _parse: function(a, b) {
        return typeof a == "string" ? b.parse(a, this) : a;
      } }), g = (g.kdf = {}).OpenSSL = { execute: function(a, b, c, d) {
        d || (d = l.random(8));
        a = v.create({ keySize: b + c }).compute(a, d);
        c = l.create(a.words.slice(b), 4 * c);
        a.sigBytes = 4 * b;
        return p.create({ key: a, iv: c, salt: d });
      } }, s = f.PasswordBasedCipher = j.extend({ cfg: j.cfg.extend({ kdf: g }), encrypt: function(a, b, c, d) {
        d = this.cfg.extend(d);
        c = d.kdf.execute(c, a.keySize, a.ivSize);
        d.iv = c.iv;
        a = j.encrypt.call(this, a, b, c.key, d);
        a.mixIn(c);
        return a;
      }, decrypt: function(a, b, c, d) {
        d = this.cfg.extend(d);
        b = this._parse(b, d.format);
        c = d.kdf.execute(c, a.keySize, a.ivSize, b.salt);
        d.iv = c.iv;
        return j.decrypt.call(this, a, b, c.key, d);
      } });
    }();
    (function() {
      for (var q = CryptoJS, x = q.lib.BlockCipher, r = q.algo, j = [], y = [], z2 = [], A = [], B = [], C = [], s = [], u = [], v = [], w = [], g = [], k = 0; 256 > k; k++)
        g[k] = 128 > k ? k << 1 : k << 1 ^ 283;
      for (var n = 0, l = 0, k = 0; 256 > k; k++) {
        var f = l ^ l << 1 ^ l << 2 ^ l << 3 ^ l << 4, f = f >>> 8 ^ f & 255 ^ 99;
        j[n] = f;
        y[f] = n;
        var t2 = g[n], D = g[t2], E = g[D], b = 257 * g[f] ^ 16843008 * f;
        z2[n] = b << 24 | b >>> 8;
        A[n] = b << 16 | b >>> 16;
        B[n] = b << 8 | b >>> 24;
        C[n] = b;
        b = 16843009 * E ^ 65537 * D ^ 257 * t2 ^ 16843008 * n;
        s[f] = b << 24 | b >>> 8;
        u[f] = b << 16 | b >>> 16;
        v[f] = b << 8 | b >>> 24;
        w[f] = b;
        n ? (n = t2 ^ g[g[g[E ^ t2]]], l ^= g[g[l]]) : n = l = 1;
      }
      var F = [
        0,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        27,
        54
      ], r = r.AES = x.extend({ _doReset: function() {
        for (var c = this._key, e = c.words, a = c.sigBytes / 4, c = 4 * ((this._nRounds = a + 6) + 1), b2 = this._keySchedule = [], h = 0; h < c; h++)
          if (h < a)
            b2[h] = e[h];
          else {
            var d = b2[h - 1];
            h % a ? 6 < a && h % a == 4 && (d = j[d >>> 24] << 24 | j[d >>> 16 & 255] << 16 | j[d >>> 8 & 255] << 8 | j[d & 255]) : (d = d << 8 | d >>> 24, d = j[d >>> 24] << 24 | j[d >>> 16 & 255] << 16 | j[d >>> 8 & 255] << 8 | j[d & 255], d ^= F[h / a | 0] << 24);
            b2[h] = b2[h - a] ^ d;
          }
        e = this._invKeySchedule = [];
        for (a = 0; a < c; a++)
          h = c - a, d = a % 4 ? b2[h] : b2[h - 4], e[a] = 4 > a || 4 >= h ? d : s[j[d >>> 24]] ^ u[j[d >>> 16 & 255]] ^ v[j[d >>> 8 & 255]] ^ w[j[d & 255]];
      }, encryptBlock: function(c, e) {
        this._doCryptBlock(c, e, this._keySchedule, z2, A, B, C, j);
      }, decryptBlock: function(c, e) {
        var a = c[e + 1];
        c[e + 1] = c[e + 3];
        c[e + 3] = a;
        this._doCryptBlock(c, e, this._invKeySchedule, s, u, v, w, y);
        a = c[e + 1];
        c[e + 1] = c[e + 3];
        c[e + 3] = a;
      }, _doCryptBlock: function(c, e, a, b2, h, d, j2, m) {
        for (var n2 = this._nRounds, f2 = c[e] ^ a[0], g2 = c[e + 1] ^ a[1], k2 = c[e + 2] ^ a[2], p = c[e + 3] ^ a[3], l2 = 4, t3 = 1; t3 < n2; t3++)
          var q2 = b2[f2 >>> 24] ^ h[g2 >>> 16 & 255] ^ d[k2 >>> 8 & 255] ^ j2[p & 255] ^ a[l2++], r2 = b2[g2 >>> 24] ^ h[k2 >>> 16 & 255] ^ d[p >>> 8 & 255] ^ j2[f2 & 255] ^ a[l2++], s2 = b2[k2 >>> 24] ^ h[p >>> 16 & 255] ^ d[f2 >>> 8 & 255] ^ j2[g2 & 255] ^ a[l2++], p = b2[p >>> 24] ^ h[f2 >>> 16 & 255] ^ d[g2 >>> 8 & 255] ^ j2[k2 & 255] ^ a[l2++], f2 = q2, g2 = r2, k2 = s2;
        q2 = (m[f2 >>> 24] << 24 | m[g2 >>> 16 & 255] << 16 | m[k2 >>> 8 & 255] << 8 | m[p & 255]) ^ a[l2++];
        r2 = (m[g2 >>> 24] << 24 | m[k2 >>> 16 & 255] << 16 | m[p >>> 8 & 255] << 8 | m[f2 & 255]) ^ a[l2++];
        s2 = (m[k2 >>> 24] << 24 | m[p >>> 16 & 255] << 16 | m[f2 >>> 8 & 255] << 8 | m[g2 & 255]) ^ a[l2++];
        p = (m[p >>> 24] << 24 | m[f2 >>> 16 & 255] << 16 | m[g2 >>> 8 & 255] << 8 | m[k2 & 255]) ^ a[l2++];
        c[e] = q2;
        c[e + 1] = r2;
        c[e + 2] = s2;
        c[e + 3] = p;
      }, keySize: 8 });
      q.AES = x._createHelper(r);
    })();
    (function() {
      function j(b, c) {
        var a = (this._lBlock >>> b ^ this._rBlock) & c;
        this._rBlock ^= a;
        this._lBlock ^= a << b;
      }
      function l(b, c) {
        var a = (this._rBlock >>> b ^ this._lBlock) & c;
        this._lBlock ^= a;
        this._rBlock ^= a << b;
      }
      var h = CryptoJS, e = h.lib, n = e.WordArray, e = e.BlockCipher, g = h.algo, q = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4], p = [
        14,
        17,
        11,
        24,
        1,
        5,
        3,
        28,
        15,
        6,
        21,
        10,
        23,
        19,
        12,
        4,
        26,
        8,
        16,
        7,
        27,
        20,
        13,
        2,
        41,
        52,
        31,
        37,
        47,
        55,
        30,
        40,
        51,
        45,
        33,
        48,
        44,
        49,
        39,
        56,
        34,
        53,
        46,
        42,
        50,
        36,
        29,
        32
      ], r = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28], s = [{
        "0": 8421888,
        268435456: 32768,
        536870912: 8421378,
        805306368: 2,
        1073741824: 512,
        1342177280: 8421890,
        1610612736: 8389122,
        1879048192: 8388608,
        2147483648: 514,
        2415919104: 8389120,
        2684354560: 33280,
        2952790016: 8421376,
        3221225472: 32770,
        3489660928: 8388610,
        3758096384: 0,
        4026531840: 33282,
        134217728: 0,
        402653184: 8421890,
        671088640: 33282,
        939524096: 32768,
        1207959552: 8421888,
        1476395008: 512,
        1744830464: 8421378,
        2013265920: 2,
        2281701376: 8389120,
        2550136832: 33280,
        2818572288: 8421376,
        3087007744: 8389122,
        3355443200: 8388610,
        3623878656: 32770,
        3892314112: 514,
        4160749568: 8388608,
        1: 32768,
        268435457: 2,
        536870913: 8421888,
        805306369: 8388608,
        1073741825: 8421378,
        1342177281: 33280,
        1610612737: 512,
        1879048193: 8389122,
        2147483649: 8421890,
        2415919105: 8421376,
        2684354561: 8388610,
        2952790017: 33282,
        3221225473: 514,
        3489660929: 8389120,
        3758096385: 32770,
        4026531841: 0,
        134217729: 8421890,
        402653185: 8421376,
        671088641: 8388608,
        939524097: 512,
        1207959553: 32768,
        1476395009: 8388610,
        1744830465: 2,
        2013265921: 33282,
        2281701377: 32770,
        2550136833: 8389122,
        2818572289: 514,
        3087007745: 8421888,
        3355443201: 8389120,
        3623878657: 0,
        3892314113: 33280,
        4160749569: 8421378
      }, {
        "0": 1074282512,
        16777216: 16384,
        33554432: 524288,
        50331648: 1074266128,
        67108864: 1073741840,
        83886080: 1074282496,
        100663296: 1073758208,
        117440512: 16,
        134217728: 540672,
        150994944: 1073758224,
        167772160: 1073741824,
        184549376: 540688,
        201326592: 524304,
        218103808: 0,
        234881024: 16400,
        251658240: 1074266112,
        8388608: 1073758208,
        25165824: 540688,
        41943040: 16,
        58720256: 1073758224,
        75497472: 1074282512,
        92274688: 1073741824,
        109051904: 524288,
        125829120: 1074266128,
        142606336: 524304,
        159383552: 0,
        176160768: 16384,
        192937984: 1074266112,
        209715200: 1073741840,
        226492416: 540672,
        243269632: 1074282496,
        260046848: 16400,
        268435456: 0,
        285212672: 1074266128,
        301989888: 1073758224,
        318767104: 1074282496,
        335544320: 1074266112,
        352321536: 16,
        369098752: 540688,
        385875968: 16384,
        402653184: 16400,
        419430400: 524288,
        436207616: 524304,
        452984832: 1073741840,
        469762048: 540672,
        486539264: 1073758208,
        503316480: 1073741824,
        520093696: 1074282512,
        276824064: 540688,
        293601280: 524288,
        310378496: 1074266112,
        327155712: 16384,
        343932928: 1073758208,
        360710144: 1074282512,
        377487360: 16,
        394264576: 1073741824,
        411041792: 1074282496,
        427819008: 1073741840,
        444596224: 1073758224,
        461373440: 524304,
        478150656: 0,
        494927872: 16400,
        511705088: 1074266128,
        528482304: 540672
      }, {
        "0": 260,
        1048576: 0,
        2097152: 67109120,
        3145728: 65796,
        4194304: 65540,
        5242880: 67108868,
        6291456: 67174660,
        7340032: 67174400,
        8388608: 67108864,
        9437184: 67174656,
        10485760: 65792,
        11534336: 67174404,
        12582912: 67109124,
        13631488: 65536,
        14680064: 4,
        15728640: 256,
        524288: 67174656,
        1572864: 67174404,
        2621440: 0,
        3670016: 67109120,
        4718592: 67108868,
        5767168: 65536,
        6815744: 65540,
        7864320: 260,
        8912896: 4,
        9961472: 256,
        11010048: 67174400,
        12058624: 65796,
        13107200: 65792,
        14155776: 67109124,
        15204352: 67174660,
        16252928: 67108864,
        16777216: 67174656,
        17825792: 65540,
        18874368: 65536,
        19922944: 67109120,
        20971520: 256,
        22020096: 67174660,
        23068672: 67108868,
        24117248: 0,
        25165824: 67109124,
        26214400: 67108864,
        27262976: 4,
        28311552: 65792,
        29360128: 67174400,
        30408704: 260,
        31457280: 65796,
        32505856: 67174404,
        17301504: 67108864,
        18350080: 260,
        19398656: 67174656,
        20447232: 0,
        21495808: 65540,
        22544384: 67109120,
        23592960: 256,
        24641536: 67174404,
        25690112: 65536,
        26738688: 67174660,
        27787264: 65796,
        28835840: 67108868,
        29884416: 67109124,
        30932992: 67174400,
        31981568: 4,
        33030144: 65792
      }, {
        "0": 2151682048,
        65536: 2147487808,
        131072: 4198464,
        196608: 2151677952,
        262144: 0,
        327680: 4198400,
        393216: 2147483712,
        458752: 4194368,
        524288: 2147483648,
        589824: 4194304,
        655360: 64,
        720896: 2147487744,
        786432: 2151678016,
        851968: 4160,
        917504: 4096,
        983040: 2151682112,
        32768: 2147487808,
        98304: 64,
        163840: 2151678016,
        229376: 2147487744,
        294912: 4198400,
        360448: 2151682112,
        425984: 0,
        491520: 2151677952,
        557056: 4096,
        622592: 2151682048,
        688128: 4194304,
        753664: 4160,
        819200: 2147483648,
        884736: 4194368,
        950272: 4198464,
        1015808: 2147483712,
        1048576: 4194368,
        1114112: 4198400,
        1179648: 2147483712,
        1245184: 0,
        1310720: 4160,
        1376256: 2151678016,
        1441792: 2151682048,
        1507328: 2147487808,
        1572864: 2151682112,
        1638400: 2147483648,
        1703936: 2151677952,
        1769472: 4198464,
        1835008: 2147487744,
        1900544: 4194304,
        1966080: 64,
        2031616: 4096,
        1081344: 2151677952,
        1146880: 2151682112,
        1212416: 0,
        1277952: 4198400,
        1343488: 4194368,
        1409024: 2147483648,
        1474560: 2147487808,
        1540096: 64,
        1605632: 2147483712,
        1671168: 4096,
        1736704: 2147487744,
        1802240: 2151678016,
        1867776: 4160,
        1933312: 2151682048,
        1998848: 4194304,
        2064384: 4198464
      }, {
        "0": 128,
        4096: 17039360,
        8192: 262144,
        12288: 536870912,
        16384: 537133184,
        20480: 16777344,
        24576: 553648256,
        28672: 262272,
        32768: 16777216,
        36864: 537133056,
        40960: 536871040,
        45056: 553910400,
        49152: 553910272,
        53248: 0,
        57344: 17039488,
        61440: 553648128,
        2048: 17039488,
        6144: 553648256,
        10240: 128,
        14336: 17039360,
        18432: 262144,
        22528: 537133184,
        26624: 553910272,
        30720: 536870912,
        34816: 537133056,
        38912: 0,
        43008: 553910400,
        47104: 16777344,
        51200: 536871040,
        55296: 553648128,
        59392: 16777216,
        63488: 262272,
        65536: 262144,
        69632: 128,
        73728: 536870912,
        77824: 553648256,
        81920: 16777344,
        86016: 553910272,
        90112: 537133184,
        94208: 16777216,
        98304: 553910400,
        102400: 553648128,
        106496: 17039360,
        110592: 537133056,
        114688: 262272,
        118784: 536871040,
        122880: 0,
        126976: 17039488,
        67584: 553648256,
        71680: 16777216,
        75776: 17039360,
        79872: 537133184,
        83968: 536870912,
        88064: 17039488,
        92160: 128,
        96256: 553910272,
        100352: 262272,
        104448: 553910400,
        108544: 0,
        112640: 553648128,
        116736: 16777344,
        120832: 262144,
        124928: 537133056,
        129024: 536871040
      }, {
        "0": 268435464,
        256: 8192,
        512: 270532608,
        768: 270540808,
        1024: 268443648,
        1280: 2097152,
        1536: 2097160,
        1792: 268435456,
        2048: 0,
        2304: 268443656,
        2560: 2105344,
        2816: 8,
        3072: 270532616,
        3328: 2105352,
        3584: 8200,
        3840: 270540800,
        128: 270532608,
        384: 270540808,
        640: 8,
        896: 2097152,
        1152: 2105352,
        1408: 268435464,
        1664: 268443648,
        1920: 8200,
        2176: 2097160,
        2432: 8192,
        2688: 268443656,
        2944: 270532616,
        3200: 0,
        3456: 270540800,
        3712: 2105344,
        3968: 268435456,
        4096: 268443648,
        4352: 270532616,
        4608: 270540808,
        4864: 8200,
        5120: 2097152,
        5376: 268435456,
        5632: 268435464,
        5888: 2105344,
        6144: 2105352,
        6400: 0,
        6656: 8,
        6912: 270532608,
        7168: 8192,
        7424: 268443656,
        7680: 270540800,
        7936: 2097160,
        4224: 8,
        4480: 2105344,
        4736: 2097152,
        4992: 268435464,
        5248: 268443648,
        5504: 8200,
        5760: 270540808,
        6016: 270532608,
        6272: 270540800,
        6528: 270532616,
        6784: 8192,
        7040: 2105352,
        7296: 2097160,
        7552: 0,
        7808: 268435456,
        8064: 268443656
      }, {
        "0": 1048576,
        16: 33555457,
        32: 1024,
        48: 1049601,
        64: 34604033,
        80: 0,
        96: 1,
        112: 34603009,
        128: 33555456,
        144: 1048577,
        160: 33554433,
        176: 34604032,
        192: 34603008,
        208: 1025,
        224: 1049600,
        240: 33554432,
        8: 34603009,
        24: 0,
        40: 33555457,
        56: 34604032,
        72: 1048576,
        88: 33554433,
        104: 33554432,
        120: 1025,
        136: 1049601,
        152: 33555456,
        168: 34603008,
        184: 1048577,
        200: 1024,
        216: 34604033,
        232: 1,
        248: 1049600,
        256: 33554432,
        272: 1048576,
        288: 33555457,
        304: 34603009,
        320: 1048577,
        336: 33555456,
        352: 34604032,
        368: 1049601,
        384: 1025,
        400: 34604033,
        416: 1049600,
        432: 1,
        448: 0,
        464: 34603008,
        480: 33554433,
        496: 1024,
        264: 1049600,
        280: 33555457,
        296: 34603009,
        312: 1,
        328: 33554432,
        344: 1048576,
        360: 1025,
        376: 34604032,
        392: 33554433,
        408: 34603008,
        424: 0,
        440: 34604033,
        456: 1049601,
        472: 1024,
        488: 33555456,
        504: 1048577
      }, {
        "0": 134219808,
        1: 131072,
        2: 134217728,
        3: 32,
        4: 131104,
        5: 134350880,
        6: 134350848,
        7: 2048,
        8: 134348800,
        9: 134219776,
        10: 133120,
        11: 134348832,
        12: 2080,
        13: 0,
        14: 134217760,
        15: 133152,
        2147483648: 2048,
        2147483649: 134350880,
        2147483650: 134219808,
        2147483651: 134217728,
        2147483652: 134348800,
        2147483653: 133120,
        2147483654: 133152,
        2147483655: 32,
        2147483656: 134217760,
        2147483657: 2080,
        2147483658: 131104,
        2147483659: 134350848,
        2147483660: 0,
        2147483661: 134348832,
        2147483662: 134219776,
        2147483663: 131072,
        16: 133152,
        17: 134350848,
        18: 32,
        19: 2048,
        20: 134219776,
        21: 134217760,
        22: 134348832,
        23: 131072,
        24: 0,
        25: 131104,
        26: 134348800,
        27: 134219808,
        28: 134350880,
        29: 133120,
        30: 2080,
        31: 134217728,
        2147483664: 131072,
        2147483665: 2048,
        2147483666: 134348832,
        2147483667: 133152,
        2147483668: 32,
        2147483669: 134348800,
        2147483670: 134217728,
        2147483671: 134219808,
        2147483672: 134350880,
        2147483673: 134217760,
        2147483674: 134219776,
        2147483675: 0,
        2147483676: 133120,
        2147483677: 2080,
        2147483678: 131104,
        2147483679: 134350848
      }], t2 = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679], m = g.DES = e.extend({ _doReset: function() {
        for (var b = this._key.words, c = [], a = 0; 56 > a; a++) {
          var f = q[a] - 1;
          c[a] = b[f >>> 5] >>> 31 - f % 32 & 1;
        }
        b = this._subKeys = [];
        for (f = 0; 16 > f; f++) {
          for (var d = b[f] = [], e2 = r[f], a = 0; 24 > a; a++)
            d[a / 6 | 0] |= c[(p[a] - 1 + e2) % 28] << 31 - a % 6, d[4 + (a / 6 | 0)] |= c[28 + (p[a + 24] - 1 + e2) % 28] << 31 - a % 6;
          d[0] = d[0] << 1 | d[0] >>> 31;
          for (a = 1; 7 > a; a++)
            d[a] >>>= 4 * (a - 1) + 3;
          d[7] = d[7] << 5 | d[7] >>> 27;
        }
        c = this._invSubKeys = [];
        for (a = 0; 16 > a; a++)
          c[a] = b[15 - a];
      }, encryptBlock: function(b, c) {
        this._doCryptBlock(b, c, this._subKeys);
      }, decryptBlock: function(b, c) {
        this._doCryptBlock(b, c, this._invSubKeys);
      }, _doCryptBlock: function(b, c, a) {
        this._lBlock = b[c];
        this._rBlock = b[c + 1];
        j.call(this, 4, 252645135);
        j.call(this, 16, 65535);
        l.call(this, 2, 858993459);
        l.call(this, 8, 16711935);
        j.call(this, 1, 1431655765);
        for (var f = 0; 16 > f; f++) {
          for (var d = a[f], e2 = this._lBlock, h2 = this._rBlock, g2 = 0, k = 0; 8 > k; k++)
            g2 |= s[k][((h2 ^ d[k]) & t2[k]) >>> 0];
          this._lBlock = h2;
          this._rBlock = e2 ^ g2;
        }
        a = this._lBlock;
        this._lBlock = this._rBlock;
        this._rBlock = a;
        j.call(this, 1, 1431655765);
        l.call(this, 8, 16711935);
        l.call(this, 2, 858993459);
        j.call(this, 16, 65535);
        j.call(this, 4, 252645135);
        b[c] = this._lBlock;
        b[c + 1] = this._rBlock;
      }, keySize: 2, ivSize: 2, blockSize: 2 });
      h.DES = e._createHelper(m);
      g = g.TripleDES = e.extend({ _doReset: function() {
        var b = this._key.words;
        this._des1 = m.createEncryptor(n.create(b.slice(0, 2)));
        this._des2 = m.createEncryptor(n.create(b.slice(2, 4)));
        this._des3 = m.createEncryptor(n.create(b.slice(4, 6)));
      }, encryptBlock: function(b, c) {
        this._des1.encryptBlock(b, c);
        this._des2.decryptBlock(b, c);
        this._des3.encryptBlock(b, c);
      }, decryptBlock: function(b, c) {
        this._des3.decryptBlock(b, c);
        this._des2.encryptBlock(b, c);
        this._des1.decryptBlock(b, c);
      }, keySize: 6, ivSize: 2, blockSize: 2 });
      h.TripleDES = e._createHelper(g);
    })();
    (function() {
      var h = CryptoJS, j = h.lib.WordArray;
      h.enc.Base64 = { stringify: function(b) {
        var e = b.words, f = b.sigBytes, c = this._map;
        b.clamp();
        b = [];
        for (var a = 0; a < f; a += 3)
          for (var d = (e[a >>> 2] >>> 24 - 8 * (a % 4) & 255) << 16 | (e[a + 1 >>> 2] >>> 24 - 8 * ((a + 1) % 4) & 255) << 8 | e[a + 2 >>> 2] >>> 24 - 8 * ((a + 2) % 4) & 255, g = 0; 4 > g && a + 0.75 * g < f; g++)
            b.push(c.charAt(d >>> 6 * (3 - g) & 63));
        if (e = c.charAt(64))
          for (; b.length % 4; )
            b.push(e);
        return b.join("");
      }, parse: function(b) {
        var e = b.length, f = this._map, c = f.charAt(64);
        c && (c = b.indexOf(c), c != -1 && (e = c));
        for (var c = [], a = 0, d = 0; d < e; d++)
          if (d % 4) {
            var g = f.indexOf(b.charAt(d - 1)) << 2 * (d % 4), h2 = f.indexOf(b.charAt(d)) >>> 6 - 2 * (d % 4);
            c[a >>> 2] |= (g | h2) << 24 - 8 * (a % 4);
            a++;
          }
        return j.create(c, a);
      }, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" };
    })();
    (function(E) {
      function h(a2, f, g, j, p, h2, k2) {
        a2 = a2 + (f & g | ~f & j) + p + k2;
        return (a2 << h2 | a2 >>> 32 - h2) + f;
      }
      function k(a2, f, g, j, p, h2, k2) {
        a2 = a2 + (f & j | g & ~j) + p + k2;
        return (a2 << h2 | a2 >>> 32 - h2) + f;
      }
      function l(a2, f, g, j, h2, k2, l2) {
        a2 = a2 + (f ^ g ^ j) + h2 + l2;
        return (a2 << k2 | a2 >>> 32 - k2) + f;
      }
      function n(a2, f, g, j, h2, k2, l2) {
        a2 = a2 + (g ^ (f | ~j)) + h2 + l2;
        return (a2 << k2 | a2 >>> 32 - k2) + f;
      }
      for (var r = CryptoJS, q = r.lib, F = q.WordArray, s = q.Hasher, q = r.algo, a = [], t2 = 0; 64 > t2; t2++)
        a[t2] = 4294967296 * E.abs(E.sin(t2 + 1)) | 0;
      q = q.MD5 = s.extend({
        _doReset: function() {
          this._hash = new F.init([1732584193, 4023233417, 2562383102, 271733878]);
        },
        _doProcessBlock: function(m, f) {
          for (var g = 0; 16 > g; g++) {
            var j = f + g, p = m[j];
            m[j] = (p << 8 | p >>> 24) & 16711935 | (p << 24 | p >>> 8) & 4278255360;
          }
          var g = this._hash.words, j = m[f + 0], p = m[f + 1], q2 = m[f + 2], r2 = m[f + 3], s2 = m[f + 4], t3 = m[f + 5], u = m[f + 6], v = m[f + 7], w = m[f + 8], x = m[f + 9], y = m[f + 10], z2 = m[f + 11], A = m[f + 12], B = m[f + 13], C = m[f + 14], D = m[f + 15], b = g[0], c = g[1], d = g[2], e = g[3], b = h(b, c, d, e, j, 7, a[0]), e = h(e, b, c, d, p, 12, a[1]), d = h(d, e, b, c, q2, 17, a[2]), c = h(c, d, e, b, r2, 22, a[3]), b = h(b, c, d, e, s2, 7, a[4]), e = h(e, b, c, d, t3, 12, a[5]), d = h(d, e, b, c, u, 17, a[6]), c = h(c, d, e, b, v, 22, a[7]), b = h(b, c, d, e, w, 7, a[8]), e = h(e, b, c, d, x, 12, a[9]), d = h(d, e, b, c, y, 17, a[10]), c = h(c, d, e, b, z2, 22, a[11]), b = h(b, c, d, e, A, 7, a[12]), e = h(e, b, c, d, B, 12, a[13]), d = h(d, e, b, c, C, 17, a[14]), c = h(c, d, e, b, D, 22, a[15]), b = k(b, c, d, e, p, 5, a[16]), e = k(e, b, c, d, u, 9, a[17]), d = k(d, e, b, c, z2, 14, a[18]), c = k(c, d, e, b, j, 20, a[19]), b = k(b, c, d, e, t3, 5, a[20]), e = k(e, b, c, d, y, 9, a[21]), d = k(d, e, b, c, D, 14, a[22]), c = k(c, d, e, b, s2, 20, a[23]), b = k(b, c, d, e, x, 5, a[24]), e = k(e, b, c, d, C, 9, a[25]), d = k(d, e, b, c, r2, 14, a[26]), c = k(c, d, e, b, w, 20, a[27]), b = k(b, c, d, e, B, 5, a[28]), e = k(e, b, c, d, q2, 9, a[29]), d = k(d, e, b, c, v, 14, a[30]), c = k(c, d, e, b, A, 20, a[31]), b = l(b, c, d, e, t3, 4, a[32]), e = l(e, b, c, d, w, 11, a[33]), d = l(d, e, b, c, z2, 16, a[34]), c = l(c, d, e, b, C, 23, a[35]), b = l(b, c, d, e, p, 4, a[36]), e = l(e, b, c, d, s2, 11, a[37]), d = l(d, e, b, c, v, 16, a[38]), c = l(c, d, e, b, y, 23, a[39]), b = l(b, c, d, e, B, 4, a[40]), e = l(e, b, c, d, j, 11, a[41]), d = l(d, e, b, c, r2, 16, a[42]), c = l(c, d, e, b, u, 23, a[43]), b = l(b, c, d, e, x, 4, a[44]), e = l(e, b, c, d, A, 11, a[45]), d = l(d, e, b, c, D, 16, a[46]), c = l(c, d, e, b, q2, 23, a[47]), b = n(b, c, d, e, j, 6, a[48]), e = n(e, b, c, d, v, 10, a[49]), d = n(d, e, b, c, C, 15, a[50]), c = n(c, d, e, b, t3, 21, a[51]), b = n(b, c, d, e, A, 6, a[52]), e = n(e, b, c, d, r2, 10, a[53]), d = n(d, e, b, c, y, 15, a[54]), c = n(c, d, e, b, p, 21, a[55]), b = n(b, c, d, e, w, 6, a[56]), e = n(e, b, c, d, D, 10, a[57]), d = n(d, e, b, c, u, 15, a[58]), c = n(c, d, e, b, B, 21, a[59]), b = n(b, c, d, e, s2, 6, a[60]), e = n(e, b, c, d, z2, 10, a[61]), d = n(d, e, b, c, q2, 15, a[62]), c = n(c, d, e, b, x, 21, a[63]);
          g[0] = g[0] + b | 0;
          g[1] = g[1] + c | 0;
          g[2] = g[2] + d | 0;
          g[3] = g[3] + e | 0;
        },
        _doFinalize: function() {
          var a2 = this._data, f = a2.words, g = 8 * this._nDataBytes, j = 8 * a2.sigBytes;
          f[j >>> 5] |= 128 << 24 - j % 32;
          var h2 = E.floor(g / 4294967296);
          f[(j + 64 >>> 9 << 4) + 15] = (h2 << 8 | h2 >>> 24) & 16711935 | (h2 << 24 | h2 >>> 8) & 4278255360;
          f[(j + 64 >>> 9 << 4) + 14] = (g << 8 | g >>> 24) & 16711935 | (g << 24 | g >>> 8) & 4278255360;
          a2.sigBytes = 4 * (f.length + 1);
          this._process();
          a2 = this._hash;
          f = a2.words;
          for (g = 0; 4 > g; g++)
            j = f[g], f[g] = (j << 8 | j >>> 24) & 16711935 | (j << 24 | j >>> 8) & 4278255360;
          return a2;
        },
        clone: function() {
          var a2 = s.clone.call(this);
          a2._hash = this._hash.clone();
          return a2;
        }
      });
      r.MD5 = s._createHelper(q);
      r.HmacMD5 = s._createHmacHelper(q);
    })(Math);
    (function() {
      var k = CryptoJS, b = k.lib, m = b.WordArray, l = b.Hasher, d = [], b = k.algo.SHA1 = l.extend({ _doReset: function() {
        this._hash = new m.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
      }, _doProcessBlock: function(n, p) {
        for (var a = this._hash.words, e = a[0], f = a[1], h = a[2], j = a[3], b2 = a[4], c = 0; 80 > c; c++) {
          if (16 > c)
            d[c] = n[p + c] | 0;
          else {
            var g = d[c - 3] ^ d[c - 8] ^ d[c - 14] ^ d[c - 16];
            d[c] = g << 1 | g >>> 31;
          }
          g = (e << 5 | e >>> 27) + b2 + d[c];
          g = 20 > c ? g + ((f & h | ~f & j) + 1518500249) : 40 > c ? g + ((f ^ h ^ j) + 1859775393) : 60 > c ? g + ((f & h | f & j | h & j) - 1894007588) : g + ((f ^ h ^ j) - 899497514);
          b2 = j;
          j = h;
          h = f << 30 | f >>> 2;
          f = e;
          e = g;
        }
        a[0] = a[0] + e | 0;
        a[1] = a[1] + f | 0;
        a[2] = a[2] + h | 0;
        a[3] = a[3] + j | 0;
        a[4] = a[4] + b2 | 0;
      }, _doFinalize: function() {
        var b2 = this._data, d2 = b2.words, a = 8 * this._nDataBytes, e = 8 * b2.sigBytes;
        d2[e >>> 5] |= 128 << 24 - e % 32;
        d2[(e + 64 >>> 9 << 4) + 14] = Math.floor(a / 4294967296);
        d2[(e + 64 >>> 9 << 4) + 15] = a;
        b2.sigBytes = 4 * d2.length;
        this._process();
        return this._hash;
      }, clone: function() {
        var b2 = l.clone.call(this);
        b2._hash = this._hash.clone();
        return b2;
      } });
      k.SHA1 = l._createHelper(b);
      k.HmacSHA1 = l._createHmacHelper(b);
    })();
    (function(k) {
      for (var g = CryptoJS, h = g.lib, v = h.WordArray, j = h.Hasher, h = g.algo, s = [], t2 = [], u = function(q) {
        return 4294967296 * (q - (q | 0)) | 0;
      }, l = 2, b = 0; 64 > b; ) {
        var d;
        a: {
          d = l;
          for (var w = k.sqrt(d), r = 2; r <= w; r++)
            if (!(d % r)) {
              d = false;
              break a;
            }
          d = true;
        }
        d && (8 > b && (s[b] = u(k.pow(l, 0.5))), t2[b] = u(k.pow(l, 1 / 3)), b++);
        l++;
      }
      var n = [], h = h.SHA256 = j.extend({ _doReset: function() {
        this._hash = new v.init(s.slice(0));
      }, _doProcessBlock: function(q, h2) {
        for (var a = this._hash.words, c = a[0], d2 = a[1], b2 = a[2], k2 = a[3], f = a[4], g2 = a[5], j2 = a[6], l2 = a[7], e = 0; 64 > e; e++) {
          if (16 > e)
            n[e] = q[h2 + e] | 0;
          else {
            var m = n[e - 15], p = n[e - 2];
            n[e] = ((m << 25 | m >>> 7) ^ (m << 14 | m >>> 18) ^ m >>> 3) + n[e - 7] + ((p << 15 | p >>> 17) ^ (p << 13 | p >>> 19) ^ p >>> 10) + n[e - 16];
          }
          m = l2 + ((f << 26 | f >>> 6) ^ (f << 21 | f >>> 11) ^ (f << 7 | f >>> 25)) + (f & g2 ^ ~f & j2) + t2[e] + n[e];
          p = ((c << 30 | c >>> 2) ^ (c << 19 | c >>> 13) ^ (c << 10 | c >>> 22)) + (c & d2 ^ c & b2 ^ d2 & b2);
          l2 = j2;
          j2 = g2;
          g2 = f;
          f = k2 + m | 0;
          k2 = b2;
          b2 = d2;
          d2 = c;
          c = m + p | 0;
        }
        a[0] = a[0] + c | 0;
        a[1] = a[1] + d2 | 0;
        a[2] = a[2] + b2 | 0;
        a[3] = a[3] + k2 | 0;
        a[4] = a[4] + f | 0;
        a[5] = a[5] + g2 | 0;
        a[6] = a[6] + j2 | 0;
        a[7] = a[7] + l2 | 0;
      }, _doFinalize: function() {
        var d2 = this._data, b2 = d2.words, a = 8 * this._nDataBytes, c = 8 * d2.sigBytes;
        b2[c >>> 5] |= 128 << 24 - c % 32;
        b2[(c + 64 >>> 9 << 4) + 14] = k.floor(a / 4294967296);
        b2[(c + 64 >>> 9 << 4) + 15] = a;
        d2.sigBytes = 4 * b2.length;
        this._process();
        return this._hash;
      }, clone: function() {
        var b2 = j.clone.call(this);
        b2._hash = this._hash.clone();
        return b2;
      } });
      g.SHA256 = j._createHelper(h);
      g.HmacSHA256 = j._createHmacHelper(h);
    })(Math);
    (function() {
      var b = CryptoJS, d = b.lib.WordArray, a = b.algo, c = a.SHA256, a = a.SHA224 = c.extend({ _doReset: function() {
        this._hash = new d.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]);
      }, _doFinalize: function() {
        var a2 = c._doFinalize.call(this);
        a2.sigBytes -= 4;
        return a2;
      } });
      b.SHA224 = c._createHelper(a);
      b.HmacSHA224 = c._createHmacHelper(a);
    })();
    (function() {
      function a() {
        return d.create.apply(d, arguments);
      }
      for (var n = CryptoJS, r = n.lib.Hasher, e = n.x64, d = e.Word, T = e.WordArray, e = n.algo, ea = [
        a(1116352408, 3609767458),
        a(1899447441, 602891725),
        a(3049323471, 3964484399),
        a(3921009573, 2173295548),
        a(961987163, 4081628472),
        a(1508970993, 3053834265),
        a(2453635748, 2937671579),
        a(2870763221, 3664609560),
        a(3624381080, 2734883394),
        a(310598401, 1164996542),
        a(607225278, 1323610764),
        a(1426881987, 3590304994),
        a(1925078388, 4068182383),
        a(2162078206, 991336113),
        a(2614888103, 633803317),
        a(3248222580, 3479774868),
        a(3835390401, 2666613458),
        a(4022224774, 944711139),
        a(264347078, 2341262773),
        a(604807628, 2007800933),
        a(770255983, 1495990901),
        a(1249150122, 1856431235),
        a(1555081692, 3175218132),
        a(1996064986, 2198950837),
        a(2554220882, 3999719339),
        a(2821834349, 766784016),
        a(2952996808, 2566594879),
        a(3210313671, 3203337956),
        a(3336571891, 1034457026),
        a(3584528711, 2466948901),
        a(113926993, 3758326383),
        a(338241895, 168717936),
        a(666307205, 1188179964),
        a(773529912, 1546045734),
        a(1294757372, 1522805485),
        a(1396182291, 2643833823),
        a(1695183700, 2343527390),
        a(1986661051, 1014477480),
        a(2177026350, 1206759142),
        a(2456956037, 344077627),
        a(2730485921, 1290863460),
        a(2820302411, 3158454273),
        a(3259730800, 3505952657),
        a(3345764771, 106217008),
        a(3516065817, 3606008344),
        a(3600352804, 1432725776),
        a(4094571909, 1467031594),
        a(275423344, 851169720),
        a(430227734, 3100823752),
        a(506948616, 1363258195),
        a(659060556, 3750685593),
        a(883997877, 3785050280),
        a(958139571, 3318307427),
        a(1322822218, 3812723403),
        a(1537002063, 2003034995),
        a(1747873779, 3602036899),
        a(1955562222, 1575990012),
        a(2024104815, 1125592928),
        a(2227730452, 2716904306),
        a(2361852424, 442776044),
        a(2428436474, 593698344),
        a(2756734187, 3733110249),
        a(3204031479, 2999351573),
        a(3329325298, 3815920427),
        a(3391569614, 3928383900),
        a(3515267271, 566280711),
        a(3940187606, 3454069534),
        a(4118630271, 4000239992),
        a(116418474, 1914138554),
        a(174292421, 2731055270),
        a(289380356, 3203993006),
        a(460393269, 320620315),
        a(685471733, 587496836),
        a(852142971, 1086792851),
        a(1017036298, 365543100),
        a(1126000580, 2618297676),
        a(1288033470, 3409855158),
        a(1501505948, 4234509866),
        a(1607167915, 987167468),
        a(1816402316, 1246189591)
      ], v = [], w = 0; 80 > w; w++)
        v[w] = a();
      e = e.SHA512 = r.extend({ _doReset: function() {
        this._hash = new T.init([new d.init(1779033703, 4089235720), new d.init(3144134277, 2227873595), new d.init(1013904242, 4271175723), new d.init(2773480762, 1595750129), new d.init(1359893119, 2917565137), new d.init(2600822924, 725511199), new d.init(528734635, 4215389547), new d.init(1541459225, 327033209)]);
      }, _doProcessBlock: function(a2, d2) {
        for (var f = this._hash.words, F = f[0], e2 = f[1], n2 = f[2], r2 = f[3], G = f[4], H = f[5], I = f[6], f = f[7], w2 = F.high, J = F.low, X = e2.high, K = e2.low, Y = n2.high, L = n2.low, Z = r2.high, M = r2.low, $ = G.high, N = G.low, aa = H.high, O = H.low, ba = I.high, P = I.low, ca = f.high, Q = f.low, k = w2, g = J, z2 = X, x = K, A = Y, y = L, U = Z, B = M, l = $, h = N, R = aa, C = O, S = ba, D = P, V = ca, E = Q, m = 0; 80 > m; m++) {
          var s = v[m];
          if (16 > m)
            var j = s.high = a2[d2 + 2 * m] | 0, b = s.low = a2[d2 + 2 * m + 1] | 0;
          else {
            var j = v[m - 15], b = j.high, p = j.low, j = (b >>> 1 | p << 31) ^ (b >>> 8 | p << 24) ^ b >>> 7, p = (p >>> 1 | b << 31) ^ (p >>> 8 | b << 24) ^ (p >>> 7 | b << 25), u = v[m - 2], b = u.high, c = u.low, u = (b >>> 19 | c << 13) ^ (b << 3 | c >>> 29) ^ b >>> 6, c = (c >>> 19 | b << 13) ^ (c << 3 | b >>> 29) ^ (c >>> 6 | b << 26), b = v[m - 7], W = b.high, t2 = v[m - 16], q = t2.high, t2 = t2.low, b = p + b.low, j = j + W + (b >>> 0 < p >>> 0 ? 1 : 0), b = b + c, j = j + u + (b >>> 0 < c >>> 0 ? 1 : 0), b = b + t2, j = j + q + (b >>> 0 < t2 >>> 0 ? 1 : 0);
            s.high = j;
            s.low = b;
          }
          var W = l & R ^ ~l & S, t2 = h & C ^ ~h & D, s = k & z2 ^ k & A ^ z2 & A, T2 = g & x ^ g & y ^ x & y, p = (k >>> 28 | g << 4) ^ (k << 30 | g >>> 2) ^ (k << 25 | g >>> 7), u = (g >>> 28 | k << 4) ^ (g << 30 | k >>> 2) ^ (g << 25 | k >>> 7), c = ea[m], fa = c.high, da = c.low, c = E + ((h >>> 14 | l << 18) ^ (h >>> 18 | l << 14) ^ (h << 23 | l >>> 9)), q = V + ((l >>> 14 | h << 18) ^ (l >>> 18 | h << 14) ^ (l << 23 | h >>> 9)) + (c >>> 0 < E >>> 0 ? 1 : 0), c = c + t2, q = q + W + (c >>> 0 < t2 >>> 0 ? 1 : 0), c = c + da, q = q + fa + (c >>> 0 < da >>> 0 ? 1 : 0), c = c + b, q = q + j + (c >>> 0 < b >>> 0 ? 1 : 0), b = u + T2, s = p + s + (b >>> 0 < u >>> 0 ? 1 : 0), V = S, E = D, S = R, D = C, R = l, C = h, h = B + c | 0, l = U + q + (h >>> 0 < B >>> 0 ? 1 : 0) | 0, U = A, B = y, A = z2, y = x, z2 = k, x = g, g = c + b | 0, k = q + s + (g >>> 0 < c >>> 0 ? 1 : 0) | 0;
        }
        J = F.low = J + g;
        F.high = w2 + k + (J >>> 0 < g >>> 0 ? 1 : 0);
        K = e2.low = K + x;
        e2.high = X + z2 + (K >>> 0 < x >>> 0 ? 1 : 0);
        L = n2.low = L + y;
        n2.high = Y + A + (L >>> 0 < y >>> 0 ? 1 : 0);
        M = r2.low = M + B;
        r2.high = Z + U + (M >>> 0 < B >>> 0 ? 1 : 0);
        N = G.low = N + h;
        G.high = $ + l + (N >>> 0 < h >>> 0 ? 1 : 0);
        O = H.low = O + C;
        H.high = aa + R + (O >>> 0 < C >>> 0 ? 1 : 0);
        P = I.low = P + D;
        I.high = ba + S + (P >>> 0 < D >>> 0 ? 1 : 0);
        Q = f.low = Q + E;
        f.high = ca + V + (Q >>> 0 < E >>> 0 ? 1 : 0);
      }, _doFinalize: function() {
        var a2 = this._data, d2 = a2.words, f = 8 * this._nDataBytes, e2 = 8 * a2.sigBytes;
        d2[e2 >>> 5] |= 128 << 24 - e2 % 32;
        d2[(e2 + 128 >>> 10 << 5) + 30] = Math.floor(f / 4294967296);
        d2[(e2 + 128 >>> 10 << 5) + 31] = f;
        a2.sigBytes = 4 * d2.length;
        this._process();
        return this._hash.toX32();
      }, clone: function() {
        var a2 = r.clone.call(this);
        a2._hash = this._hash.clone();
        return a2;
      }, blockSize: 32 });
      n.SHA512 = r._createHelper(e);
      n.HmacSHA512 = r._createHmacHelper(e);
    })();
    (function() {
      var c = CryptoJS, a = c.x64, b = a.Word, e = a.WordArray, a = c.algo, d = a.SHA512, a = a.SHA384 = d.extend({ _doReset: function() {
        this._hash = new e.init([new b.init(3418070365, 3238371032), new b.init(1654270250, 914150663), new b.init(2438529370, 812702999), new b.init(355462360, 4144912697), new b.init(1731405415, 4290775857), new b.init(2394180231, 1750603025), new b.init(3675008525, 1694076839), new b.init(1203062813, 3204075428)]);
      }, _doFinalize: function() {
        var a2 = d._doFinalize.call(this);
        a2.sigBytes -= 16;
        return a2;
      } });
      c.SHA384 = d._createHelper(a);
      c.HmacSHA384 = d._createHmacHelper(a);
    })();
    (function() {
      var q = CryptoJS, d = q.lib, n = d.WordArray, p = d.Hasher, d = q.algo, x = n.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]), y = n.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]), z2 = n.create([
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8,
        7,
        6,
        8,
        13,
        11,
        9,
        7,
        15,
        7,
        12,
        15,
        9,
        11,
        7,
        13,
        12,
        11,
        13,
        6,
        7,
        14,
        9,
        13,
        15,
        14,
        8,
        13,
        6,
        5,
        12,
        7,
        5,
        11,
        12,
        14,
        15,
        14,
        15,
        9,
        8,
        9,
        14,
        5,
        6,
        8,
        6,
        5,
        12,
        9,
        15,
        5,
        11,
        6,
        8,
        13,
        12,
        5,
        12,
        13,
        14,
        11,
        8,
        5,
        6
      ]), A = n.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]), B = n.create([0, 1518500249, 1859775393, 2400959708, 2840853838]), C = n.create([
        1352829926,
        1548603684,
        1836072691,
        2053994217,
        0
      ]), d = d.RIPEMD160 = p.extend({ _doReset: function() {
        this._hash = n.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
      }, _doProcessBlock: function(e, v) {
        for (var b = 0; 16 > b; b++) {
          var c = v + b, f = e[c];
          e[c] = (f << 8 | f >>> 24) & 16711935 | (f << 24 | f >>> 8) & 4278255360;
        }
        var c = this._hash.words, f = B.words, d2 = C.words, n2 = x.words, q2 = y.words, p2 = z2.words, w = A.words, t2, g, h, j, r, u, k, l, m, s;
        u = t2 = c[0];
        k = g = c[1];
        l = h = c[2];
        m = j = c[3];
        s = r = c[4];
        for (var a, b = 0; 80 > b; b += 1)
          a = t2 + e[v + n2[b]] | 0, a = 16 > b ? a + ((g ^ h ^ j) + f[0]) : 32 > b ? a + ((g & h | ~g & j) + f[1]) : 48 > b ? a + (((g | ~h) ^ j) + f[2]) : 64 > b ? a + ((g & j | h & ~j) + f[3]) : a + ((g ^ (h | ~j)) + f[4]), a |= 0, a = a << p2[b] | a >>> 32 - p2[b], a = a + r | 0, t2 = r, r = j, j = h << 10 | h >>> 22, h = g, g = a, a = u + e[v + q2[b]] | 0, a = 16 > b ? a + ((k ^ (l | ~m)) + d2[0]) : 32 > b ? a + ((k & m | l & ~m) + d2[1]) : 48 > b ? a + (((k | ~l) ^ m) + d2[2]) : 64 > b ? a + ((k & l | ~k & m) + d2[3]) : a + ((k ^ l ^ m) + d2[4]), a |= 0, a = a << w[b] | a >>> 32 - w[b], a = a + s | 0, u = s, s = m, m = l << 10 | l >>> 22, l = k, k = a;
        a = c[1] + h + m | 0;
        c[1] = c[2] + j + s | 0;
        c[2] = c[3] + r + u | 0;
        c[3] = c[4] + t2 + k | 0;
        c[4] = c[0] + g + l | 0;
        c[0] = a;
      }, _doFinalize: function() {
        var e = this._data, d2 = e.words, b = 8 * this._nDataBytes, c = 8 * e.sigBytes;
        d2[c >>> 5] |= 128 << 24 - c % 32;
        d2[(c + 64 >>> 9 << 4) + 14] = (b << 8 | b >>> 24) & 16711935 | (b << 24 | b >>> 8) & 4278255360;
        e.sigBytes = 4 * (d2.length + 1);
        this._process();
        e = this._hash;
        d2 = e.words;
        for (b = 0; 5 > b; b++)
          c = d2[b], d2[b] = (c << 8 | c >>> 24) & 16711935 | (c << 24 | c >>> 8) & 4278255360;
        return e;
      }, clone: function() {
        var d2 = p.clone.call(this);
        d2._hash = this._hash.clone();
        return d2;
      } });
      q.RIPEMD160 = p._createHelper(d);
      q.HmacRIPEMD160 = p._createHmacHelper(d);
    })(Math);
    (function() {
      var c = CryptoJS, k = c.enc.Utf8;
      c.algo.HMAC = c.lib.Base.extend({ init: function(a, b) {
        a = this._hasher = new a.init();
        typeof b == "string" && (b = k.parse(b));
        var c2 = a.blockSize, e = 4 * c2;
        b.sigBytes > e && (b = a.finalize(b));
        b.clamp();
        for (var f = this._oKey = b.clone(), g = this._iKey = b.clone(), h = f.words, j = g.words, d = 0; d < c2; d++)
          h[d] ^= 1549556828, j[d] ^= 909522486;
        f.sigBytes = g.sigBytes = e;
        this.reset();
      }, reset: function() {
        var a = this._hasher;
        a.reset();
        a.update(this._iKey);
      }, update: function(a) {
        this._hasher.update(a);
        return this;
      }, finalize: function(a) {
        var b = this._hasher;
        a = b.finalize(a);
        b.reset();
        return b.finalize(this._oKey.clone().concat(a));
      } });
    })();
    (function() {
      var b = CryptoJS, a = b.lib, d = a.Base, m = a.WordArray, a = b.algo, q = a.HMAC, l = a.PBKDF2 = d.extend({ cfg: d.extend({ keySize: 4, hasher: a.SHA1, iterations: 1 }), init: function(a2) {
        this.cfg = this.cfg.extend(a2);
      }, compute: function(a2, b2) {
        for (var c = this.cfg, f = q.create(c.hasher, a2), g = m.create(), d2 = m.create([1]), l2 = g.words, r = d2.words, n = c.keySize, c = c.iterations; l2.length < n; ) {
          var h = f.update(b2).finalize(d2);
          f.reset();
          for (var j = h.words, s = j.length, k = h, p = 1; p < c; p++) {
            k = f.finalize(k);
            f.reset();
            for (var t2 = k.words, e = 0; e < s; e++)
              j[e] ^= t2[e];
          }
          g.concat(h);
          r[0]++;
        }
        g.sigBytes = 4 * n;
        return g;
      } });
      b.PBKDF2 = function(a2, b2, c) {
        return l.create(c).compute(a2, b2);
      };
    })();
    var b64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var b64pad = "=";
    function hex2b64(d) {
      var b;
      var e;
      var a = "";
      for (b = 0; b + 3 <= d.length; b += 3) {
        e = parseInt(d.substring(b, b + 3), 16);
        a += b64map.charAt(e >> 6) + b64map.charAt(e & 63);
      }
      if (b + 1 == d.length) {
        e = parseInt(d.substring(b, b + 1), 16);
        a += b64map.charAt(e << 2);
      } else {
        if (b + 2 == d.length) {
          e = parseInt(d.substring(b, b + 2), 16);
          a += b64map.charAt(e >> 2) + b64map.charAt((e & 3) << 4);
        }
      }
      if (b64pad) {
        while ((a.length & 3) > 0) {
          a += b64pad;
        }
      }
      return a;
    }
    function b64tohex(f) {
      var d = "";
      var e;
      var b = 0;
      var c;
      var a;
      for (e = 0; e < f.length; ++e) {
        if (f.charAt(e) == b64pad) {
          break;
        }
        a = b64map.indexOf(f.charAt(e));
        if (a < 0) {
          continue;
        }
        if (b == 0) {
          d += int2char(a >> 2);
          c = a & 3;
          b = 1;
        } else {
          if (b == 1) {
            d += int2char(c << 2 | a >> 4);
            c = a & 15;
            b = 2;
          } else {
            if (b == 2) {
              d += int2char(c);
              d += int2char(a >> 2);
              c = a & 3;
              b = 3;
            } else {
              d += int2char(c << 2 | a >> 4);
              d += int2char(a & 15);
              b = 0;
            }
          }
        }
      }
      if (b == 1) {
        d += int2char(c << 2);
      }
      return d;
    }
    function b64toBA(e) {
      var d = b64tohex(e);
      var c;
      var b = new Array();
      for (c = 0; 2 * c < d.length; ++c) {
        b[c] = parseInt(d.substring(2 * c, 2 * c + 2), 16);
      }
      return b;
    }
    var dbits;
    var canary = 244837814094590;
    var j_lm = (canary & 16777215) == 15715070;
    function BigInteger(e, d, f) {
      if (e != null) {
        if (typeof e == "number") {
          this.fromNumber(e, d, f);
        } else {
          if (d == null && typeof e != "string") {
            this.fromString(e, 256);
          } else {
            this.fromString(e, d);
          }
        }
      }
    }
    function nbi() {
      return new BigInteger(null);
    }
    function am1(f, a, b, e, h, g) {
      while (--g >= 0) {
        var d = a * this[f++] + b[e] + h;
        h = Math.floor(d / 67108864);
        b[e++] = d & 67108863;
      }
      return h;
    }
    function am2(f, q, r, e, o, a) {
      var k = q & 32767, p = q >> 15;
      while (--a >= 0) {
        var d = this[f] & 32767;
        var g = this[f++] >> 15;
        var b = p * d + g * k;
        d = k * d + ((b & 32767) << 15) + r[e] + (o & 1073741823);
        o = (d >>> 30) + (b >>> 15) + p * g + (o >>> 30);
        r[e++] = d & 1073741823;
      }
      return o;
    }
    function am3(f, q, r, e, o, a) {
      var k = q & 16383, p = q >> 14;
      while (--a >= 0) {
        var d = this[f] & 16383;
        var g = this[f++] >> 14;
        var b = p * d + g * k;
        d = k * d + ((b & 16383) << 14) + r[e] + o;
        o = (d >> 28) + (b >> 14) + p * g;
        r[e++] = d & 268435455;
      }
      return o;
    }
    if (j_lm && navigator.appName == "Microsoft Internet Explorer") {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else {
      if (j_lm && navigator.appName != "Netscape") {
        BigInteger.prototype.am = am1;
        dbits = 26;
      } else {
        BigInteger.prototype.am = am3;
        dbits = 28;
      }
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    BigInteger.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr;
    var vv;
    rr = "0".charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv) {
      BI_RC[rr++] = vv;
    }
    rr = "a".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv) {
      BI_RC[rr++] = vv;
    }
    rr = "A".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv) {
      BI_RC[rr++] = vv;
    }
    function int2char(a) {
      return BI_RM.charAt(a);
    }
    function intAt(b, a) {
      var d = BI_RC[b.charCodeAt(a)];
      return d == null ? -1 : d;
    }
    function bnpCopyTo(b) {
      for (var a = this.t - 1; a >= 0; --a) {
        b[a] = this[a];
      }
      b.t = this.t;
      b.s = this.s;
    }
    function bnpFromInt(a) {
      this.t = 1;
      this.s = a < 0 ? -1 : 0;
      if (a > 0) {
        this[0] = a;
      } else {
        if (a < -1) {
          this[0] = a + this.DV;
        } else {
          this.t = 0;
        }
      }
    }
    function nbv(a) {
      var b = nbi();
      b.fromInt(a);
      return b;
    }
    function bnpFromString(h, c) {
      var e;
      if (c == 16) {
        e = 4;
      } else {
        if (c == 8) {
          e = 3;
        } else {
          if (c == 256) {
            e = 8;
          } else {
            if (c == 2) {
              e = 1;
            } else {
              if (c == 32) {
                e = 5;
              } else {
                if (c == 4) {
                  e = 2;
                } else {
                  this.fromRadix(h, c);
                  return;
                }
              }
            }
          }
        }
      }
      this.t = 0;
      this.s = 0;
      var g = h.length, d = false, f = 0;
      while (--g >= 0) {
        var a = e == 8 ? h[g] & 255 : intAt(h, g);
        if (a < 0) {
          if (h.charAt(g) == "-") {
            d = true;
          }
          continue;
        }
        d = false;
        if (f == 0) {
          this[this.t++] = a;
        } else {
          if (f + e > this.DB) {
            this[this.t - 1] |= (a & (1 << this.DB - f) - 1) << f;
            this[this.t++] = a >> this.DB - f;
          } else {
            this[this.t - 1] |= a << f;
          }
        }
        f += e;
        if (f >= this.DB) {
          f -= this.DB;
        }
      }
      if (e == 8 && (h[0] & 128) != 0) {
        this.s = -1;
        if (f > 0) {
          this[this.t - 1] |= (1 << this.DB - f) - 1 << f;
        }
      }
      this.clamp();
      if (d) {
        BigInteger.ZERO.subTo(this, this);
      }
    }
    function bnpClamp() {
      var a = this.s & this.DM;
      while (this.t > 0 && this[this.t - 1] == a) {
        --this.t;
      }
    }
    function bnToString(c) {
      if (this.s < 0) {
        return "-" + this.negate().toString(c);
      }
      var e;
      if (c == 16) {
        e = 4;
      } else {
        if (c == 8) {
          e = 3;
        } else {
          if (c == 2) {
            e = 1;
          } else {
            if (c == 32) {
              e = 5;
            } else {
              if (c == 4) {
                e = 2;
              } else {
                return this.toRadix(c);
              }
            }
          }
        }
      }
      var g = (1 << e) - 1, l, a = false, h = "", f = this.t;
      var j = this.DB - f * this.DB % e;
      if (f-- > 0) {
        if (j < this.DB && (l = this[f] >> j) > 0) {
          a = true;
          h = int2char(l);
        }
        while (f >= 0) {
          if (j < e) {
            l = (this[f] & (1 << j) - 1) << e - j;
            l |= this[--f] >> (j += this.DB - e);
          } else {
            l = this[f] >> (j -= e) & g;
            if (j <= 0) {
              j += this.DB;
              --f;
            }
          }
          if (l > 0) {
            a = true;
          }
          if (a) {
            h += int2char(l);
          }
        }
      }
      return a ? h : "0";
    }
    function bnNegate() {
      var a = nbi();
      BigInteger.ZERO.subTo(this, a);
      return a;
    }
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo(b) {
      var d = this.s - b.s;
      if (d != 0) {
        return d;
      }
      var c = this.t;
      d = c - b.t;
      if (d != 0) {
        return this.s < 0 ? -d : d;
      }
      while (--c >= 0) {
        if ((d = this[c] - b[c]) != 0) {
          return d;
        }
      }
      return 0;
    }
    function nbits(a) {
      var c = 1, b;
      if ((b = a >>> 16) != 0) {
        a = b;
        c += 16;
      }
      if ((b = a >> 8) != 0) {
        a = b;
        c += 8;
      }
      if ((b = a >> 4) != 0) {
        a = b;
        c += 4;
      }
      if ((b = a >> 2) != 0) {
        a = b;
        c += 2;
      }
      if ((b = a >> 1) != 0) {
        a = b;
        c += 1;
      }
      return c;
    }
    function bnBitLength() {
      if (this.t <= 0) {
        return 0;
      }
      return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
    }
    function bnpDLShiftTo(c, b) {
      var a;
      for (a = this.t - 1; a >= 0; --a) {
        b[a + c] = this[a];
      }
      for (a = c - 1; a >= 0; --a) {
        b[a] = 0;
      }
      b.t = this.t + c;
      b.s = this.s;
    }
    function bnpDRShiftTo(c, b) {
      for (var a = c; a < this.t; ++a) {
        b[a - c] = this[a];
      }
      b.t = Math.max(this.t - c, 0);
      b.s = this.s;
    }
    function bnpLShiftTo(j, e) {
      var b = j % this.DB;
      var a = this.DB - b;
      var g = (1 << a) - 1;
      var f = Math.floor(j / this.DB), h = this.s << b & this.DM, d;
      for (d = this.t - 1; d >= 0; --d) {
        e[d + f + 1] = this[d] >> a | h;
        h = (this[d] & g) << b;
      }
      for (d = f - 1; d >= 0; --d) {
        e[d] = 0;
      }
      e[f] = h;
      e.t = this.t + f + 1;
      e.s = this.s;
      e.clamp();
    }
    function bnpRShiftTo(g, d) {
      d.s = this.s;
      var e = Math.floor(g / this.DB);
      if (e >= this.t) {
        d.t = 0;
        return;
      }
      var b = g % this.DB;
      var a = this.DB - b;
      var f = (1 << b) - 1;
      d[0] = this[e] >> b;
      for (var c = e + 1; c < this.t; ++c) {
        d[c - e - 1] |= (this[c] & f) << a;
        d[c - e] = this[c] >> b;
      }
      if (b > 0) {
        d[this.t - e - 1] |= (this.s & f) << a;
      }
      d.t = this.t - e;
      d.clamp();
    }
    function bnpSubTo(d, f) {
      var e = 0, g = 0, b = Math.min(d.t, this.t);
      while (e < b) {
        g += this[e] - d[e];
        f[e++] = g & this.DM;
        g >>= this.DB;
      }
      if (d.t < this.t) {
        g -= d.s;
        while (e < this.t) {
          g += this[e];
          f[e++] = g & this.DM;
          g >>= this.DB;
        }
        g += this.s;
      } else {
        g += this.s;
        while (e < d.t) {
          g -= d[e];
          f[e++] = g & this.DM;
          g >>= this.DB;
        }
        g -= d.s;
      }
      f.s = g < 0 ? -1 : 0;
      if (g < -1) {
        f[e++] = this.DV + g;
      } else {
        if (g > 0) {
          f[e++] = g;
        }
      }
      f.t = e;
      f.clamp();
    }
    function bnpMultiplyTo(c, e) {
      var b = this.abs(), f = c.abs();
      var d = b.t;
      e.t = d + f.t;
      while (--d >= 0) {
        e[d] = 0;
      }
      for (d = 0; d < f.t; ++d) {
        e[d + b.t] = b.am(0, f[d], e, d, 0, b.t);
      }
      e.s = 0;
      e.clamp();
      if (this.s != c.s) {
        BigInteger.ZERO.subTo(e, e);
      }
    }
    function bnpSquareTo(d) {
      var a = this.abs();
      var b = d.t = 2 * a.t;
      while (--b >= 0) {
        d[b] = 0;
      }
      for (b = 0; b < a.t - 1; ++b) {
        var e = a.am(b, a[b], d, 2 * b, 0, 1);
        if ((d[b + a.t] += a.am(b + 1, 2 * a[b], d, 2 * b + 1, e, a.t - b - 1)) >= a.DV) {
          d[b + a.t] -= a.DV;
          d[b + a.t + 1] = 1;
        }
      }
      if (d.t > 0) {
        d[d.t - 1] += a.am(b, a[b], d, 2 * b, 0, 1);
      }
      d.s = 0;
      d.clamp();
    }
    function bnpDivRemTo(n, h, g) {
      var w = n.abs();
      if (w.t <= 0) {
        return;
      }
      var k = this.abs();
      if (k.t < w.t) {
        if (h != null) {
          h.fromInt(0);
        }
        if (g != null) {
          this.copyTo(g);
        }
        return;
      }
      if (g == null) {
        g = nbi();
      }
      var d = nbi(), a = this.s, l = n.s;
      var v = this.DB - nbits(w[w.t - 1]);
      if (v > 0) {
        w.lShiftTo(v, d);
        k.lShiftTo(v, g);
      } else {
        w.copyTo(d);
        k.copyTo(g);
      }
      var p = d.t;
      var b = d[p - 1];
      if (b == 0) {
        return;
      }
      var o = b * (1 << this.F1) + (p > 1 ? d[p - 2] >> this.F2 : 0);
      var A = this.FV / o, z2 = (1 << this.F1) / o, x = 1 << this.F2;
      var u = g.t, s = u - p, f = h == null ? nbi() : h;
      d.dlShiftTo(s, f);
      if (g.compareTo(f) >= 0) {
        g[g.t++] = 1;
        g.subTo(f, g);
      }
      BigInteger.ONE.dlShiftTo(p, f);
      f.subTo(d, d);
      while (d.t < p) {
        d[d.t++] = 0;
      }
      while (--s >= 0) {
        var c = g[--u] == b ? this.DM : Math.floor(g[u] * A + (g[u - 1] + x) * z2);
        if ((g[u] += d.am(0, c, g, s, 0, p)) < c) {
          d.dlShiftTo(s, f);
          g.subTo(f, g);
          while (g[u] < --c) {
            g.subTo(f, g);
          }
        }
      }
      if (h != null) {
        g.drShiftTo(p, h);
        if (a != l) {
          BigInteger.ZERO.subTo(h, h);
        }
      }
      g.t = p;
      g.clamp();
      if (v > 0) {
        g.rShiftTo(v, g);
      }
      if (a < 0) {
        BigInteger.ZERO.subTo(g, g);
      }
    }
    function bnMod(b) {
      var c = nbi();
      this.abs().divRemTo(b, null, c);
      if (this.s < 0 && c.compareTo(BigInteger.ZERO) > 0) {
        b.subTo(c, c);
      }
      return c;
    }
    function Classic(a) {
      this.m = a;
    }
    function cConvert(a) {
      if (a.s < 0 || a.compareTo(this.m) >= 0) {
        return a.mod(this.m);
      } else {
        return a;
      }
    }
    function cRevert(a) {
      return a;
    }
    function cReduce(a) {
      a.divRemTo(this.m, null, a);
    }
    function cMulTo(a, c, b) {
      a.multiplyTo(c, b);
      this.reduce(b);
    }
    function cSqrTo(a, b) {
      a.squareTo(b);
      this.reduce(b);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1) {
        return 0;
      }
      var a = this[0];
      if ((a & 1) == 0) {
        return 0;
      }
      var b = a & 3;
      b = b * (2 - (a & 15) * b) & 15;
      b = b * (2 - (a & 255) * b) & 255;
      b = b * (2 - ((a & 65535) * b & 65535)) & 65535;
      b = b * (2 - a * b % this.DV) % this.DV;
      return b > 0 ? this.DV - b : -b;
    }
    function Montgomery(a) {
      this.m = a;
      this.mp = a.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << a.DB - 15) - 1;
      this.mt2 = 2 * a.t;
    }
    function montConvert(a) {
      var b = nbi();
      a.abs().dlShiftTo(this.m.t, b);
      b.divRemTo(this.m, null, b);
      if (a.s < 0 && b.compareTo(BigInteger.ZERO) > 0) {
        this.m.subTo(b, b);
      }
      return b;
    }
    function montRevert(a) {
      var b = nbi();
      a.copyTo(b);
      this.reduce(b);
      return b;
    }
    function montReduce(a) {
      while (a.t <= this.mt2) {
        a[a.t++] = 0;
      }
      for (var c = 0; c < this.m.t; ++c) {
        var b = a[c] & 32767;
        var d = b * this.mpl + ((b * this.mph + (a[c] >> 15) * this.mpl & this.um) << 15) & a.DM;
        b = c + this.m.t;
        a[b] += this.m.am(0, d, a, c, 0, this.m.t);
        while (a[b] >= a.DV) {
          a[b] -= a.DV;
          a[++b]++;
        }
      }
      a.clamp();
      a.drShiftTo(this.m.t, a);
      if (a.compareTo(this.m) >= 0) {
        a.subTo(this.m, a);
      }
    }
    function montSqrTo(a, b) {
      a.squareTo(b);
      this.reduce(b);
    }
    function montMulTo(a, c, b) {
      a.multiplyTo(c, b);
      this.reduce(b);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this[0] & 1 : this.s) == 0;
    }
    function bnpExp(h, j) {
      if (h > 4294967295 || h < 1) {
        return BigInteger.ONE;
      }
      var f = nbi(), a = nbi(), d = j.convert(this), c = nbits(h) - 1;
      d.copyTo(f);
      while (--c >= 0) {
        j.sqrTo(f, a);
        if ((h & 1 << c) > 0) {
          j.mulTo(a, d, f);
        } else {
          var b = f;
          f = a;
          a = b;
        }
      }
      return j.revert(f);
    }
    function bnModPowInt(b, a) {
      var c;
      if (b < 256 || a.isEven()) {
        c = new Classic(a);
      } else {
        c = new Montgomery(a);
      }
      return this.exp(b, c);
    }
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    function bnClone() {
      var a = nbi();
      this.copyTo(a);
      return a;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1) {
          return this[0] - this.DV;
        } else {
          if (this.t == 0) {
            return -1;
          }
        }
      } else {
        if (this.t == 1) {
          return this[0];
        } else {
          if (this.t == 0) {
            return 0;
          }
        }
      }
      return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
    }
    function bnByteValue() {
      return this.t == 0 ? this.s : this[0] << 24 >> 24;
    }
    function bnShortValue() {
      return this.t == 0 ? this.s : this[0] << 16 >> 16;
    }
    function bnpChunkSize(a) {
      return Math.floor(Math.LN2 * this.DB / Math.log(a));
    }
    function bnSigNum() {
      if (this.s < 0) {
        return -1;
      } else {
        if (this.t <= 0 || this.t == 1 && this[0] <= 0) {
          return 0;
        } else {
          return 1;
        }
      }
    }
    function bnpToRadix(c) {
      if (c == null) {
        c = 10;
      }
      if (this.signum() == 0 || c < 2 || c > 36) {
        return "0";
      }
      var f = this.chunkSize(c);
      var e = Math.pow(c, f);
      var i = nbv(e), j = nbi(), h = nbi(), g = "";
      this.divRemTo(i, j, h);
      while (j.signum() > 0) {
        g = (e + h.intValue()).toString(c).substr(1) + g;
        j.divRemTo(i, j, h);
      }
      return h.intValue().toString(c) + g;
    }
    function bnpFromRadix(m, h) {
      this.fromInt(0);
      if (h == null) {
        h = 10;
      }
      var f = this.chunkSize(h);
      var g = Math.pow(h, f), e = false, a = 0, l = 0;
      for (var c = 0; c < m.length; ++c) {
        var k = intAt(m, c);
        if (k < 0) {
          if (m.charAt(c) == "-" && this.signum() == 0) {
            e = true;
          }
          continue;
        }
        l = h * l + k;
        if (++a >= f) {
          this.dMultiply(g);
          this.dAddOffset(l, 0);
          a = 0;
          l = 0;
        }
      }
      if (a > 0) {
        this.dMultiply(Math.pow(h, a));
        this.dAddOffset(l, 0);
      }
      if (e) {
        BigInteger.ZERO.subTo(this, this);
      }
    }
    function bnpFromNumber(f, e, h) {
      if (typeof e == "number") {
        if (f < 2) {
          this.fromInt(1);
        } else {
          this.fromNumber(f, h);
          if (!this.testBit(f - 1)) {
            this.bitwiseTo(BigInteger.ONE.shiftLeft(f - 1), op_or, this);
          }
          if (this.isEven()) {
            this.dAddOffset(1, 0);
          }
          while (!this.isProbablePrime(e)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > f) {
              this.subTo(BigInteger.ONE.shiftLeft(f - 1), this);
            }
          }
        }
      } else {
        var d = new Array(), g = f & 7;
        d.length = (f >> 3) + 1;
        e.nextBytes(d);
        if (g > 0) {
          d[0] &= (1 << g) - 1;
        } else {
          d[0] = 0;
        }
        this.fromString(d, 256);
      }
    }
    function bnToByteArray() {
      var b = this.t, c = new Array();
      c[0] = this.s;
      var e = this.DB - b * this.DB % 8, f, a = 0;
      if (b-- > 0) {
        if (e < this.DB && (f = this[b] >> e) != (this.s & this.DM) >> e) {
          c[a++] = f | this.s << this.DB - e;
        }
        while (b >= 0) {
          if (e < 8) {
            f = (this[b] & (1 << e) - 1) << 8 - e;
            f |= this[--b] >> (e += this.DB - 8);
          } else {
            f = this[b] >> (e -= 8) & 255;
            if (e <= 0) {
              e += this.DB;
              --b;
            }
          }
          if ((f & 128) != 0) {
            f |= -256;
          }
          if (a == 0 && (this.s & 128) != (f & 128)) {
            ++a;
          }
          if (a > 0 || f != this.s) {
            c[a++] = f;
          }
        }
      }
      return c;
    }
    function bnEquals(b) {
      return this.compareTo(b) == 0;
    }
    function bnMin(b) {
      return this.compareTo(b) < 0 ? this : b;
    }
    function bnMax(b) {
      return this.compareTo(b) > 0 ? this : b;
    }
    function bnpBitwiseTo(c, h, e) {
      var d, g, b = Math.min(c.t, this.t);
      for (d = 0; d < b; ++d) {
        e[d] = h(this[d], c[d]);
      }
      if (c.t < this.t) {
        g = c.s & this.DM;
        for (d = b; d < this.t; ++d) {
          e[d] = h(this[d], g);
        }
        e.t = this.t;
      } else {
        g = this.s & this.DM;
        for (d = b; d < c.t; ++d) {
          e[d] = h(g, c[d]);
        }
        e.t = c.t;
      }
      e.s = h(this.s, c.s);
      e.clamp();
    }
    function op_and(a, b) {
      return a & b;
    }
    function bnAnd(b) {
      var c = nbi();
      this.bitwiseTo(b, op_and, c);
      return c;
    }
    function op_or(a, b) {
      return a | b;
    }
    function bnOr(b) {
      var c = nbi();
      this.bitwiseTo(b, op_or, c);
      return c;
    }
    function op_xor(a, b) {
      return a ^ b;
    }
    function bnXor(b) {
      var c = nbi();
      this.bitwiseTo(b, op_xor, c);
      return c;
    }
    function op_andnot(a, b) {
      return a & ~b;
    }
    function bnAndNot(b) {
      var c = nbi();
      this.bitwiseTo(b, op_andnot, c);
      return c;
    }
    function bnNot() {
      var b = nbi();
      for (var a = 0; a < this.t; ++a) {
        b[a] = this.DM & ~this[a];
      }
      b.t = this.t;
      b.s = ~this.s;
      return b;
    }
    function bnShiftLeft(b) {
      var a = nbi();
      if (b < 0) {
        this.rShiftTo(-b, a);
      } else {
        this.lShiftTo(b, a);
      }
      return a;
    }
    function bnShiftRight(b) {
      var a = nbi();
      if (b < 0) {
        this.lShiftTo(-b, a);
      } else {
        this.rShiftTo(b, a);
      }
      return a;
    }
    function lbit(a) {
      if (a == 0) {
        return -1;
      }
      var b = 0;
      if ((a & 65535) == 0) {
        a >>= 16;
        b += 16;
      }
      if ((a & 255) == 0) {
        a >>= 8;
        b += 8;
      }
      if ((a & 15) == 0) {
        a >>= 4;
        b += 4;
      }
      if ((a & 3) == 0) {
        a >>= 2;
        b += 2;
      }
      if ((a & 1) == 0) {
        ++b;
      }
      return b;
    }
    function bnGetLowestSetBit() {
      for (var a = 0; a < this.t; ++a) {
        if (this[a] != 0) {
          return a * this.DB + lbit(this[a]);
        }
      }
      if (this.s < 0) {
        return this.t * this.DB;
      }
      return -1;
    }
    function cbit(a) {
      var b = 0;
      while (a != 0) {
        a &= a - 1;
        ++b;
      }
      return b;
    }
    function bnBitCount() {
      var c = 0, a = this.s & this.DM;
      for (var b = 0; b < this.t; ++b) {
        c += cbit(this[b] ^ a);
      }
      return c;
    }
    function bnTestBit(b) {
      var a = Math.floor(b / this.DB);
      if (a >= this.t) {
        return this.s != 0;
      }
      return (this[a] & 1 << b % this.DB) != 0;
    }
    function bnpChangeBit(c, b) {
      var a = BigInteger.ONE.shiftLeft(c);
      this.bitwiseTo(a, b, a);
      return a;
    }
    function bnSetBit(a) {
      return this.changeBit(a, op_or);
    }
    function bnClearBit(a) {
      return this.changeBit(a, op_andnot);
    }
    function bnFlipBit(a) {
      return this.changeBit(a, op_xor);
    }
    function bnpAddTo(d, f) {
      var e = 0, g = 0, b = Math.min(d.t, this.t);
      while (e < b) {
        g += this[e] + d[e];
        f[e++] = g & this.DM;
        g >>= this.DB;
      }
      if (d.t < this.t) {
        g += d.s;
        while (e < this.t) {
          g += this[e];
          f[e++] = g & this.DM;
          g >>= this.DB;
        }
        g += this.s;
      } else {
        g += this.s;
        while (e < d.t) {
          g += d[e];
          f[e++] = g & this.DM;
          g >>= this.DB;
        }
        g += d.s;
      }
      f.s = g < 0 ? -1 : 0;
      if (g > 0) {
        f[e++] = g;
      } else {
        if (g < -1) {
          f[e++] = this.DV + g;
        }
      }
      f.t = e;
      f.clamp();
    }
    function bnAdd(b) {
      var c = nbi();
      this.addTo(b, c);
      return c;
    }
    function bnSubtract(b) {
      var c = nbi();
      this.subTo(b, c);
      return c;
    }
    function bnMultiply(b) {
      var c = nbi();
      this.multiplyTo(b, c);
      return c;
    }
    function bnSquare() {
      var a = nbi();
      this.squareTo(a);
      return a;
    }
    function bnDivide(b) {
      var c = nbi();
      this.divRemTo(b, c, null);
      return c;
    }
    function bnRemainder(b) {
      var c = nbi();
      this.divRemTo(b, null, c);
      return c;
    }
    function bnDivideAndRemainder(b) {
      var d = nbi(), c = nbi();
      this.divRemTo(b, d, c);
      return new Array(d, c);
    }
    function bnpDMultiply(a) {
      this[this.t] = this.am(0, a - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(b, a) {
      if (b == 0) {
        return;
      }
      while (this.t <= a) {
        this[this.t++] = 0;
      }
      this[a] += b;
      while (this[a] >= this.DV) {
        this[a] -= this.DV;
        if (++a >= this.t) {
          this[this.t++] = 0;
        }
        ++this[a];
      }
    }
    function NullExp() {
    }
    function nNop(a) {
      return a;
    }
    function nMulTo(a, c, b) {
      a.multiplyTo(c, b);
    }
    function nSqrTo(a, b) {
      a.squareTo(b);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(a) {
      return this.exp(a, new NullExp());
    }
    function bnpMultiplyLowerTo(b, f, e) {
      var d = Math.min(this.t + b.t, f);
      e.s = 0;
      e.t = d;
      while (d > 0) {
        e[--d] = 0;
      }
      var c;
      for (c = e.t - this.t; d < c; ++d) {
        e[d + this.t] = this.am(0, b[d], e, d, 0, this.t);
      }
      for (c = Math.min(b.t, f); d < c; ++d) {
        this.am(0, b[d], e, d, 0, f - d);
      }
      e.clamp();
    }
    function bnpMultiplyUpperTo(b, e, d) {
      --e;
      var c = d.t = this.t + b.t - e;
      d.s = 0;
      while (--c >= 0) {
        d[c] = 0;
      }
      for (c = Math.max(e - this.t, 0); c < b.t; ++c) {
        d[this.t + c - e] = this.am(e - c, b[c], d, 0, 0, this.t + c - e);
      }
      d.clamp();
      d.drShiftTo(1, d);
    }
    function Barrett(a) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * a.t, this.r2);
      this.mu = this.r2.divide(a);
      this.m = a;
    }
    function barrettConvert(a) {
      if (a.s < 0 || a.t > 2 * this.m.t) {
        return a.mod(this.m);
      } else {
        if (a.compareTo(this.m) < 0) {
          return a;
        } else {
          var b = nbi();
          a.copyTo(b);
          this.reduce(b);
          return b;
        }
      }
    }
    function barrettRevert(a) {
      return a;
    }
    function barrettReduce(a) {
      a.drShiftTo(this.m.t - 1, this.r2);
      if (a.t > this.m.t + 1) {
        a.t = this.m.t + 1;
        a.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (a.compareTo(this.r2) < 0) {
        a.dAddOffset(1, this.m.t + 1);
      }
      a.subTo(this.r2, a);
      while (a.compareTo(this.m) >= 0) {
        a.subTo(this.m, a);
      }
    }
    function barrettSqrTo(a, b) {
      a.squareTo(b);
      this.reduce(b);
    }
    function barrettMulTo(a, c, b) {
      a.multiplyTo(c, b);
      this.reduce(b);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(q, f) {
      var o = q.bitLength(), h, b = nbv(1), v;
      if (o <= 0) {
        return b;
      } else {
        if (o < 18) {
          h = 1;
        } else {
          if (o < 48) {
            h = 3;
          } else {
            if (o < 144) {
              h = 4;
            } else {
              if (o < 768) {
                h = 5;
              } else {
                h = 6;
              }
            }
          }
        }
      }
      if (o < 8) {
        v = new Classic(f);
      } else {
        if (f.isEven()) {
          v = new Barrett(f);
        } else {
          v = new Montgomery(f);
        }
      }
      var p = new Array(), d = 3, s = h - 1, a = (1 << h) - 1;
      p[1] = v.convert(this);
      if (h > 1) {
        var A = nbi();
        v.sqrTo(p[1], A);
        while (d <= a) {
          p[d] = nbi();
          v.mulTo(A, p[d - 2], p[d]);
          d += 2;
        }
      }
      var l = q.t - 1, x, u = true, c = nbi(), y;
      o = nbits(q[l]) - 1;
      while (l >= 0) {
        if (o >= s) {
          x = q[l] >> o - s & a;
        } else {
          x = (q[l] & (1 << o + 1) - 1) << s - o;
          if (l > 0) {
            x |= q[l - 1] >> this.DB + o - s;
          }
        }
        d = h;
        while ((x & 1) == 0) {
          x >>= 1;
          --d;
        }
        if ((o -= d) < 0) {
          o += this.DB;
          --l;
        }
        if (u) {
          p[x].copyTo(b);
          u = false;
        } else {
          while (d > 1) {
            v.sqrTo(b, c);
            v.sqrTo(c, b);
            d -= 2;
          }
          if (d > 0) {
            v.sqrTo(b, c);
          } else {
            y = b;
            b = c;
            c = y;
          }
          v.mulTo(c, p[x], b);
        }
        while (l >= 0 && (q[l] & 1 << o) == 0) {
          v.sqrTo(b, c);
          y = b;
          b = c;
          c = y;
          if (--o < 0) {
            o = this.DB - 1;
            --l;
          }
        }
      }
      return v.revert(b);
    }
    function bnGCD(c) {
      var b = this.s < 0 ? this.negate() : this.clone();
      var h = c.s < 0 ? c.negate() : c.clone();
      if (b.compareTo(h) < 0) {
        var e = b;
        b = h;
        h = e;
      }
      var d = b.getLowestSetBit(), f = h.getLowestSetBit();
      if (f < 0) {
        return b;
      }
      if (d < f) {
        f = d;
      }
      if (f > 0) {
        b.rShiftTo(f, b);
        h.rShiftTo(f, h);
      }
      while (b.signum() > 0) {
        if ((d = b.getLowestSetBit()) > 0) {
          b.rShiftTo(d, b);
        }
        if ((d = h.getLowestSetBit()) > 0) {
          h.rShiftTo(d, h);
        }
        if (b.compareTo(h) >= 0) {
          b.subTo(h, b);
          b.rShiftTo(1, b);
        } else {
          h.subTo(b, h);
          h.rShiftTo(1, h);
        }
      }
      if (f > 0) {
        h.lShiftTo(f, h);
      }
      return h;
    }
    function bnpModInt(e) {
      if (e <= 0) {
        return 0;
      }
      var c = this.DV % e, b = this.s < 0 ? e - 1 : 0;
      if (this.t > 0) {
        if (c == 0) {
          b = this[0] % e;
        } else {
          for (var a = this.t - 1; a >= 0; --a) {
            b = (c * b + this[a]) % e;
          }
        }
      }
      return b;
    }
    function bnModInverse(f) {
      var j = f.isEven();
      if (this.isEven() && j || f.signum() == 0) {
        return BigInteger.ZERO;
      }
      var i = f.clone(), h = this.clone();
      var g = nbv(1), e = nbv(0), l = nbv(0), k = nbv(1);
      while (i.signum() != 0) {
        while (i.isEven()) {
          i.rShiftTo(1, i);
          if (j) {
            if (!g.isEven() || !e.isEven()) {
              g.addTo(this, g);
              e.subTo(f, e);
            }
            g.rShiftTo(1, g);
          } else {
            if (!e.isEven()) {
              e.subTo(f, e);
            }
          }
          e.rShiftTo(1, e);
        }
        while (h.isEven()) {
          h.rShiftTo(1, h);
          if (j) {
            if (!l.isEven() || !k.isEven()) {
              l.addTo(this, l);
              k.subTo(f, k);
            }
            l.rShiftTo(1, l);
          } else {
            if (!k.isEven()) {
              k.subTo(f, k);
            }
          }
          k.rShiftTo(1, k);
        }
        if (i.compareTo(h) >= 0) {
          i.subTo(h, i);
          if (j) {
            g.subTo(l, g);
          }
          e.subTo(k, e);
        } else {
          h.subTo(i, h);
          if (j) {
            l.subTo(g, l);
          }
          k.subTo(e, k);
        }
      }
      if (h.compareTo(BigInteger.ONE) != 0) {
        return BigInteger.ZERO;
      }
      if (k.compareTo(f) >= 0) {
        return k.subtract(f);
      }
      if (k.signum() < 0) {
        k.addTo(f, k);
      } else {
        return k;
      }
      if (k.signum() < 0) {
        return k.add(f);
      } else {
        return k;
      }
    }
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(e) {
      var d, b = this.abs();
      if (b.t == 1 && b[0] <= lowprimes[lowprimes.length - 1]) {
        for (d = 0; d < lowprimes.length; ++d) {
          if (b[0] == lowprimes[d]) {
            return true;
          }
        }
        return false;
      }
      if (b.isEven()) {
        return false;
      }
      d = 1;
      while (d < lowprimes.length) {
        var a = lowprimes[d], c = d + 1;
        while (c < lowprimes.length && a < lplim) {
          a *= lowprimes[c++];
        }
        a = b.modInt(a);
        while (d < c) {
          if (a % lowprimes[d++] == 0) {
            return false;
          }
        }
      }
      return b.millerRabin(e);
    }
    function bnpMillerRabin(f) {
      var g = this.subtract(BigInteger.ONE);
      var c = g.getLowestSetBit();
      if (c <= 0) {
        return false;
      }
      var h = g.shiftRight(c);
      f = f + 1 >> 1;
      if (f > lowprimes.length) {
        f = lowprimes.length;
      }
      var b = nbi();
      for (var e = 0; e < f; ++e) {
        b.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
        var l = b.modPow(h, this);
        if (l.compareTo(BigInteger.ONE) != 0 && l.compareTo(g) != 0) {
          var d = 1;
          while (d++ < c && l.compareTo(g) != 0) {
            l = l.modPowInt(2, this);
            if (l.compareTo(BigInteger.ONE) == 0) {
              return false;
            }
          }
          if (l.compareTo(g) != 0) {
            return false;
          }
        }
      }
      return true;
    }
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
    BigInteger.prototype.square = bnSquare;
    function Arcfour() {
      this.i = 0;
      this.j = 0;
      this.S = new Array();
    }
    function ARC4init(d) {
      var c, a, b;
      for (c = 0; c < 256; ++c) {
        this.S[c] = c;
      }
      a = 0;
      for (c = 0; c < 256; ++c) {
        a = a + this.S[c] + d[c % d.length] & 255;
        b = this.S[c];
        this.S[c] = this.S[a];
        this.S[a] = b;
      }
      this.i = 0;
      this.j = 0;
    }
    function ARC4next() {
      var a;
      this.i = this.i + 1 & 255;
      this.j = this.j + this.S[this.i] & 255;
      a = this.S[this.i];
      this.S[this.i] = this.S[this.j];
      this.S[this.j] = a;
      return this.S[a + this.S[this.i] & 255];
    }
    Arcfour.prototype.init = ARC4init;
    Arcfour.prototype.next = ARC4next;
    function prng_newstate() {
      return new Arcfour();
    }
    var rng_psize = 256;
    var rng_state;
    var rng_pool;
    var rng_pptr;
    function rng_seed_int(a) {
      rng_pool[rng_pptr++] ^= a & 255;
      rng_pool[rng_pptr++] ^= a >> 8 & 255;
      rng_pool[rng_pptr++] ^= a >> 16 & 255;
      rng_pool[rng_pptr++] ^= a >> 24 & 255;
      if (rng_pptr >= rng_psize) {
        rng_pptr -= rng_psize;
      }
    }
    function rng_seed_time() {
      rng_seed_int(new Date().getTime());
    }
    if (rng_pool == null) {
      rng_pool = new Array();
      rng_pptr = 0;
      if (window2 !== void 0 && (window2.crypto !== void 0 || window2.msCrypto !== void 0)) {
        crypto = window2.crypto || window2.msCrypto;
        if (crypto.getRandomValues) {
          ua = new Uint8Array(32);
          crypto.getRandomValues(ua);
          for (t = 0; t < 32; ++t) {
            rng_pool[rng_pptr++] = ua[t];
          }
        } else {
          if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
            z = window2.crypto.random(32);
            for (t = 0; t < z.length; ++t) {
              rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
            }
          }
        }
      }
      while (rng_pptr < rng_psize) {
        t = Math.floor(65536 * Math.random());
        rng_pool[rng_pptr++] = t >>> 8;
        rng_pool[rng_pptr++] = t & 255;
      }
      rng_pptr = 0;
      rng_seed_time();
    }
    var t;
    var crypto;
    var ua;
    var z;
    function rng_get_byte() {
      if (rng_state == null) {
        rng_seed_time();
        rng_state = prng_newstate();
        rng_state.init(rng_pool);
        for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) {
          rng_pool[rng_pptr] = 0;
        }
        rng_pptr = 0;
      }
      return rng_state.next();
    }
    function rng_get_bytes(b) {
      var a;
      for (a = 0; a < b.length; ++a) {
        b[a] = rng_get_byte();
      }
    }
    function SecureRandom() {
    }
    SecureRandom.prototype.nextBytes = rng_get_bytes;
    function parseBigInt(b, a) {
      return new BigInteger(b, a);
    }
    function pkcs1pad2(e, h) {
      if (h < e.length + 11) {
        throw "Message too long for RSA";
        return null;
      }
      var g = new Array();
      var d = e.length - 1;
      while (d >= 0 && h > 0) {
        var f = e.charCodeAt(d--);
        if (f < 128) {
          g[--h] = f;
        } else {
          if (f > 127 && f < 2048) {
            g[--h] = f & 63 | 128;
            g[--h] = f >> 6 | 192;
          } else {
            g[--h] = f & 63 | 128;
            g[--h] = f >> 6 & 63 | 128;
            g[--h] = f >> 12 | 224;
          }
        }
      }
      g[--h] = 0;
      var b = new SecureRandom();
      var a = new Array();
      while (h > 2) {
        a[0] = 0;
        while (a[0] == 0) {
          b.nextBytes(a);
        }
        g[--h] = a[0];
      }
      g[--h] = 2;
      g[--h] = 0;
      return new BigInteger(g);
    }
    function oaep_mgf1_arr(c, a, e) {
      var b = "", d = 0;
      while (b.length < a) {
        b += e(String.fromCharCode.apply(String, c.concat([(d & 4278190080) >> 24, (d & 16711680) >> 16, (d & 65280) >> 8, d & 255])));
        d += 1;
      }
      return b;
    }
    function oaep_pad(q, a, f, l) {
      var c = KJUR.crypto.MessageDigest;
      var o = KJUR.crypto.Util;
      var b = null;
      if (!f) {
        f = "sha1";
      }
      if (typeof f === "string") {
        b = c.getCanonicalAlgName(f);
        l = c.getHashLength(b);
        f = function(i) {
          return hextorstr(o.hashHex(rstrtohex(i), b));
        };
      }
      if (q.length + 2 * l + 2 > a) {
        throw "Message too long for RSA";
      }
      var k = "", e;
      for (e = 0; e < a - q.length - 2 * l - 2; e += 1) {
        k += "\0";
      }
      var h = f("") + k + "" + q;
      var g = new Array(l);
      new SecureRandom().nextBytes(g);
      var j = oaep_mgf1_arr(g, h.length, f);
      var p = [];
      for (e = 0; e < h.length; e += 1) {
        p[e] = h.charCodeAt(e) ^ j.charCodeAt(e);
      }
      var m = oaep_mgf1_arr(p, g.length, f);
      var d = [0];
      for (e = 0; e < g.length; e += 1) {
        d[e + 1] = g[e] ^ m.charCodeAt(e);
      }
      return new BigInteger(d.concat(p));
    }
    function RSAKey() {
      this.n = null;
      this.e = 0;
      this.d = null;
      this.p = null;
      this.q = null;
      this.dmp1 = null;
      this.dmq1 = null;
      this.coeff = null;
    }
    function RSASetPublic(b, a) {
      this.isPublic = true;
      this.isPrivate = false;
      if (typeof b !== "string") {
        this.n = b;
        this.e = a;
      } else {
        if (b != null && a != null && b.length > 0 && a.length > 0) {
          this.n = parseBigInt(b, 16);
          this.e = parseInt(a, 16);
        } else {
          throw "Invalid RSA public key";
        }
      }
    }
    function RSADoPublic(a) {
      return a.modPowInt(this.e, this.n);
    }
    function RSAEncrypt(d) {
      var a = pkcs1pad2(d, this.n.bitLength() + 7 >> 3);
      if (a == null) {
        return null;
      }
      var e = this.doPublic(a);
      if (e == null) {
        return null;
      }
      var b = e.toString(16);
      if ((b.length & 1) == 0) {
        return b;
      } else {
        return "0" + b;
      }
    }
    function RSAEncryptOAEP(f, e, b) {
      var a = oaep_pad(f, this.n.bitLength() + 7 >> 3, e, b);
      if (a == null) {
        return null;
      }
      var g = this.doPublic(a);
      if (g == null) {
        return null;
      }
      var d = g.toString(16);
      if ((d.length & 1) == 0) {
        return d;
      } else {
        return "0" + d;
      }
    }
    RSAKey.prototype.doPublic = RSADoPublic;
    RSAKey.prototype.setPublic = RSASetPublic;
    RSAKey.prototype.encrypt = RSAEncrypt;
    RSAKey.prototype.encryptOAEP = RSAEncryptOAEP;
    RSAKey.prototype.type = "RSA";
    function pkcs1unpad2(g, j) {
      var a = g.toByteArray();
      var f = 0;
      while (f < a.length && a[f] == 0) {
        ++f;
      }
      if (a.length - f != j - 1 || a[f] != 2) {
        return null;
      }
      ++f;
      while (a[f] != 0) {
        if (++f >= a.length) {
          return null;
        }
      }
      var e = "";
      while (++f < a.length) {
        var h = a[f] & 255;
        if (h < 128) {
          e += String.fromCharCode(h);
        } else {
          if (h > 191 && h < 224) {
            e += String.fromCharCode((h & 31) << 6 | a[f + 1] & 63);
            ++f;
          } else {
            e += String.fromCharCode((h & 15) << 12 | (a[f + 1] & 63) << 6 | a[f + 2] & 63);
            f += 2;
          }
        }
      }
      return e;
    }
    function oaep_mgf1_str(c, a, e) {
      var b = "", d = 0;
      while (b.length < a) {
        b += e(c + String.fromCharCode.apply(String, [(d & 4278190080) >> 24, (d & 16711680) >> 16, (d & 65280) >> 8, d & 255]));
        d += 1;
      }
      return b;
    }
    function oaep_unpad(o, b, g, p) {
      var e = KJUR.crypto.MessageDigest;
      var r = KJUR.crypto.Util;
      var c = null;
      if (!g) {
        g = "sha1";
      }
      if (typeof g === "string") {
        c = e.getCanonicalAlgName(g);
        p = e.getHashLength(c);
        g = function(d) {
          return hextorstr(r.hashHex(rstrtohex(d), c));
        };
      }
      o = o.toByteArray();
      var h;
      for (h = 0; h < o.length; h += 1) {
        o[h] &= 255;
      }
      while (o.length < b) {
        o.unshift(0);
      }
      o = String.fromCharCode.apply(String, o);
      if (o.length < 2 * p + 2) {
        throw "Cipher too short";
      }
      var f = o.substr(1, p);
      var s = o.substr(p + 1);
      var q = oaep_mgf1_str(s, p, g);
      var k = [], h;
      for (h = 0; h < f.length; h += 1) {
        k[h] = f.charCodeAt(h) ^ q.charCodeAt(h);
      }
      var l = oaep_mgf1_str(String.fromCharCode.apply(String, k), o.length - p, g);
      var j = [];
      for (h = 0; h < s.length; h += 1) {
        j[h] = s.charCodeAt(h) ^ l.charCodeAt(h);
      }
      j = String.fromCharCode.apply(String, j);
      if (j.substr(0, p) !== g("")) {
        throw "Hash mismatch";
      }
      j = j.substr(p);
      var a = j.indexOf("");
      var m = a != -1 ? j.substr(0, a).lastIndexOf("\0") : -1;
      if (m + 1 != a) {
        throw "Malformed data";
      }
      return j.substr(a + 1);
    }
    function RSASetPrivate(c, a, b) {
      this.isPrivate = true;
      if (typeof c !== "string") {
        this.n = c;
        this.e = a;
        this.d = b;
      } else {
        if (c != null && a != null && c.length > 0 && a.length > 0) {
          this.n = parseBigInt(c, 16);
          this.e = parseInt(a, 16);
          this.d = parseBigInt(b, 16);
        } else {
          throw "Invalid RSA private key";
        }
      }
    }
    function RSASetPrivateEx(g, d, e, c, b, a, h, f) {
      this.isPrivate = true;
      this.isPublic = false;
      if (g == null) {
        throw "RSASetPrivateEx N == null";
      }
      if (d == null) {
        throw "RSASetPrivateEx E == null";
      }
      if (g.length == 0) {
        throw "RSASetPrivateEx N.length == 0";
      }
      if (d.length == 0) {
        throw "RSASetPrivateEx E.length == 0";
      }
      if (g != null && d != null && g.length > 0 && d.length > 0) {
        this.n = parseBigInt(g, 16);
        this.e = parseInt(d, 16);
        this.d = parseBigInt(e, 16);
        this.p = parseBigInt(c, 16);
        this.q = parseBigInt(b, 16);
        this.dmp1 = parseBigInt(a, 16);
        this.dmq1 = parseBigInt(h, 16);
        this.coeff = parseBigInt(f, 16);
      } else {
        throw "Invalid RSA private key in RSASetPrivateEx";
      }
    }
    function RSAGenerate(b, i) {
      var a = new SecureRandom();
      var f = b >> 1;
      this.e = parseInt(i, 16);
      var c = new BigInteger(i, 16);
      for (; ; ) {
        for (; ; ) {
          this.p = new BigInteger(b - f, 1, a);
          if (this.p.subtract(BigInteger.ONE).gcd(c).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) {
            break;
          }
        }
        for (; ; ) {
          this.q = new BigInteger(f, 1, a);
          if (this.q.subtract(BigInteger.ONE).gcd(c).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) {
            break;
          }
        }
        if (this.p.compareTo(this.q) <= 0) {
          var h = this.p;
          this.p = this.q;
          this.q = h;
        }
        var g = this.p.subtract(BigInteger.ONE);
        var d = this.q.subtract(BigInteger.ONE);
        var e = g.multiply(d);
        if (e.gcd(c).compareTo(BigInteger.ONE) == 0) {
          this.n = this.p.multiply(this.q);
          if (this.n.bitLength() == b) {
            this.d = c.modInverse(e);
            this.dmp1 = this.d.mod(g);
            this.dmq1 = this.d.mod(d);
            this.coeff = this.q.modInverse(this.p);
            break;
          }
        }
      }
      this.isPrivate = true;
    }
    function RSADoPrivate(a) {
      if (this.p == null || this.q == null) {
        return a.modPow(this.d, this.n);
      }
      var c = a.mod(this.p).modPow(this.dmp1, this.p);
      var b = a.mod(this.q).modPow(this.dmq1, this.q);
      while (c.compareTo(b) < 0) {
        c = c.add(this.p);
      }
      return c.subtract(b).multiply(this.coeff).mod(this.p).multiply(this.q).add(b);
    }
    function RSADecrypt(b) {
      if (b.length != Math.ceil(this.n.bitLength() / 4)) {
        throw new Error("wrong ctext length");
      }
      var d = parseBigInt(b, 16);
      var a = this.doPrivate(d);
      if (a == null) {
        return null;
      }
      return pkcs1unpad2(a, this.n.bitLength() + 7 >> 3);
    }
    function RSADecryptOAEP(e, d, b) {
      if (e.length != Math.ceil(this.n.bitLength() / 4)) {
        throw new Error("wrong ctext length");
      }
      var f = parseBigInt(e, 16);
      var a = this.doPrivate(f);
      if (a == null) {
        return null;
      }
      return oaep_unpad(a, this.n.bitLength() + 7 >> 3, d, b);
    }
    RSAKey.prototype.doPrivate = RSADoPrivate;
    RSAKey.prototype.setPrivate = RSASetPrivate;
    RSAKey.prototype.setPrivateEx = RSASetPrivateEx;
    RSAKey.prototype.generate = RSAGenerate;
    RSAKey.prototype.decrypt = RSADecrypt;
    RSAKey.prototype.decryptOAEP = RSADecryptOAEP;
    function ECFieldElementFp(b, a) {
      this.x = a;
      this.q = b;
    }
    function feFpEquals(a) {
      if (a == this) {
        return true;
      }
      return this.q.equals(a.q) && this.x.equals(a.x);
    }
    function feFpToBigInteger() {
      return this.x;
    }
    function feFpNegate() {
      return new ECFieldElementFp(this.q, this.x.negate().mod(this.q));
    }
    function feFpAdd(a) {
      return new ECFieldElementFp(this.q, this.x.add(a.toBigInteger()).mod(this.q));
    }
    function feFpSubtract(a) {
      return new ECFieldElementFp(this.q, this.x.subtract(a.toBigInteger()).mod(this.q));
    }
    function feFpMultiply(a) {
      return new ECFieldElementFp(this.q, this.x.multiply(a.toBigInteger()).mod(this.q));
    }
    function feFpSquare() {
      return new ECFieldElementFp(this.q, this.x.square().mod(this.q));
    }
    function feFpDivide(a) {
      return new ECFieldElementFp(this.q, this.x.multiply(a.toBigInteger().modInverse(this.q)).mod(this.q));
    }
    ECFieldElementFp.prototype.equals = feFpEquals;
    ECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;
    ECFieldElementFp.prototype.negate = feFpNegate;
    ECFieldElementFp.prototype.add = feFpAdd;
    ECFieldElementFp.prototype.subtract = feFpSubtract;
    ECFieldElementFp.prototype.multiply = feFpMultiply;
    ECFieldElementFp.prototype.square = feFpSquare;
    ECFieldElementFp.prototype.divide = feFpDivide;
    function ECPointFp(c, a, d, b) {
      this.curve = c;
      this.x = a;
      this.y = d;
      if (b == null) {
        this.z = BigInteger.ONE;
      } else {
        this.z = b;
      }
      this.zinv = null;
    }
    function pointFpGetX() {
      if (this.zinv == null) {
        this.zinv = this.z.modInverse(this.curve.q);
      }
      return this.curve.fromBigInteger(this.x.toBigInteger().multiply(this.zinv).mod(this.curve.q));
    }
    function pointFpGetY() {
      if (this.zinv == null) {
        this.zinv = this.z.modInverse(this.curve.q);
      }
      return this.curve.fromBigInteger(this.y.toBigInteger().multiply(this.zinv).mod(this.curve.q));
    }
    function pointFpEquals(a) {
      if (a == this) {
        return true;
      }
      if (this.isInfinity()) {
        return a.isInfinity();
      }
      if (a.isInfinity()) {
        return this.isInfinity();
      }
      var c, b;
      c = a.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(a.z)).mod(this.curve.q);
      if (!c.equals(BigInteger.ZERO)) {
        return false;
      }
      b = a.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(a.z)).mod(this.curve.q);
      return b.equals(BigInteger.ZERO);
    }
    function pointFpIsInfinity() {
      if (this.x == null && this.y == null) {
        return true;
      }
      return this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO);
    }
    function pointFpNegate() {
      return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);
    }
    function pointFpAdd(l) {
      if (this.isInfinity()) {
        return l;
      }
      if (l.isInfinity()) {
        return this;
      }
      var p = l.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(l.z)).mod(this.curve.q);
      var o = l.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(l.z)).mod(this.curve.q);
      if (BigInteger.ZERO.equals(o)) {
        if (BigInteger.ZERO.equals(p)) {
          return this.twice();
        }
        return this.curve.getInfinity();
      }
      var j = new BigInteger("3");
      var e = this.x.toBigInteger();
      var n = this.y.toBigInteger();
      var c = l.x.toBigInteger();
      var k = l.y.toBigInteger();
      var m = o.square();
      var i = m.multiply(o);
      var d = e.multiply(m);
      var g = p.square().multiply(this.z);
      var a = g.subtract(d.shiftLeft(1)).multiply(l.z).subtract(i).multiply(o).mod(this.curve.q);
      var h = d.multiply(j).multiply(p).subtract(n.multiply(i)).subtract(g.multiply(p)).multiply(l.z).add(p.multiply(i)).mod(this.curve.q);
      var f = i.multiply(this.z).multiply(l.z).mod(this.curve.q);
      return new ECPointFp(this.curve, this.curve.fromBigInteger(a), this.curve.fromBigInteger(h), f);
    }
    function pointFpTwice() {
      if (this.isInfinity()) {
        return this;
      }
      if (this.y.toBigInteger().signum() == 0) {
        return this.curve.getInfinity();
      }
      var g = new BigInteger("3");
      var c = this.x.toBigInteger();
      var h = this.y.toBigInteger();
      var e = h.multiply(this.z);
      var j = e.multiply(h).mod(this.curve.q);
      var i = this.curve.a.toBigInteger();
      var k = c.square().multiply(g);
      if (!BigInteger.ZERO.equals(i)) {
        k = k.add(this.z.square().multiply(i));
      }
      k = k.mod(this.curve.q);
      var b = k.square().subtract(c.shiftLeft(3).multiply(j)).shiftLeft(1).multiply(e).mod(this.curve.q);
      var f = k.multiply(g).multiply(c).subtract(j.shiftLeft(1)).shiftLeft(2).multiply(j).subtract(k.square().multiply(k)).mod(this.curve.q);
      var d = e.square().multiply(e).shiftLeft(3).mod(this.curve.q);
      return new ECPointFp(this.curve, this.curve.fromBigInteger(b), this.curve.fromBigInteger(f), d);
    }
    function pointFpMultiply(d) {
      if (this.isInfinity()) {
        return this;
      }
      if (d.signum() == 0) {
        return this.curve.getInfinity();
      }
      var m = d;
      var l = m.multiply(new BigInteger("3"));
      var b = this.negate();
      var j = this;
      var q = this.curve.q.subtract(d);
      var o = q.multiply(new BigInteger("3"));
      var c = new ECPointFp(this.curve, this.x, this.y);
      var a = c.negate();
      var g;
      for (g = l.bitLength() - 2; g > 0; --g) {
        j = j.twice();
        var n = l.testBit(g);
        var f = m.testBit(g);
        if (n != f) {
          j = j.add(n ? this : b);
        }
      }
      for (g = o.bitLength() - 2; g > 0; --g) {
        c = c.twice();
        var p = o.testBit(g);
        var r = q.testBit(g);
        if (p != r) {
          c = c.add(p ? c : a);
        }
      }
      return j;
    }
    function pointFpMultiplyTwo(c, a, b) {
      var d;
      if (c.bitLength() > b.bitLength()) {
        d = c.bitLength() - 1;
      } else {
        d = b.bitLength() - 1;
      }
      var f = this.curve.getInfinity();
      var e = this.add(a);
      while (d >= 0) {
        f = f.twice();
        if (c.testBit(d)) {
          if (b.testBit(d)) {
            f = f.add(e);
          } else {
            f = f.add(this);
          }
        } else {
          if (b.testBit(d)) {
            f = f.add(a);
          }
        }
        --d;
      }
      return f;
    }
    ECPointFp.prototype.getX = pointFpGetX;
    ECPointFp.prototype.getY = pointFpGetY;
    ECPointFp.prototype.equals = pointFpEquals;
    ECPointFp.prototype.isInfinity = pointFpIsInfinity;
    ECPointFp.prototype.negate = pointFpNegate;
    ECPointFp.prototype.add = pointFpAdd;
    ECPointFp.prototype.twice = pointFpTwice;
    ECPointFp.prototype.multiply = pointFpMultiply;
    ECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;
    function ECCurveFp(e, d, c) {
      this.q = e;
      this.a = this.fromBigInteger(d);
      this.b = this.fromBigInteger(c);
      this.infinity = new ECPointFp(this, null, null);
    }
    function curveFpGetQ() {
      return this.q;
    }
    function curveFpGetA() {
      return this.a;
    }
    function curveFpGetB() {
      return this.b;
    }
    function curveFpEquals(a) {
      if (a == this) {
        return true;
      }
      return this.q.equals(a.q) && this.a.equals(a.a) && this.b.equals(a.b);
    }
    function curveFpGetInfinity() {
      return this.infinity;
    }
    function curveFpFromBigInteger(a) {
      return new ECFieldElementFp(this.q, a);
    }
    function curveFpDecodePointHex(d) {
      switch (parseInt(d.substr(0, 2), 16)) {
        case 0:
          return this.infinity;
        case 2:
        case 3:
          return null;
        case 4:
        case 6:
        case 7:
          var a = (d.length - 2) / 2;
          var c = d.substr(2, a);
          var b = d.substr(a + 2, a);
          return new ECPointFp(this, this.fromBigInteger(new BigInteger(c, 16)), this.fromBigInteger(new BigInteger(b, 16)));
        default:
          return null;
      }
    }
    ECCurveFp.prototype.getQ = curveFpGetQ;
    ECCurveFp.prototype.getA = curveFpGetA;
    ECCurveFp.prototype.getB = curveFpGetB;
    ECCurveFp.prototype.equals = curveFpEquals;
    ECCurveFp.prototype.getInfinity = curveFpGetInfinity;
    ECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;
    ECCurveFp.prototype.decodePointHex = curveFpDecodePointHex;
    ECFieldElementFp.prototype.getByteLength = function() {
      return Math.floor((this.toBigInteger().bitLength() + 7) / 8);
    };
    ECPointFp.prototype.getEncoded = function(c) {
      var d = function(h, f) {
        var g = h.toByteArrayUnsigned();
        if (f < g.length) {
          g = g.slice(g.length - f);
        } else {
          while (f > g.length) {
            g.unshift(0);
          }
        }
        return g;
      };
      var a = this.getX().toBigInteger();
      var e = this.getY().toBigInteger();
      var b = d(a, 32);
      if (c) {
        if (e.isEven()) {
          b.unshift(2);
        } else {
          b.unshift(3);
        }
      } else {
        b.unshift(4);
        b = b.concat(d(e, 32));
      }
      return b;
    };
    ECPointFp.decodeFrom = function(g, c) {
      var f = c[0];
      var e = c.length - 1;
      var d = c.slice(1, 1 + e / 2);
      var b = c.slice(1 + e / 2, 1 + e);
      d.unshift(0);
      b.unshift(0);
      var a = new BigInteger(d);
      var h = new BigInteger(b);
      return new ECPointFp(g, g.fromBigInteger(a), g.fromBigInteger(h));
    };
    ECPointFp.decodeFromHex = function(g, c) {
      var f = c.substr(0, 2);
      var e = c.length - 2;
      var d = c.substr(2, e / 2);
      var b = c.substr(2 + e / 2, e / 2);
      var a = new BigInteger(d, 16);
      var h = new BigInteger(b, 16);
      return new ECPointFp(g, g.fromBigInteger(a), g.fromBigInteger(h));
    };
    ECPointFp.prototype.add2D = function(c) {
      if (this.isInfinity()) {
        return c;
      }
      if (c.isInfinity()) {
        return this;
      }
      if (this.x.equals(c.x)) {
        if (this.y.equals(c.y)) {
          return this.twice();
        }
        return this.curve.getInfinity();
      }
      var g = c.x.subtract(this.x);
      var e = c.y.subtract(this.y);
      var a = e.divide(g);
      var d = a.square().subtract(this.x).subtract(c.x);
      var f = a.multiply(this.x.subtract(d)).subtract(this.y);
      return new ECPointFp(this.curve, d, f);
    };
    ECPointFp.prototype.twice2D = function() {
      if (this.isInfinity()) {
        return this;
      }
      if (this.y.toBigInteger().signum() == 0) {
        return this.curve.getInfinity();
      }
      var b = this.curve.fromBigInteger(BigInteger.valueOf(2));
      var e = this.curve.fromBigInteger(BigInteger.valueOf(3));
      var a = this.x.square().multiply(e).add(this.curve.a).divide(this.y.multiply(b));
      var c = a.square().subtract(this.x.multiply(b));
      var d = a.multiply(this.x.subtract(c)).subtract(this.y);
      return new ECPointFp(this.curve, c, d);
    };
    ECPointFp.prototype.multiply2D = function(b) {
      if (this.isInfinity()) {
        return this;
      }
      if (b.signum() == 0) {
        return this.curve.getInfinity();
      }
      var g = b;
      var f = g.multiply(new BigInteger("3"));
      var l = this.negate();
      var d = this;
      var c;
      for (c = f.bitLength() - 2; c > 0; --c) {
        d = d.twice();
        var a = f.testBit(c);
        var j = g.testBit(c);
        if (a != j) {
          d = d.add2D(a ? this : l);
        }
      }
      return d;
    };
    ECPointFp.prototype.isOnCurve = function() {
      var d = this.getX().toBigInteger();
      var i = this.getY().toBigInteger();
      var f = this.curve.getA().toBigInteger();
      var c = this.curve.getB().toBigInteger();
      var h = this.curve.getQ();
      var e = i.multiply(i).mod(h);
      var g = d.multiply(d).multiply(d).add(f.multiply(d)).add(c).mod(h);
      return e.equals(g);
    };
    ECPointFp.prototype.toString = function() {
      return "(" + this.getX().toBigInteger().toString() + "," + this.getY().toBigInteger().toString() + ")";
    };
    ECPointFp.prototype.validate = function() {
      var c = this.curve.getQ();
      if (this.isInfinity()) {
        throw new Error("Point is at infinity.");
      }
      var a = this.getX().toBigInteger();
      var b = this.getY().toBigInteger();
      if (a.compareTo(BigInteger.ONE) < 0 || a.compareTo(c.subtract(BigInteger.ONE)) > 0) {
        throw new Error("x coordinate out of bounds");
      }
      if (b.compareTo(BigInteger.ONE) < 0 || b.compareTo(c.subtract(BigInteger.ONE)) > 0) {
        throw new Error("y coordinate out of bounds");
      }
      if (!this.isOnCurve()) {
        throw new Error("Point is not on the curve.");
      }
      if (this.multiply(c).isInfinity()) {
        throw new Error("Point is not a scalar multiple of G.");
      }
      return true;
    };
    var jsonParse = function() {
      var e = "(?:-?\\b(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\b)";
      var j = '(?:[^\\0-\\x08\\x0a-\\x1f"\\\\]|\\\\(?:["/\\\\bfnrt]|u[0-9A-Fa-f]{4}))';
      var i = '(?:"' + j + '*")';
      var d = new RegExp("(?:false|true|null|[\\{\\}\\[\\]]|" + e + "|" + i + ")", "g");
      var k = new RegExp("\\\\(?:([^u])|u(.{4}))", "g");
      var g = { '"': '"', "/": "/", "\\": "\\", b: "\b", f: "\f", n: "\n", r: "\r", t: "	" };
      function h(l, m, n) {
        return m ? g[m] : String.fromCharCode(parseInt(n, 16));
      }
      var c = new String("");
      var a = "\\";
      var f = { "{": Object, "[": Array };
      var b = Object.hasOwnProperty;
      return function(u, q) {
        var p = u.match(d);
        var x;
        var v = p[0];
        var l = false;
        if (v === "{") {
          x = {};
        } else {
          if (v === "[") {
            x = [];
          } else {
            x = [];
            l = true;
          }
        }
        var t2;
        var r = [x];
        for (var o = 1 - l, m = p.length; o < m; ++o) {
          v = p[o];
          var w;
          switch (v.charCodeAt(0)) {
            default:
              w = r[0];
              w[t2 || w.length] = +v;
              t2 = void 0;
              break;
            case 34:
              v = v.substring(1, v.length - 1);
              if (v.indexOf(a) !== -1) {
                v = v.replace(k, h);
              }
              w = r[0];
              if (!t2) {
                if (w instanceof Array) {
                  t2 = w.length;
                } else {
                  t2 = v || c;
                  break;
                }
              }
              w[t2] = v;
              t2 = void 0;
              break;
            case 91:
              w = r[0];
              r.unshift(w[t2 || w.length] = []);
              t2 = void 0;
              break;
            case 93:
              r.shift();
              break;
            case 102:
              w = r[0];
              w[t2 || w.length] = false;
              t2 = void 0;
              break;
            case 110:
              w = r[0];
              w[t2 || w.length] = null;
              t2 = void 0;
              break;
            case 116:
              w = r[0];
              w[t2 || w.length] = true;
              t2 = void 0;
              break;
            case 123:
              w = r[0];
              r.unshift(w[t2 || w.length] = {});
              t2 = void 0;
              break;
            case 125:
              r.shift();
              break;
          }
        }
        if (l) {
          if (r.length !== 1) {
            throw new Error();
          }
          x = x[0];
        } else {
          if (r.length) {
            throw new Error();
          }
        }
        if (q) {
          var s = function(C, B) {
            var D = C[B];
            if (D && typeof D === "object") {
              var n = null;
              for (var z2 in D) {
                if (b.call(D, z2) && D !== C) {
                  var y = s(D, z2);
                  if (y !== void 0) {
                    D[z2] = y;
                  } else {
                    if (!n) {
                      n = [];
                    }
                    n.push(z2);
                  }
                }
              }
              if (n) {
                for (var A = n.length; --A >= 0; ) {
                  delete D[n[A]];
                }
              }
            }
            return q.call(C, B, D);
          };
          x = s({ "": x }, "");
        }
        return x;
      };
    }();
    if (typeof KJUR == "undefined" || !KJUR) {
      KJUR = {};
    }
    if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) {
      KJUR.asn1 = {};
    }
    KJUR.asn1.ASN1Util = new function() {
      this.integerToByteHex = function(a) {
        var b = a.toString(16);
        if (b.length % 2 == 1) {
          b = "0" + b;
        }
        return b;
      };
      this.bigIntToMinTwosComplementsHex = function(j) {
        var f = j.toString(16);
        if (f.substr(0, 1) != "-") {
          if (f.length % 2 == 1) {
            f = "0" + f;
          } else {
            if (!f.match(/^[0-7]/)) {
              f = "00" + f;
            }
          }
        } else {
          var a = f.substr(1);
          var e = a.length;
          if (e % 2 == 1) {
            e += 1;
          } else {
            if (!f.match(/^[0-7]/)) {
              e += 2;
            }
          }
          var g = "";
          for (var d = 0; d < e; d++) {
            g += "f";
          }
          var c = new BigInteger(g, 16);
          var b = c.xor(j).add(BigInteger.ONE);
          f = b.toString(16).replace(/^-/, "");
        }
        return f;
      };
      this.getPEMStringFromHex = function(a, b) {
        return hextopem(a, b);
      };
      this.newObject = function(k) {
        var F = KJUR, o = F.asn1, v = o.ASN1Object, B = o.DERBoolean, e = o.DERInteger, t2 = o.DERBitString, h = o.DEROctetString, x = o.DERNull, y = o.DERObjectIdentifier, m = o.DEREnumerated, g = o.DERUTF8String, f = o.DERNumericString, A = o.DERPrintableString, w = o.DERTeletexString, q = o.DERIA5String, E = o.DERUTCTime, j = o.DERGeneralizedTime, b = o.DERVisibleString, l = o.DERBMPString, n = o.DERSequence, c = o.DERSet, s = o.DERTaggedObject, p = o.ASN1Util.newObject;
        if (k instanceof o.ASN1Object) {
          return k;
        }
        var u = Object.keys(k);
        if (u.length != 1) {
          throw new Error("key of param shall be only one.");
        }
        var H = u[0];
        if (":asn1:bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:visstr:bmpstr:seq:set:tag:".indexOf(":" + H + ":") == -1) {
          throw new Error("undefined key: " + H);
        }
        if (H == "bool") {
          return new B(k[H]);
        }
        if (H == "int") {
          return new e(k[H]);
        }
        if (H == "bitstr") {
          return new t2(k[H]);
        }
        if (H == "octstr") {
          return new h(k[H]);
        }
        if (H == "null") {
          return new x(k[H]);
        }
        if (H == "oid") {
          return new y(k[H]);
        }
        if (H == "enum") {
          return new m(k[H]);
        }
        if (H == "utf8str") {
          return new g(k[H]);
        }
        if (H == "numstr") {
          return new f(k[H]);
        }
        if (H == "prnstr") {
          return new A(k[H]);
        }
        if (H == "telstr") {
          return new w(k[H]);
        }
        if (H == "ia5str") {
          return new q(k[H]);
        }
        if (H == "utctime") {
          return new E(k[H]);
        }
        if (H == "gentime") {
          return new j(k[H]);
        }
        if (H == "visstr") {
          return new b(k[H]);
        }
        if (H == "bmpstr") {
          return new l(k[H]);
        }
        if (H == "asn1") {
          return new v(k[H]);
        }
        if (H == "seq") {
          var d = k[H];
          var G = [];
          for (var z2 = 0; z2 < d.length; z2++) {
            var D = p(d[z2]);
            G.push(D);
          }
          return new n({ array: G });
        }
        if (H == "set") {
          var d = k[H];
          var G = [];
          for (var z2 = 0; z2 < d.length; z2++) {
            var D = p(d[z2]);
            G.push(D);
          }
          return new c({ array: G });
        }
        if (H == "tag") {
          var C = k[H];
          if (Object.prototype.toString.call(C) === "[object Array]" && C.length == 3) {
            var r = p(C[2]);
            return new s({ tag: C[0], explicit: C[1], obj: r });
          } else {
            return new s(C);
          }
        }
      };
      this.jsonToASN1HEX = function(b) {
        var a = this.newObject(b);
        return a.getEncodedHex();
      };
    }();
    KJUR.asn1.ASN1Util.oidHexToInt = function(a) {
      var j = "";
      var k = parseInt(a.substr(0, 2), 16);
      var d = Math.floor(k / 40);
      var c = k % 40;
      var j = d + "." + c;
      var e = "";
      for (var f = 2; f < a.length; f += 2) {
        var g = parseInt(a.substr(f, 2), 16);
        var h = ("00000000" + g.toString(2)).slice(-8);
        e = e + h.substr(1, 7);
        if (h.substr(0, 1) == "0") {
          var b = new BigInteger(e, 2);
          j = j + "." + b.toString(10);
          e = "";
        }
      }
      return j;
    };
    KJUR.asn1.ASN1Util.oidIntToHex = function(f) {
      var e = function(a) {
        var k = a.toString(16);
        if (k.length == 1) {
          k = "0" + k;
        }
        return k;
      };
      var d = function(o) {
        var n = "";
        var k = new BigInteger(o, 10);
        var a = k.toString(2);
        var l = 7 - a.length % 7;
        if (l == 7) {
          l = 0;
        }
        var q = "";
        for (var m = 0; m < l; m++) {
          q += "0";
        }
        a = q + a;
        for (var m = 0; m < a.length - 1; m += 7) {
          var p = a.substr(m, 7);
          if (m != a.length - 7) {
            p = "1" + p;
          }
          n += e(parseInt(p, 2));
        }
        return n;
      };
      if (!f.match(/^[0-9.]+$/)) {
        throw "malformed oid string: " + f;
      }
      var g = "";
      var b = f.split(".");
      var j = parseInt(b[0]) * 40 + parseInt(b[1]);
      g += e(j);
      b.splice(0, 2);
      for (var c = 0; c < b.length; c++) {
        g += d(b[c]);
      }
      return g;
    };
    KJUR.asn1.ASN1Object = function(e) {
      var c = true;
      var b = null;
      var d = "00";
      var f = "00";
      var a = "";
      this.params = null;
      this.getLengthHexFromValue = function() {
        if (typeof this.hV == "undefined" || this.hV == null) {
          throw new Error("this.hV is null or undefined");
        }
        if (this.hV.length % 2 == 1) {
          throw new Error("value hex must be even length: n=" + a.length + ",v=" + this.hV);
        }
        var j = this.hV.length / 2;
        var i = j.toString(16);
        if (i.length % 2 == 1) {
          i = "0" + i;
        }
        if (j < 128) {
          return i;
        } else {
          var h = i.length / 2;
          if (h > 15) {
            throw "ASN.1 length too long to represent by 8x: n = " + j.toString(16);
          }
          var g = 128 + h;
          return g.toString(16) + i;
        }
      };
      this.getEncodedHex = function() {
        if (this.hTLV == null || this.isModified) {
          this.hV = this.getFreshValueHex();
          this.hL = this.getLengthHexFromValue();
          this.hTLV = this.hT + this.hL + this.hV;
          this.isModified = false;
        }
        return this.hTLV;
      };
      this.getValueHex = function() {
        this.getEncodedHex();
        return this.hV;
      };
      this.getFreshValueHex = function() {
        return "";
      };
      this.setByParam = function(g) {
        this.params = g;
      };
      if (e != void 0) {
        if (e.tlv != void 0) {
          this.hTLV = e.tlv;
          this.isModified = false;
        }
      }
    };
    KJUR.asn1.DERAbstractString = function(c) {
      KJUR.asn1.DERAbstractString.superclass.constructor.call(this);
      var b = null;
      var a = null;
      this.getString = function() {
        return this.s;
      };
      this.setString = function(d) {
        this.hTLV = null;
        this.isModified = true;
        this.s = d;
        this.hV = utf8tohex(this.s).toLowerCase();
      };
      this.setStringHex = function(d) {
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = d;
      };
      this.getFreshValueHex = function() {
        return this.hV;
      };
      if (typeof c != "undefined") {
        if (typeof c == "string") {
          this.setString(c);
        } else {
          if (typeof c.str != "undefined") {
            this.setString(c.str);
          } else {
            if (typeof c.hex != "undefined") {
              this.setStringHex(c.hex);
            }
          }
        }
      }
    };
    extendClass(KJUR.asn1.DERAbstractString, KJUR.asn1.ASN1Object);
    KJUR.asn1.DERAbstractTime = function(c) {
      KJUR.asn1.DERAbstractTime.superclass.constructor.call(this);
      var b = null;
      var a = null;
      this.localDateToUTC = function(g) {
        var e = g.getTime() + g.getTimezoneOffset() * 6e4;
        var f = new Date(e);
        return f;
      };
      this.formatDate = function(m, o, e) {
        var g = this.zeroPadding;
        var n = this.localDateToUTC(m);
        var p = String(n.getFullYear());
        if (o == "utc") {
          p = p.substr(2, 2);
        }
        var l = g(String(n.getMonth() + 1), 2);
        var q = g(String(n.getDate()), 2);
        var h = g(String(n.getHours()), 2);
        var i = g(String(n.getMinutes()), 2);
        var j = g(String(n.getSeconds()), 2);
        var r = p + l + q + h + i + j;
        if (e === true) {
          var f = n.getMilliseconds();
          if (f != 0) {
            var k = g(String(f), 3);
            k = k.replace(/[0]+$/, "");
            r = r + "." + k;
          }
        }
        return r + "Z";
      };
      this.zeroPadding = function(e, d) {
        if (e.length >= d) {
          return e;
        }
        return new Array(d - e.length + 1).join("0") + e;
      };
      this.getString = function() {
        return this.s;
      };
      this.setString = function(d) {
        this.hTLV = null;
        this.isModified = true;
        this.s = d;
        this.hV = stohex(d);
      };
      this.setByDateValue = function(h, j, e, d, f, g) {
        var i = new Date(Date.UTC(h, j - 1, e, d, f, g, 0));
        this.setByDate(i);
      };
      this.getFreshValueHex = function() {
        return this.hV;
      };
    };
    extendClass(KJUR.asn1.DERAbstractTime, KJUR.asn1.ASN1Object);
    KJUR.asn1.DERAbstractStructured = function(b) {
      KJUR.asn1.DERAbstractString.superclass.constructor.call(this);
      var a = null;
      this.setByASN1ObjectArray = function(c) {
        this.hTLV = null;
        this.isModified = true;
        this.asn1Array = c;
      };
      this.appendASN1Object = function(c) {
        this.hTLV = null;
        this.isModified = true;
        this.asn1Array.push(c);
      };
      this.asn1Array = new Array();
      if (typeof b != "undefined") {
        if (typeof b.array != "undefined") {
          this.asn1Array = b.array;
        }
      }
    };
    extendClass(KJUR.asn1.DERAbstractStructured, KJUR.asn1.ASN1Object);
    KJUR.asn1.DERBoolean = function(a) {
      KJUR.asn1.DERBoolean.superclass.constructor.call(this);
      this.hT = "01";
      if (a == false) {
        this.hTLV = "010100";
      } else {
        this.hTLV = "0101ff";
      }
    };
    extendClass(KJUR.asn1.DERBoolean, KJUR.asn1.ASN1Object);
    KJUR.asn1.DERInteger = function(a) {
      KJUR.asn1.DERInteger.superclass.constructor.call(this);
      this.hT = "02";
      this.setByBigInteger = function(b) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(b);
      };
      this.setByInteger = function(c) {
        var b = new BigInteger(String(c), 10);
        this.setByBigInteger(b);
      };
      this.setValueHex = function(b) {
        this.hV = b;
      };
      this.getFreshValueHex = function() {
        return this.hV;
      };
      if (typeof a != "undefined") {
        if (typeof a.bigint != "undefined") {
          this.setByBigInteger(a.bigint);
        } else {
          if (typeof a["int"] != "undefined") {
            this.setByInteger(a["int"]);
          } else {
            if (typeof a == "number") {
              this.setByInteger(a);
            } else {
              if (typeof a.hex != "undefined") {
                this.setValueHex(a.hex);
              }
            }
          }
        }
      }
    };
    extendClass(KJUR.asn1.DERInteger, KJUR.asn1.ASN1Object);
    KJUR.asn1.DERBitString = function(b) {
      if (b !== void 0 && typeof b.obj !== "undefined") {
        var a = KJUR.asn1.ASN1Util.newObject(b.obj);
        b.hex = "00" + a.getEncodedHex();
      }
      KJUR.asn1.DERBitString.superclass.constructor.call(this);
      this.hT = "03";
      this.setHexValueIncludingUnusedBits = function(c) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = c;
      };
      this.setUnusedBitsAndHexValue = function(c, e) {
        if (c < 0 || 7 < c) {
          throw "unused bits shall be from 0 to 7: u = " + c;
        }
        var d = "0" + c;
        this.hTLV = null;
        this.isModified = true;
        this.hV = d + e;
      };
      this.setByBinaryString = function(e) {
        e = e.replace(/0+$/, "");
        var f = 8 - e.length % 8;
        if (f == 8) {
          f = 0;
        }
        for (var g = 0; g <= f; g++) {
          e += "0";
        }
        var j = "";
        for (var g = 0; g < e.length - 1; g += 8) {
          var d = e.substr(g, 8);
          var c = parseInt(d, 2).toString(16);
          if (c.length == 1) {
            c = "0" + c;
          }
          j += c;
        }
        this.hTLV = null;
        this.isModified = true;
        this.hV = "0" + f + j;
      };
      this.setByBooleanArray = function(e) {
        var d = "";
        for (var c = 0; c < e.length; c++) {
          if (e[c] == true) {
            d += "1";
          } else {
            d += "0";
          }
        }
        this.setByBinaryString(d);
      };
      this.newFalseArray = function(e) {
        var c = new Array(e);
        for (var d = 0; d < e; d++) {
          c[d] = false;
        }
        return c;
      };
      this.getFreshValueHex = function() {
        return this.hV;
      };
      if (typeof b != "undefined") {
        if (typeof b == "string" && b.toLowerCase().match(/^[0-9a-f]+$/)) {
          this.setHexValueIncludingUnusedBits(b);
        } else {
          if (typeof b.hex != "undefined") {
            this.setHexValueIncludingUnusedBits(b.hex);
          } else {
            if (typeof b.bin != "undefined") {
              this.setByBinaryString(b.bin);
            } else {
              if (typeof b.array != "undefined") {
                this.setByBooleanArray(b.array);
              }
            }
          }
        }
      }
    };
    extendClass(KJUR.asn1.DERBitString, KJUR.asn1.ASN1Object);
    KJUR.asn1.DEROctetString = function(b) {
      if (b !== void 0 && typeof b.obj !== "undefined") {
        var a = KJUR.asn1.ASN1Util.newObject(b.obj);
        b.hex = a.getEncodedHex();
      }
      KJUR.asn1.DEROctetString.superclass.constructor.call(this, b);
      this.hT = "04";
    };
    extendClass(KJUR.asn1.DEROctetString, KJUR.asn1.DERAbstractString);
    KJUR.asn1.DERNull = function() {
      KJUR.asn1.DERNull.superclass.constructor.call(this);
      this.hT = "05";
      this.hTLV = "0500";
    };
    extendClass(KJUR.asn1.DERNull, KJUR.asn1.ASN1Object);
    KJUR.asn1.DERObjectIdentifier = function(a) {
      KJUR.asn1.DERObjectIdentifier.superclass.constructor.call(this);
      this.hT = "06";
      this.setValueHex = function(b) {
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = b;
      };
      this.setValueOidString = function(b) {
        var c = oidtohex(b);
        if (c == null) {
          throw new Error("malformed oid string: " + b);
        }
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = c;
      };
      this.setValueName = function(c) {
        var b = KJUR.asn1.x509.OID.name2oid(c);
        if (b !== "") {
          this.setValueOidString(b);
        } else {
          throw new Error("DERObjectIdentifier oidName undefined: " + c);
        }
      };
      this.setValueNameOrOid = function(b) {
        if (b.match(/^[0-2].[0-9.]+$/)) {
          this.setValueOidString(b);
        } else {
          this.setValueName(b);
        }
      };
      this.getFreshValueHex = function() {
        return this.hV;
      };
      this.setByParam = function(b) {
        if (typeof b === "string") {
          this.setValueNameOrOid(b);
        } else {
          if (b.oid !== void 0) {
            this.setValueNameOrOid(b.oid);
          } else {
            if (b.name !== void 0) {
              this.setValueNameOrOid(b.name);
            } else {
              if (b.hex !== void 0) {
                this.setValueHex(b.hex);
              }
            }
          }
        }
      };
      if (a !== void 0) {
        this.setByParam(a);
      }
    };
    extendClass(KJUR.asn1.DERObjectIdentifier, KJUR.asn1.ASN1Object);
    KJUR.asn1.DEREnumerated = function(a) {
      KJUR.asn1.DEREnumerated.superclass.constructor.call(this);
      this.hT = "0a";
      this.setByBigInteger = function(b) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(b);
      };
      this.setByInteger = function(c) {
        var b = new BigInteger(String(c), 10);
        this.setByBigInteger(b);
      };
      this.setValueHex = function(b) {
        this.hV = b;
      };
      this.getFreshValueHex = function() {
        return this.hV;
      };
      if (typeof a != "undefined") {
        if (typeof a["int"] != "undefined") {
          this.setByInteger(a["int"]);
        } else {
          if (typeof a == "number") {
            this.setByInteger(a);
          } else {
            if (typeof a.hex != "undefined") {
              this.setValueHex(a.hex);
            }
          }
        }
      }
    };
    extendClass(KJUR.asn1.DEREnumerated, KJUR.asn1.ASN1Object);
    KJUR.asn1.DERUTF8String = function(a) {
      KJUR.asn1.DERUTF8String.superclass.constructor.call(this, a);
      this.hT = "0c";
    };
    extendClass(KJUR.asn1.DERUTF8String, KJUR.asn1.DERAbstractString);
    KJUR.asn1.DERNumericString = function(a) {
      KJUR.asn1.DERNumericString.superclass.constructor.call(this, a);
      this.hT = "12";
    };
    extendClass(KJUR.asn1.DERNumericString, KJUR.asn1.DERAbstractString);
    KJUR.asn1.DERPrintableString = function(a) {
      KJUR.asn1.DERPrintableString.superclass.constructor.call(this, a);
      this.hT = "13";
    };
    extendClass(KJUR.asn1.DERPrintableString, KJUR.asn1.DERAbstractString);
    KJUR.asn1.DERTeletexString = function(a) {
      KJUR.asn1.DERTeletexString.superclass.constructor.call(this, a);
      this.hT = "14";
    };
    extendClass(KJUR.asn1.DERTeletexString, KJUR.asn1.DERAbstractString);
    KJUR.asn1.DERIA5String = function(a) {
      KJUR.asn1.DERIA5String.superclass.constructor.call(this, a);
      this.hT = "16";
    };
    extendClass(KJUR.asn1.DERIA5String, KJUR.asn1.DERAbstractString);
    KJUR.asn1.DERVisibleString = function(a) {
      KJUR.asn1.DERIA5String.superclass.constructor.call(this, a);
      this.hT = "1a";
    };
    extendClass(KJUR.asn1.DERVisibleString, KJUR.asn1.DERAbstractString);
    KJUR.asn1.DERBMPString = function(a) {
      KJUR.asn1.DERBMPString.superclass.constructor.call(this, a);
      this.hT = "1e";
    };
    extendClass(KJUR.asn1.DERBMPString, KJUR.asn1.DERAbstractString);
    KJUR.asn1.DERUTCTime = function(a) {
      KJUR.asn1.DERUTCTime.superclass.constructor.call(this, a);
      this.hT = "17";
      this.setByDate = function(b) {
        this.hTLV = null;
        this.isModified = true;
        this.date = b;
        this.s = this.formatDate(this.date, "utc");
        this.hV = stohex(this.s);
      };
      this.getFreshValueHex = function() {
        if (typeof this.date == "undefined" && typeof this.s == "undefined") {
          this.date = new Date();
          this.s = this.formatDate(this.date, "utc");
          this.hV = stohex(this.s);
        }
        return this.hV;
      };
      if (a !== void 0) {
        if (a.str !== void 0) {
          this.setString(a.str);
        } else {
          if (typeof a == "string" && a.match(/^[0-9]{12}Z$/)) {
            this.setString(a);
          } else {
            if (a.hex !== void 0) {
              this.setStringHex(a.hex);
            } else {
              if (a.date !== void 0) {
                this.setByDate(a.date);
              }
            }
          }
        }
      }
    };
    extendClass(KJUR.asn1.DERUTCTime, KJUR.asn1.DERAbstractTime);
    KJUR.asn1.DERGeneralizedTime = function(a) {
      KJUR.asn1.DERGeneralizedTime.superclass.constructor.call(this, a);
      this.hT = "18";
      this.withMillis = false;
      this.setByDate = function(b) {
        this.hTLV = null;
        this.isModified = true;
        this.date = b;
        this.s = this.formatDate(this.date, "gen", this.withMillis);
        this.hV = stohex(this.s);
      };
      this.getFreshValueHex = function() {
        if (this.date === void 0 && this.s === void 0) {
          this.date = new Date();
          this.s = this.formatDate(this.date, "gen", this.withMillis);
          this.hV = stohex(this.s);
        }
        return this.hV;
      };
      if (a !== void 0) {
        if (a.str !== void 0) {
          this.setString(a.str);
        } else {
          if (typeof a == "string" && a.match(/^[0-9]{14}Z$/)) {
            this.setString(a);
          } else {
            if (a.hex !== void 0) {
              this.setStringHex(a.hex);
            } else {
              if (a.date !== void 0) {
                this.setByDate(a.date);
              }
            }
          }
        }
        if (a.millis === true) {
          this.withMillis = true;
        }
      }
    };
    extendClass(KJUR.asn1.DERGeneralizedTime, KJUR.asn1.DERAbstractTime);
    KJUR.asn1.DERSequence = function(a) {
      KJUR.asn1.DERSequence.superclass.constructor.call(this, a);
      this.hT = "30";
      this.getFreshValueHex = function() {
        var c = "";
        for (var b = 0; b < this.asn1Array.length; b++) {
          var d = this.asn1Array[b];
          c += d.getEncodedHex();
        }
        this.hV = c;
        return this.hV;
      };
    };
    extendClass(KJUR.asn1.DERSequence, KJUR.asn1.DERAbstractStructured);
    KJUR.asn1.DERSet = function(a) {
      KJUR.asn1.DERSet.superclass.constructor.call(this, a);
      this.hT = "31";
      this.sortFlag = true;
      this.getFreshValueHex = function() {
        var b = new Array();
        for (var c = 0; c < this.asn1Array.length; c++) {
          var d = this.asn1Array[c];
          b.push(d.getEncodedHex());
        }
        if (this.sortFlag == true) {
          b.sort();
        }
        this.hV = b.join("");
        return this.hV;
      };
      if (typeof a != "undefined") {
        if (typeof a.sortflag != "undefined" && a.sortflag == false) {
          this.sortFlag = false;
        }
      }
    };
    extendClass(KJUR.asn1.DERSet, KJUR.asn1.DERAbstractStructured);
    KJUR.asn1.DERTaggedObject = function(b) {
      KJUR.asn1.DERTaggedObject.superclass.constructor.call(this);
      var a = KJUR.asn1;
      this.hT = "a0";
      this.hV = "";
      this.isExplicit = true;
      this.asn1Object = null;
      this.setASN1Object = function(c, d, e) {
        this.hT = d;
        this.isExplicit = c;
        this.asn1Object = e;
        if (this.isExplicit) {
          this.hV = this.asn1Object.getEncodedHex();
          this.hTLV = null;
          this.isModified = true;
        } else {
          this.hV = null;
          this.hTLV = e.getEncodedHex();
          this.hTLV = this.hTLV.replace(/^../, d);
          this.isModified = false;
        }
      };
      this.getFreshValueHex = function() {
        return this.hV;
      };
      this.setByParam = function(c) {
        if (c.tag != void 0) {
          this.hT = c.tag;
        }
        if (c.explicit != void 0) {
          this.isExplicit = c.explicit;
        }
        if (c.tage != void 0) {
          this.hT = c.tage;
          this.isExplicit = true;
        }
        if (c.tagi != void 0) {
          this.hT = c.tagi;
          this.isExplicit = false;
        }
        if (c.obj != void 0) {
          if (c.obj instanceof a.ASN1Object) {
            this.asn1Object = c.obj;
            this.setASN1Object(this.isExplicit, this.hT, this.asn1Object);
          } else {
            if (typeof c.obj == "object") {
              this.asn1Object = a.ASN1Util.newObject(c.obj);
              this.setASN1Object(this.isExplicit, this.hT, this.asn1Object);
            }
          }
        }
      };
      if (b != void 0) {
        this.setByParam(b);
      }
    };
    extendClass(KJUR.asn1.DERTaggedObject, KJUR.asn1.ASN1Object);
    var ASN1HEX = new function() {
    }();
    ASN1HEX.getLblen = function(c, a) {
      if (c.substr(a + 2, 1) != "8") {
        return 1;
      }
      var b = parseInt(c.substr(a + 3, 1));
      if (b == 0) {
        return -1;
      }
      if (0 < b && b < 10) {
        return b + 1;
      }
      return -2;
    };
    ASN1HEX.getL = function(c, b) {
      var a = ASN1HEX.getLblen(c, b);
      if (a < 1) {
        return "";
      }
      return c.substr(b + 2, a * 2);
    };
    ASN1HEX.getVblen = function(d, a) {
      var c, b;
      c = ASN1HEX.getL(d, a);
      if (c == "") {
        return -1;
      }
      if (c.substr(0, 1) === "8") {
        b = new BigInteger(c.substr(2), 16);
      } else {
        b = new BigInteger(c, 16);
      }
      return b.intValue();
    };
    ASN1HEX.getVidx = function(c, b) {
      var a = ASN1HEX.getLblen(c, b);
      if (a < 0) {
        return a;
      }
      return b + (a + 1) * 2;
    };
    ASN1HEX.getV = function(d, a) {
      var c = ASN1HEX.getVidx(d, a);
      var b = ASN1HEX.getVblen(d, a);
      return d.substr(c, b * 2);
    };
    ASN1HEX.getTLV = function(b, a) {
      return b.substr(a, 2) + ASN1HEX.getL(b, a) + ASN1HEX.getV(b, a);
    };
    ASN1HEX.getTLVblen = function(b, a) {
      return 2 + ASN1HEX.getLblen(b, a) * 2 + ASN1HEX.getVblen(b, a) * 2;
    };
    ASN1HEX.getNextSiblingIdx = function(d, a) {
      var c = ASN1HEX.getVidx(d, a);
      var b = ASN1HEX.getVblen(d, a);
      return c + b * 2;
    };
    ASN1HEX.getChildIdx = function(e, k) {
      var l = ASN1HEX;
      var j = [];
      var c, f, g;
      c = l.getVidx(e, k);
      f = l.getVblen(e, k) * 2;
      if (e.substr(k, 2) == "03") {
        c += 2;
        f -= 2;
      }
      g = 0;
      var d = c;
      while (g <= f) {
        var b = l.getTLVblen(e, d);
        g += b;
        if (g <= f) {
          j.push(d);
        }
        d += b;
        if (g >= f) {
          break;
        }
      }
      return j;
    };
    ASN1HEX.getNthChildIdx = function(d, b, e) {
      var c = ASN1HEX.getChildIdx(d, b);
      return c[e];
    };
    ASN1HEX.getIdxbyList = function(e, d, c, i) {
      var g = ASN1HEX;
      var f, b;
      if (c.length == 0) {
        if (i !== void 0) {
          if (e.substr(d, 2) !== i) {
            return -1;
          }
        }
        return d;
      }
      f = c.shift();
      b = g.getChildIdx(e, d);
      if (f >= b.length) {
        return -1;
      }
      return g.getIdxbyList(e, b[f], c, i);
    };
    ASN1HEX.getIdxbyListEx = function(f, k, b, g) {
      var m = ASN1HEX;
      var d, l;
      if (b.length == 0) {
        if (g !== void 0) {
          if (f.substr(k, 2) !== g) {
            return -1;
          }
        }
        return k;
      }
      d = b.shift();
      l = m.getChildIdx(f, k);
      var j = 0;
      for (var e = 0; e < l.length; e++) {
        var c = f.substr(l[e], 2);
        if (typeof d == "number" && !m.isContextTag(c) && j == d || typeof d == "string" && m.isContextTag(c, d)) {
          return m.getIdxbyListEx(f, l[e], b, g);
        }
        if (!m.isContextTag(c)) {
          j++;
        }
      }
      return -1;
    };
    ASN1HEX.getTLVbyList = function(d, c, b, f) {
      var e = ASN1HEX;
      var a = e.getIdxbyList(d, c, b, f);
      if (a == -1) {
        return null;
      }
      if (a >= d.length) {
        return null;
      }
      return e.getTLV(d, a);
    };
    ASN1HEX.getTLVbyListEx = function(d, c, b, f) {
      var e = ASN1HEX;
      var a = e.getIdxbyListEx(d, c, b, f);
      if (a == -1) {
        return null;
      }
      return e.getTLV(d, a);
    };
    ASN1HEX.getVbyList = function(e, c, b, g, i) {
      var f = ASN1HEX;
      var a, d;
      a = f.getIdxbyList(e, c, b, g);
      if (a == -1) {
        return null;
      }
      if (a >= e.length) {
        return null;
      }
      d = f.getV(e, a);
      if (i === true) {
        d = d.substr(2);
      }
      return d;
    };
    ASN1HEX.getVbyListEx = function(b, e, a, d, f) {
      var j = ASN1HEX;
      var g, c, i;
      g = j.getIdxbyListEx(b, e, a, d);
      if (g == -1) {
        return null;
      }
      i = j.getV(b, g);
      if (b.substr(g, 2) == "03" && f !== false) {
        i = i.substr(2);
      }
      return i;
    };
    ASN1HEX.getInt = function(e, b, f) {
      if (f == void 0) {
        f = -1;
      }
      try {
        var c = e.substr(b, 2);
        if (c != "02" && c != "03") {
          return f;
        }
        var a = ASN1HEX.getV(e, b);
        if (c == "02") {
          return parseInt(a, 16);
        } else {
          return bitstrtoint(a);
        }
      } catch (d) {
        return f;
      }
    };
    ASN1HEX.getOID = function(c, a, d) {
      if (d == void 0) {
        d = null;
      }
      try {
        if (c.substr(a, 2) != "06") {
          return d;
        }
        var e = ASN1HEX.getV(c, a);
        return hextooid(e);
      } catch (b) {
        return d;
      }
    };
    ASN1HEX.getOIDName = function(d, a, f) {
      if (f == void 0) {
        f = null;
      }
      try {
        var e = ASN1HEX.getOID(d, a, f);
        if (e == f) {
          return f;
        }
        var b = KJUR.asn1.x509.OID.oid2name(e);
        if (b == "") {
          return e;
        }
        return b;
      } catch (c) {
        return f;
      }
    };
    ASN1HEX.getString = function(d, b, e) {
      if (e == void 0) {
        e = null;
      }
      try {
        var a = ASN1HEX.getV(d, b);
        return hextorstr(a);
      } catch (c) {
        return e;
      }
    };
    ASN1HEX.hextooidstr = function(e) {
      var h = function(b, a) {
        if (b.length >= a) {
          return b;
        }
        return new Array(a - b.length + 1).join("0") + b;
      };
      var l = [];
      var o = e.substr(0, 2);
      var f = parseInt(o, 16);
      l[0] = new String(Math.floor(f / 40));
      l[1] = new String(f % 40);
      var m = e.substr(2);
      var k = [];
      for (var g = 0; g < m.length / 2; g++) {
        k.push(parseInt(m.substr(g * 2, 2), 16));
      }
      var j = [];
      var d = "";
      for (var g = 0; g < k.length; g++) {
        if (k[g] & 128) {
          d = d + h((k[g] & 127).toString(2), 7);
        } else {
          d = d + h((k[g] & 127).toString(2), 7);
          j.push(new String(parseInt(d, 2)));
          d = "";
        }
      }
      var n = l.join(".");
      if (j.length > 0) {
        n = n + "." + j.join(".");
      }
      return n;
    };
    ASN1HEX.dump = function(t2, c, l, g) {
      var p = ASN1HEX;
      var j = p.getV;
      var y = p.dump;
      var w = p.getChildIdx;
      var e = t2;
      if (t2 instanceof KJUR.asn1.ASN1Object) {
        e = t2.getEncodedHex();
      }
      var q = function(A, i) {
        if (A.length <= i * 2) {
          return A;
        } else {
          var v = A.substr(0, i) + "..(total " + A.length / 2 + "bytes).." + A.substr(A.length - i, i);
          return v;
        }
      };
      if (c === void 0) {
        c = { ommit_long_octet: 32 };
      }
      if (l === void 0) {
        l = 0;
      }
      if (g === void 0) {
        g = "";
      }
      var x = c.ommit_long_octet;
      var z2 = e.substr(l, 2);
      if (z2 == "01") {
        var h = j(e, l);
        if (h == "00") {
          return g + "BOOLEAN FALSE\n";
        } else {
          return g + "BOOLEAN TRUE\n";
        }
      }
      if (z2 == "02") {
        var h = j(e, l);
        return g + "INTEGER " + q(h, x) + "\n";
      }
      if (z2 == "03") {
        var h = j(e, l);
        if (p.isASN1HEX(h.substr(2))) {
          var k = g + "BITSTRING, encapsulates\n";
          k = k + y(h.substr(2), c, 0, g + "  ");
          return k;
        } else {
          return g + "BITSTRING " + q(h, x) + "\n";
        }
      }
      if (z2 == "04") {
        var h = j(e, l);
        if (p.isASN1HEX(h)) {
          var k = g + "OCTETSTRING, encapsulates\n";
          k = k + y(h, c, 0, g + "  ");
          return k;
        } else {
          return g + "OCTETSTRING " + q(h, x) + "\n";
        }
      }
      if (z2 == "05") {
        return g + "NULL\n";
      }
      if (z2 == "06") {
        var m = j(e, l);
        var b = KJUR.asn1.ASN1Util.oidHexToInt(m);
        var o = KJUR.asn1.x509.OID.oid2name(b);
        var a = b.replace(/\./g, " ");
        if (o != "") {
          return g + "ObjectIdentifier " + o + " (" + a + ")\n";
        } else {
          return g + "ObjectIdentifier (" + a + ")\n";
        }
      }
      if (z2 == "0a") {
        return g + "ENUMERATED " + parseInt(j(e, l)) + "\n";
      }
      if (z2 == "0c") {
        return g + "UTF8String '" + hextoutf8(j(e, l)) + "'\n";
      }
      if (z2 == "13") {
        return g + "PrintableString '" + hextoutf8(j(e, l)) + "'\n";
      }
      if (z2 == "14") {
        return g + "TeletexString '" + hextoutf8(j(e, l)) + "'\n";
      }
      if (z2 == "16") {
        return g + "IA5String '" + hextoutf8(j(e, l)) + "'\n";
      }
      if (z2 == "17") {
        return g + "UTCTime " + hextoutf8(j(e, l)) + "\n";
      }
      if (z2 == "18") {
        return g + "GeneralizedTime " + hextoutf8(j(e, l)) + "\n";
      }
      if (z2 == "1a") {
        return g + "VisualString '" + hextoutf8(j(e, l)) + "'\n";
      }
      if (z2 == "1e") {
        return g + "BMPString '" + ucs2hextoutf8(j(e, l)) + "'\n";
      }
      if (z2 == "30") {
        if (e.substr(l, 4) == "3000") {
          return g + "SEQUENCE {}\n";
        }
        var k = g + "SEQUENCE\n";
        var d = w(e, l);
        var f = c;
        if ((d.length == 2 || d.length == 3) && e.substr(d[0], 2) == "06" && e.substr(d[d.length - 1], 2) == "04") {
          var o = p.oidname(j(e, d[0]));
          var r = JSON.parse(JSON.stringify(c));
          r.x509ExtName = o;
          f = r;
        }
        for (var u = 0; u < d.length; u++) {
          k = k + y(e, f, d[u], g + "  ");
        }
        return k;
      }
      if (z2 == "31") {
        var k = g + "SET\n";
        var d = w(e, l);
        for (var u = 0; u < d.length; u++) {
          k = k + y(e, c, d[u], g + "  ");
        }
        return k;
      }
      var z2 = parseInt(z2, 16);
      if ((z2 & 128) != 0) {
        var n = z2 & 31;
        if ((z2 & 32) != 0) {
          var k = g + "[" + n + "]\n";
          var d = w(e, l);
          for (var u = 0; u < d.length; u++) {
            k = k + y(e, c, d[u], g + "  ");
          }
          return k;
        } else {
          var h = j(e, l);
          if (ASN1HEX.isASN1HEX(h)) {
            var k = g + "[" + n + "]\n";
            k = k + y(h, c, 0, g + "  ");
            return k;
          } else {
            if (h.substr(0, 8) == "68747470") {
              h = hextoutf8(h);
            } else {
              if (c.x509ExtName === "subjectAltName" && n == 2) {
                h = hextoutf8(h);
              }
            }
          }
          var k = g + "[" + n + "] " + h + "\n";
          return k;
        }
      }
      return g + "UNKNOWN(" + z2 + ") " + j(e, l) + "\n";
    };
    ASN1HEX.isContextTag = function(c, b) {
      c = c.toLowerCase();
      var f, e;
      try {
        f = parseInt(c, 16);
      } catch (d) {
        return -1;
      }
      if (b === void 0) {
        if ((f & 192) == 128) {
          return true;
        } else {
          return false;
        }
      }
      try {
        var a = b.match(/^\[[0-9]+\]$/);
        if (a == null) {
          return false;
        }
        e = parseInt(b.substr(1, b.length - 1), 10);
        if (e > 31) {
          return false;
        }
        if ((f & 192) == 128 && (f & 31) == e) {
          return true;
        }
        return false;
      } catch (d) {
        return false;
      }
    };
    ASN1HEX.isASN1HEX = function(e) {
      var d = ASN1HEX;
      if (e.length % 2 == 1) {
        return false;
      }
      var c = d.getVblen(e, 0);
      var b = e.substr(0, 2);
      var f = d.getL(e, 0);
      var a = e.length - b.length - f.length;
      if (a == c * 2) {
        return true;
      }
      return false;
    };
    ASN1HEX.checkStrictDER = function(g, o, d, c, r) {
      var s = ASN1HEX;
      if (d === void 0) {
        if (typeof g != "string") {
          throw new Error("not hex string");
        }
        g = g.toLowerCase();
        if (!KJUR.lang.String.isHex(g)) {
          throw new Error("not hex string");
        }
        d = g.length;
        c = g.length / 2;
        if (c < 128) {
          r = 1;
        } else {
          r = Math.ceil(c.toString(16)) + 1;
        }
      }
      var k = s.getL(g, o);
      if (k.length > r * 2) {
        throw new Error("L of TLV too long: idx=" + o);
      }
      var n = s.getVblen(g, o);
      if (n > c) {
        throw new Error("value of L too long than hex: idx=" + o);
      }
      var q = s.getTLV(g, o);
      var f = q.length - 2 - s.getL(g, o).length;
      if (f !== n * 2) {
        throw new Error("V string length and L's value not the same:" + f + "/" + n * 2);
      }
      if (o === 0) {
        if (g.length != q.length) {
          throw new Error("total length and TLV length unmatch:" + g.length + "!=" + q.length);
        }
      }
      var b = g.substr(o, 2);
      if (b === "02") {
        var a = s.getVidx(g, o);
        if (g.substr(a, 2) == "00" && g.charCodeAt(a + 2) < 56) {
          throw new Error("not least zeros for DER INTEGER");
        }
      }
      if (parseInt(b, 16) & 32) {
        var p = s.getVblen(g, o);
        var m = 0;
        var l = s.getChildIdx(g, o);
        for (var e = 0; e < l.length; e++) {
          var j = s.getTLV(g, l[e]);
          m += j.length;
          s.checkStrictDER(g, l[e], d, c, r);
        }
        if (p * 2 != m) {
          throw new Error("sum of children's TLV length and L unmatch: " + p * 2 + "!=" + m);
        }
      }
    };
    ASN1HEX.oidname = function(a) {
      var c = KJUR.asn1;
      if (KJUR.lang.String.isHex(a)) {
        a = c.ASN1Util.oidHexToInt(a);
      }
      var b = c.x509.OID.oid2name(a);
      if (b === "") {
        b = a;
      }
      return b;
    };
    if (typeof KJUR == "undefined" || !KJUR) {
      KJUR = {};
    }
    if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) {
      KJUR.asn1 = {};
    }
    if (typeof KJUR.asn1.x509 == "undefined" || !KJUR.asn1.x509) {
      KJUR.asn1.x509 = {};
    }
    KJUR.asn1.x509.Certificate = function(h) {
      KJUR.asn1.x509.Certificate.superclass.constructor.call(this);
      var d = KJUR, c = d.asn1, f = c.DERBitString, b = c.DERSequence, g = c.x509, a = g.TBSCertificate, e = g.AlgorithmIdentifier;
      this.params = void 0;
      this.setByParam = function(i) {
        this.params = i;
      };
      this.sign = function() {
        var l = this.params;
        var k = l.sigalg;
        if (l.sigalg.name != void 0) {
          k = l.sigalg.name;
        }
        var i = l.tbsobj.getEncodedHex();
        var j = new KJUR.crypto.Signature({ alg: k });
        j.init(l.cakey);
        j.updateHex(i);
        l.sighex = j.sign();
      };
      this.getPEM = function() {
        return hextopem(this.getEncodedHex(), "CERTIFICATE");
      };
      this.getEncodedHex = function() {
        var k = this.params;
        if (k.tbsobj == void 0 || k.tbsobj == null) {
          k.tbsobj = new a(k);
        }
        if (k.sighex == void 0 && k.cakey != void 0) {
          this.sign();
        }
        if (k.sighex == void 0) {
          throw new Error("sighex or cakey parameter not defined");
        }
        var i = [];
        i.push(k.tbsobj);
        i.push(new e({ name: k.sigalg }));
        i.push(new f({ hex: "00" + k.sighex }));
        var j = new b({ array: i });
        return j.getEncodedHex();
      };
      if (h != void 0) {
        this.params = h;
      }
    };
    extendClass(KJUR.asn1.x509.Certificate, KJUR.asn1.ASN1Object);
    KJUR.asn1.x509.TBSCertificate = function(f) {
      KJUR.asn1.x509.TBSCertificate.superclass.constructor.call(this);
      var b = KJUR, i = b.asn1, d = i.x509, c = i.DERTaggedObject, h = i.DERInteger, g = i.DERSequence, l = d.AlgorithmIdentifier, e = d.Time, a = d.X500Name, j = d.Extensions, k = d.SubjectPublicKeyInfo;
      this.params = null;
      this.setByParam = function(m) {
        this.params = m;
      };
      this.getEncodedHex = function() {
        var n = [];
        var q = this.params;
        if (q.version != void 0 || q.version != 1) {
          var m = 2;
          if (q.version != void 0) {
            m = q.version - 1;
          }
          var p = new c({ obj: new h({ "int": m }) });
          n.push(p);
        }
        n.push(new h(q.serial));
        n.push(new l({ name: q.sigalg }));
        n.push(new a(q.issuer));
        n.push(new g({ array: [new e(q.notbefore), new e(q.notafter)] }));
        n.push(new a(q.subject));
        n.push(new k(KEYUTIL.getKey(q.sbjpubkey)));
        if (q.ext !== void 0 && q.ext.length > 0) {
          n.push(new c({ tag: "a3", obj: new j(q.ext) }));
        }
        var o = new KJUR.asn1.DERSequence({ array: n });
        return o.getEncodedHex();
      };
      if (f !== void 0) {
        this.setByParam(f);
      }
    };
    extendClass(KJUR.asn1.x509.TBSCertificate, KJUR.asn1.ASN1Object);
    KJUR.asn1.x509.Extensions = function(d) {
      KJUR.asn1.x509.Extensions.superclass.constructor.call(this);
      var c = KJUR, b = c.asn1, a = b.DERSequence, e = b.x509;
      this.aParam = [];
      this.setByParam = function(f) {
        this.aParam = f;
      };
      this.getEncodedHex = function() {
        var f = [];
        for (var h = 0; h < this.aParam.length; h++) {
          var l = this.aParam[h];
          var k = l.extname;
          var j = null;
          if (l.extn != void 0) {
            j = new e.PrivateExtension(l);
          } else {
            if (k == "subjectKeyIdentifier") {
              j = new e.SubjectKeyIdentifier(l);
            } else {
              if (k == "keyUsage") {
                j = new e.KeyUsage(l);
              } else {
                if (k == "subjectAltName") {
                  j = new e.SubjectAltName(l);
                } else {
                  if (k == "issuerAltName") {
                    j = new e.IssuerAltName(l);
                  } else {
                    if (k == "basicConstraints") {
                      j = new e.BasicConstraints(l);
                    } else {
                      if (k == "cRLDistributionPoints") {
                        j = new e.CRLDistributionPoints(l);
                      } else {
                        if (k == "certificatePolicies") {
                          j = new e.CertificatePolicies(l);
                        } else {
                          if (k == "authorityKeyIdentifier") {
                            j = new e.AuthorityKeyIdentifier(l);
                          } else {
                            if (k == "extKeyUsage") {
                              j = new e.ExtKeyUsage(l);
                            } else {
                              if (k == "authorityInfoAccess") {
                                j = new e.AuthorityInfoAccess(l);
                              } else {
                                if (k == "cRLNumber") {
                                  j = new e.CRLNumber(l);
                                } else {
                                  if (k == "cRLReason") {
                                    j = new e.CRLReason(l);
                                  } else {
                                    if (k == "ocspNonce") {
                                      j = new e.OCSPNonce(l);
                                    } else {
                                      if (k == "ocspNoCheck") {
                                        j = new e.OCSPNoCheck(l);
                                      } else {
                                        if (k == "adobeTimeStamp") {
                                          j = new e.AdobeTimeStamp(l);
                                        } else {
                                          if (k == "subjectDirectoryAttributes") {
                                            j = new e.SubjectDirectoryAttributes(l);
                                          } else {
                                            throw new Error("extension not supported:" + JSON.stringify(l));
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (j != null) {
            f.push(j);
          }
        }
        var g = new a({ array: f });
        return g.getEncodedHex();
      };
      if (d != void 0) {
        this.setByParam(d);
      }
    };
    extendClass(KJUR.asn1.x509.Extensions, KJUR.asn1.ASN1Object);
    KJUR.asn1.x509.Extension = function(d) {
      KJUR.asn1.x509.Extension.superclass.constructor.call(this);
      var f = null, a = KJUR, e = a.asn1, h = e.DERObjectIdentifier, i = e.DEROctetString, b = e.DERBitString, g = e.DERBoolean, c = e.DERSequence;
      this.getEncodedHex = function() {
        var m = new h({ oid: this.oid });
        var l = new i({ hex: this.getExtnValueHex() });
        var k = new Array();
        k.push(m);
        if (this.critical) {
          k.push(new g());
        }
        k.push(l);
        var j = new c({ array: k });
        return j.getEncodedHex();
      };
      this.critical = false;
      if (d !== void 0) {
        if (d.critical !== void 0) {
          this.critical = d.critical;
        }
      }
    };
    extendClass(KJUR.asn1.x509.Extension, KJUR.asn1.ASN1Object);
    KJUR.asn1.x509.KeyUsage = function(f) {
      KJUR.asn1.x509.KeyUsage.superclass.constructor.call(this, f);
      var a = X509.KEYUSAGE_NAME;
      this.getExtnValueHex = function() {
        return this.asn1ExtnValue.getEncodedHex();
      };
      this.oid = "2.5.29.15";
      if (f !== void 0) {
        if (f.bin !== void 0) {
          this.asn1ExtnValue = new KJUR.asn1.DERBitString(f);
        }
        if (f.names !== void 0 && f.names.length !== void 0) {
          var e = f.names;
          var d = "000000000";
          for (var c = 0; c < e.length; c++) {
            for (var b = 0; b < a.length; b++) {
              if (e[c] === a[b]) {
                d = d.substring(0, b) + "1" + d.substring(b + 1, d.length);
              }
            }
          }
          this.asn1ExtnValue = new KJUR.asn1.DERBitString({ bin: d });
        }
      }
    };
    extendClass(KJUR.asn1.x509.KeyUsage, KJUR.asn1.x509.Extension);
    KJUR.asn1.x509.BasicConstraints = function(g) {
      KJUR.asn1.x509.BasicConstraints.superclass.constructor.call(this, g);
      var c = KJUR.asn1, e = c.DERBoolean, f = c.DERInteger, b = c.DERSequence;
      var a = false;
      var d = -1;
      this.getExtnValueHex = function() {
        var i = new Array();
        if (this.cA) {
          i.push(new e());
        }
        if (this.pathLen > -1) {
          i.push(new f({ "int": this.pathLen }));
        }
        var h = new b({ array: i });
        this.asn1ExtnValue = h;
        return this.asn1ExtnValue.getEncodedHex();
      };
      this.oid = "2.5.29.19";
      this.cA = false;
      this.pathLen = -1;
      if (g !== void 0) {
        if (g.cA !== void 0) {
          this.cA = g.cA;
        }
        if (g.pathLen !== void 0) {
          this.pathLen = g.pathLen;
        }
      }
    };
    extendClass(KJUR.asn1.x509.BasicConstraints, KJUR.asn1.x509.Extension);
    KJUR.asn1.x509.CRLDistributionPoints = function(d) {
      KJUR.asn1.x509.CRLDistributionPoints.superclass.constructor.call(this, d);
      var b = KJUR, a = b.asn1, c = a.x509;
      this.getExtnValueHex = function() {
        return this.asn1ExtnValue.getEncodedHex();
      };
      this.setByDPArray = function(e) {
        var f = [];
        for (var g = 0; g < e.length; g++) {
          if (e[g] instanceof KJUR.asn1.ASN1Object) {
            f.push(e[g]);
          } else {
            var h = new c.DistributionPoint(e[g]);
            f.push(h);
          }
        }
        this.asn1ExtnValue = new a.DERSequence({ array: f });
      };
      this.setByOneURI = function(f) {
        var e = new c.DistributionPoint({ fulluri: f });
        this.setByDPArray([e]);
      };
      this.oid = "2.5.29.31";
      if (d !== void 0) {
        if (d.array !== void 0) {
          this.setByDPArray(d.array);
        } else {
          if (d.uri !== void 0) {
            this.setByOneURI(d.uri);
          }
        }
      }
    };
    extendClass(KJUR.asn1.x509.CRLDistributionPoints, KJUR.asn1.x509.Extension);
    KJUR.asn1.x509.DistributionPoint = function(e) {
      KJUR.asn1.x509.DistributionPoint.superclass.constructor.call(this);
      var a = null, c = KJUR, b = c.asn1, d = b.x509.DistributionPointName;
      this.getEncodedHex = function() {
        var f = new b.DERSequence();
        if (this.asn1DP != null) {
          var g = new b.DERTaggedObject({ explicit: true, tag: "a0", obj: this.asn1DP });
          f.appendASN1Object(g);
        }
        this.hTLV = f.getEncodedHex();
        return this.hTLV;
      };
      if (e !== void 0) {
        if (e.dpobj !== void 0) {
          this.asn1DP = e.dpobj;
        } else {
          if (e.dpname !== void 0) {
            this.asn1DP = new d(e.dpname);
          } else {
            if (e.fulluri !== void 0) {
              this.asn1DP = new d({ full: [{ uri: e.fulluri }] });
            }
          }
        }
      }
    };
    extendClass(KJUR.asn1.x509.DistributionPoint, KJUR.asn1.ASN1Object);
    KJUR.asn1.x509.DistributionPointName = function(h) {
      KJUR.asn1.x509.DistributionPointName.superclass.constructor.call(this);
      var g = null, d = null, a = null, f = null, c = KJUR, b = c.asn1, e = b.DERTaggedObject;
      this.getEncodedHex = function() {
        if (this.type != "full") {
          throw new Error("currently type shall be 'full': " + this.type);
        }
        this.asn1Obj = new e({ explicit: false, tag: this.tag, obj: this.asn1V });
        this.hTLV = this.asn1Obj.getEncodedHex();
        return this.hTLV;
      };
      if (h !== void 0) {
        if (b.x509.GeneralNames.prototype.isPrototypeOf(h)) {
          this.type = "full";
          this.tag = "a0";
          this.asn1V = h;
        } else {
          if (h.full !== void 0) {
            this.type = "full";
            this.tag = "a0";
            this.asn1V = new b.x509.GeneralNames(h.full);
          } else {
            throw new Error("This class supports GeneralNames only as argument");
          }
        }
      }
    };
    extendClass(KJUR.asn1.x509.DistributionPointName, KJUR.asn1.ASN1Object);
    KJUR.asn1.x509.CertificatePolicies = function(f) {
      KJUR.asn1.x509.CertificatePolicies.superclass.constructor.call(this, f);
      var c = KJUR, b = c.asn1, e = b.x509, a = b.DERSequence, d = e.PolicyInformation;
      this.params = null;
      this.getExtnValueHex = function() {
        var j = [];
        for (var h = 0; h < this.params.array.length; h++) {
          j.push(new d(this.params.array[h]));
        }
        var g = new a({ array: j });
        this.asn1ExtnValue = g;
        return this.asn1ExtnValue.getEncodedHex();
      };
      this.oid = "2.5.29.32";
      if (f !== void 0) {
        this.params = f;
      }
    };
    extendClass(KJUR.asn1.x509.CertificatePolicies, KJUR.asn1.x509.Extension);
    KJUR.asn1.x509.PolicyInformation = function(d) {
      KJUR.asn1.x509.PolicyInformation.superclass.constructor.call(this, d);
      var c = KJUR.asn1, b = c.DERSequence, e = c.DERObjectIdentifier, a = c.x509.PolicyQualifierInfo;
      this.params = null;
      this.getEncodedHex = function() {
        if (this.params.policyoid === void 0 && this.params.array === void 0) {
          throw new Error("parameter oid and array missing");
        }
        var f = [new e(this.params.policyoid)];
        if (this.params.array !== void 0) {
          var j = [];
          for (var h = 0; h < this.params.array.length; h++) {
            j.push(new a(this.params.array[h]));
          }
          if (j.length > 0) {
            f.push(new b({ array: j }));
          }
        }
        var g = new b({ array: f });
        return g.getEncodedHex();
      };
      if (d !== void 0) {
        this.params = d;
      }
    };
    extendClass(KJUR.asn1.x509.PolicyInformation, KJUR.asn1.ASN1Object);
    KJUR.asn1.x509.PolicyQualifierInfo = function(e) {
      KJUR.asn1.x509.PolicyQualifierInfo.superclass.constructor.call(this, e);
      var c = KJUR.asn1, b = c.DERSequence, d = c.DERIA5String, f = c.DERObjectIdentifier, a = c.x509.UserNotice;
      this.params = null;
      this.getEncodedHex = function() {
        if (this.params.cps !== void 0) {
          var g = new b({ array: [new f({ oid: "1.3.6.1.5.5.7.2.1" }), new d({ str: this.params.cps })] });
          return g.getEncodedHex();
        }
        if (this.params.unotice != void 0) {
          var g = new b({ array: [new f({ oid: "1.3.6.1.5.5.7.2.2" }), new a(this.params.unotice)] });
          return g.getEncodedHex();
        }
      };
      if (e !== void 0) {
        this.params = e;
      }
    };
    extendClass(KJUR.asn1.x509.PolicyQualifierInfo, KJUR.asn1.ASN1Object);
    KJUR.asn1.x509.UserNotice = function(e) {
      KJUR.asn1.x509.UserNotice.superclass.constructor.call(this, e);
      var a = KJUR.asn1.DERSequence, d = KJUR.asn1.DERInteger, c = KJUR.asn1.x509.DisplayText, b = KJUR.asn1.x509.NoticeReference;
      this.params = null;
      this.getEncodedHex = function() {
        var f = [];
        if (this.params.noticeref !== void 0) {
          f.push(new b(this.params.noticeref));
        }
        if (this.params.exptext !== void 0) {
          f.push(new c(this.params.exptext));
        }
        var g = new a({ array: f });
        return g.getEncodedHex();
      };
      if (e !== void 0) {
        this.params = e;
      }
    };
    extendClass(KJUR.asn1.x509.UserNotice, KJUR.asn1.ASN1Object);
    KJUR.asn1.x509.NoticeReference = function(d) {
      KJUR.asn1.x509.NoticeReference.superclass.constructor.call(this, d);
      var a = KJUR.asn1.DERSequence, c = KJUR.asn1.DERInteger, b = KJUR.asn1.x509.DisplayText;
      this.params = null;
      this.getEncodedHex = function() {
        var f = [];
        if (this.params.org !== void 0) {
          f.push(new b(this.params.org));
        }
        if (this.params.noticenum !== void 0) {
          var h = [];
          var e = this.params.noticenum;
          for (var j = 0; j < e.length; j++) {
            h.push(new c(e[j]));
          }
          f.push(new a({ array: h }));
        }
        if (f.length == 0) {
          throw new Error("parameter is empty");
        }
        var g = new a({ array: f });
        return g.getEncodedHex();
      };
      if (d !== void 0) {
        this.params = d;
      }
    };
    extendClass(KJUR.asn1.x509.NoticeReference, KJUR.asn1.ASN1Object);
    KJUR.asn1.x509.DisplayText = function(a) {
      KJUR.asn1.x509.DisplayText.superclass.constructor.call(this, a);
      this.hT = "0c";
      if (a !== void 0) {
        if (a.type === "ia5") {
          this.hT = "16";
        } else {
          if (a.type === "vis") {
            this.hT = "1a";
          } else {
            if (a.type === "bmp") {
              this.hT = "1e";
            }
          }
        }
      }
    };
    extendClass(KJUR.asn1.x509.DisplayText, KJUR.asn1.DERAbstractString);
    KJUR.asn1.x509.ExtKeyUsage = function(c) {
      KJUR.asn1.x509.ExtKeyUsage.superclass.constructor.call(this, c);
      var b = KJUR, a = b.asn1;
      this.setPurposeArray = function(d) {
        this.asn1ExtnValue = new a.DERSequence();
        for (var e = 0; e < d.length; e++) {
          var f = new a.DERObjectIdentifier(d[e]);
          this.asn1ExtnValue.appendASN1Object(f);
        }
      };
      this.getExtnValueHex = function() {
        return this.asn1ExtnValue.getEncodedHex();
      };
      this.oid = "2.5.29.37";
      if (c !== void 0) {
        if (c.array !== void 0) {
          this.setPurposeArray(c.array);
        }
      }
    };
    extendClass(KJUR.asn1.x509.ExtKeyUsage, KJUR.asn1.x509.Extension);
    KJUR.asn1.x509.AuthorityKeyIdentifier = function(f) {
      KJUR.asn1.x509.AuthorityKeyIdentifier.superclass.constructor.call(this, f);
      var b = KJUR, a = b.asn1, d = a.DERTaggedObject, e = a.x509.GeneralNames, c = b.crypto.Util.isKey;
      this.asn1KID = null;
      this.asn1CertIssuer = null;
      this.asn1CertSN = null;
      this.getExtnValueHex = function() {
        var h = new Array();
        if (this.asn1KID) {
          h.push(new d({ explicit: false, tag: "80", obj: this.asn1KID }));
        }
        if (this.asn1CertIssuer) {
          h.push(new d({ explicit: false, tag: "a1", obj: new e([{ dn: this.asn1CertIssuer }]) }));
        }
        if (this.asn1CertSN) {
          h.push(new d({ explicit: false, tag: "82", obj: this.asn1CertSN }));
        }
        var g = new a.DERSequence({ array: h });
        this.asn1ExtnValue = g;
        return this.asn1ExtnValue.getEncodedHex();
      };
      this.setKIDByParam = function(i) {
        if (i.str !== void 0 || i.hex !== void 0) {
          this.asn1KID = new KJUR.asn1.DEROctetString(i);
        } else {
          if (typeof i === "object" && KJUR.crypto.Util.isKey(i) || typeof i === "string" && i.indexOf("BEGIN ") != -1) {
            var h = i;
            if (typeof i === "string") {
              h = KEYUTIL.getKey(i);
            }
            var g = KEYUTIL.getKeyID(h);
            this.asn1KID = new KJUR.asn1.DEROctetString({ hex: g });
          }
        }
      };
      this.setCertIssuerByParam = function(g) {
        if (g.str !== void 0 || g.ldapstr !== void 0 || g.hex !== void 0 || g.certsubject !== void 0 || g.certissuer !== void 0) {
          this.asn1CertIssuer = new KJUR.asn1.x509.X500Name(g);
        } else {
          if (typeof g === "string" && g.indexOf("BEGIN ") != -1 && g.indexOf("CERTIFICATE") != -1) {
            this.asn1CertIssuer = new KJUR.asn1.x509.X500Name({ certissuer: g });
          }
        }
      };
      this.setCertSNByParam = function(i) {
        if (i.str !== void 0 || i.bigint !== void 0 || i.hex !== void 0) {
          this.asn1CertSN = new KJUR.asn1.DERInteger(i);
        } else {
          if (typeof i === "string" && i.indexOf("BEGIN ") != -1 && i.indexOf("CERTIFICATE")) {
            var g = new X509();
            g.readCertPEM(i);
            var h = g.getSerialNumberHex();
            this.asn1CertSN = new KJUR.asn1.DERInteger({ hex: h });
          }
        }
      };
      this.oid = "2.5.29.35";
      if (f !== void 0) {
        if (f.kid !== void 0) {
          this.setKIDByParam(f.kid);
        }
        if (f.issuer !== void 0) {
          this.setCertIssuerByParam(f.issuer);
        }
        if (f.sn !== void 0) {
          this.setCertSNByParam(f.sn);
        }
        if (f.issuersn !== void 0 && typeof f.issuersn === "string" && f.issuersn.indexOf("BEGIN ") != -1 && f.issuersn.indexOf("CERTIFICATE")) {
          this.setCertSNByParam(f.issuersn);
          this.setCertIssuerByParam(f.issuersn);
        }
      }
    };
    extendClass(KJUR.asn1.x509.AuthorityKeyIdentifier, KJUR.asn1.x509.Extension);
    KJUR.asn1.x509.SubjectKeyIdentifier = function(d) {
      KJUR.asn1.x509.SubjectKeyIdentifier.superclass.constructor.call(this, d);
      var b = KJUR, a = b.asn1, c = a.DEROctetString;
      this.asn1KID = null;
      this.getExtnValueHex = function() {
        this.asn1ExtnValue = this.asn1KID;
        return this.asn1ExtnValue.getEncodedHex();
      };
      this.setKIDByParam = function(g) {
        if (g.str !== void 0 || g.hex !== void 0) {
          this.asn1KID = new c(g);
        } else {
          if (typeof g === "object" && KJUR.crypto.Util.isKey(g) || typeof g === "string" && g.indexOf("BEGIN") != -1) {
            var f = g;
            if (typeof g === "string") {
              f = KEYUTIL.getKey(g);
            }
            var e = KEYUTIL.getKeyID(f);
            this.asn1KID = new KJUR.asn1.DEROctetString({ hex: e });
          }
        }
      };
      this.oid = "2.5.29.14";
      if (d !== void 0) {
        if (d.kid !== void 0) {
          this.setKIDByParam(d.kid);
        }
      }
    };
    extendClass(KJUR.asn1.x509.SubjectKeyIdentifier, KJUR.asn1.x509.Extension);
    KJUR.asn1.x509.AuthorityInfoAccess = function(a) {
      KJUR.asn1.x509.AuthorityInfoAccess.superclass.constructor.call(this, a);
      this.setAccessDescriptionArray = function(k) {
        var d = new Array(), b = KJUR, g = b.asn1, c = g.DERSequence, j = g.DERObjectIdentifier, l = g.x509.GeneralName;
        for (var f = 0; f < k.length; f++) {
          var e;
          var h = k[f];
          if (h.ocsp !== void 0) {
            e = new c({ array: [new j({ oid: "1.3.6.1.5.5.7.48.1" }), new l({ uri: h.ocsp })] });
          } else {
            if (h.caissuer !== void 0) {
              e = new c({ array: [new j({ oid: "1.3.6.1.5.5.7.48.2" }), new l({ uri: h.caissuer })] });
            } else {
              throw new Error("unknown AccessMethod parameter: " + JSON.stringify(h));
            }
          }
          d.push(e);
        }
        this.asn1ExtnValue = new c({ array: d });
      };
      this.getExtnValueHex = function() {
        return this.asn1ExtnValue.getEncodedHex();
      };
      this.oid = "1.3.6.1.5.5.7.1.1";
      if (a !== void 0) {
        if (a.array !== void 0) {
          this.setAccessDescriptionArray(a.array);
        }
      }
    };
    extendClass(KJUR.asn1.x509.AuthorityInfoAccess, KJUR.asn1.x509.Extension);
    KJUR.asn1.x509.SubjectAltName = function(a) {
      KJUR.asn1.x509.SubjectAltName.superclass.constructor.call(this, a);
      this.setNameArray = function(b) {
        this.asn1ExtnValue = new KJUR.asn1.x509.GeneralNames(b);
      };
      this.getExtnValueHex = function() {
        return this.asn1ExtnValue.getEncodedHex();
      };
      this.oid = "2.5.29.17";
      if (a !== void 0) {
        if (a.array !== void 0) {
          this.setNameArray(a.array);
        }
      }
    };
    extendClass(KJUR.asn1.x509.SubjectAltName, KJUR.asn1.x509.Extension);
    KJUR.asn1.x509.IssuerAltName = function(a) {
      KJUR.asn1.x509.IssuerAltName.superclass.constructor.call(this, a);
      this.setNameArray = function(b) {
        this.asn1ExtnValue = new KJUR.asn1.x509.GeneralNames(b);
      };
      this.getExtnValueHex = function() {
        return this.asn1ExtnValue.getEncodedHex();
      };
      this.oid = "2.5.29.18";
      if (a !== void 0) {
        if (a.array !== void 0) {
          this.setNameArray(a.array);
        }
      }
    };
    extendClass(KJUR.asn1.x509.IssuerAltName, KJUR.asn1.x509.Extension);
    KJUR.asn1.x509.SubjectDirectoryAttributes = function(e) {
      KJUR.asn1.x509.SubjectDirectoryAttributes.superclass.constructor.call(this, e);
      var c = KJUR.asn1, a = c.DERSequence, b = c.ASN1Util.newObject, d = c.x509.OID.name2oid;
      this.params = null;
      this.getExtnValueHex = function() {
        var f = [];
        for (var j = 0; j < this.params.array.length; j++) {
          var k = this.params.array[j];
          var h = { seq: [{ oid: "1.2.3.4" }, { set: [{ utf8str: "DE" }] }] };
          if (k.attr == "dateOfBirth") {
            h.seq[0].oid = d(k.attr);
            h.seq[1].set[0] = { gentime: k.str };
          } else {
            if (k.attr == "placeOfBirth") {
              h.seq[0].oid = d(k.attr);
              h.seq[1].set[0] = { utf8str: k.str };
            } else {
              if (k.attr == "gender") {
                h.seq[0].oid = d(k.attr);
                h.seq[1].set[0] = { prnstr: k.str };
              } else {
                if (k.attr == "countryOfCitizenship") {
                  h.seq[0].oid = d(k.attr);
                  h.seq[1].set[0] = { prnstr: k.str };
                } else {
                  if (k.attr == "countryOfResidence") {
                    h.seq[0].oid = d(k.attr);
                    h.seq[1].set[0] = { prnstr: k.str };
                  } else {
                    throw new Error("unsupported attribute: " + k.attr);
                  }
                }
              }
            }
          }
          f.push(new b(h));
        }
        var g = new a({ array: f });
        this.asn1ExtnValue = g;
        return this.asn1ExtnValue.getEncodedHex();
      };
      this.oid = "2.5.29.9";
      if (e !== void 0) {
        this.params = e;
      }
    };
    extendClass(KJUR.asn1.x509.SubjectDirectoryAttributes, KJUR.asn1.x509.Extension);
    KJUR.asn1.x509.PrivateExtension = function(f) {
      KJUR.asn1.x509.PrivateExtension.superclass.constructor.call(this, f);
      var c = KJUR, e = c.lang.String.isHex, b = c.asn1, d = b.x509.OID.name2oid, a = b.ASN1Util.newObject;
      this.params = null;
      this.setByParam = function(g) {
        this.oid = d(g.extname);
        this.params = g;
      };
      this.getExtnValueHex = function() {
        if (this.params.extname == void 0 || this.params.extn == void 0) {
          throw new Error("extname or extnhex not specified");
        }
        var h = this.params.extn;
        if (typeof h == "string" && e(h)) {
          return h;
        } else {
          if (typeof h == "object") {
            try {
              return a(h).getEncodedHex();
            } catch (g) {
            }
          }
        }
        throw new Error("unsupported extn value");
      };
      if (f != void 0) {
        this.setByParam(f);
      }
    };
    extendClass(KJUR.asn1.x509.PrivateExtension, KJUR.asn1.x509.Extension);
    KJUR.asn1.x509.CRL = function(g) {
      KJUR.asn1.x509.CRL.superclass.constructor.call(this);
      var c = KJUR, b = c.asn1, a = b.DERSequence, e = b.DERBitString, f = b.x509, d = f.AlgorithmIdentifier, h = f.TBSCertList;
      this.params = void 0;
      this.setByParam = function(i) {
        this.params = i;
      };
      this.sign = function() {
        var j = new h(this.params).getEncodedHex();
        var k = new KJUR.crypto.Signature({ alg: this.params.sigalg });
        k.init(this.params.cakey);
        k.updateHex(j);
        var i = k.sign();
        this.params.sighex = i;
      };
      this.getPEM = function() {
        return hextopem(this.getEncodedHex(), "X509 CRL");
      };
      this.getEncodedHex = function() {
        var k = this.params;
        if (k.tbsobj == void 0) {
          k.tbsobj = new h(k);
        }
        if (k.sighex == void 0 && k.cakey != void 0) {
          this.sign();
        }
        if (k.sighex == void 0) {
          throw new Error("sighex or cakey parameter not defined");
        }
        var i = [];
        i.push(k.tbsobj);
        i.push(new d({ name: k.sigalg }));
        i.push(new e({ hex: "00" + k.sighex }));
        var j = new a({ array: i });
        return j.getEncodedHex();
      };
      if (g != void 0) {
        this.params = g;
      }
    };
    extendClass(KJUR.asn1.x509.CRL, KJUR.asn1.ASN1Object);
    KJUR.asn1.x509.TBSCertList = function(f) {
      KJUR.asn1.x509.TBSCertList.superclass.constructor.call(this);
      var b = KJUR, i = b.asn1, h = i.DERInteger, g = i.DERSequence, c = i.DERTaggedObject, k = i.DERObjectIdentifier, d = i.x509, l = d.AlgorithmIdentifier, e = d.Time, j = d.Extensions, a = d.X500Name;
      this.params = null;
      this.setByParam = function(m) {
        this.params = m;
      };
      this.getRevCertSequence = function() {
        var m = [];
        var n = this.params.revcert;
        for (var o = 0; o < n.length; o++) {
          var p = [new h(n[o].sn), new e(n[o].date)];
          if (n[o].ext != void 0) {
            p.push(new j(n[o].ext));
          }
          m.push(new g({ array: p }));
        }
        return new g({ array: m });
      };
      this.getEncodedHex = function() {
        var n = [];
        var r = this.params;
        if (r.version != void 0) {
          var m = r.version - 1;
          var p = new h({ "int": m });
          n.push(p);
        }
        n.push(new l({ name: r.sigalg }));
        n.push(new a(r.issuer));
        n.push(new e(r.thisupdate));
        if (r.nextupdate != void 0) {
          n.push(new e(r.nextupdate));
        }
        if (r.revcert != void 0) {
          n.push(this.getRevCertSequence());
        }
        if (r.ext != void 0) {
          var q = new j(r.ext);
          n.push(new c({ tag: "a0", explicit: true, obj: q }));
        }
        var o = new g({ array: n });
        return o.getEncodedHex();
      };
      if (f !== void 0) {
        this.setByParam(f);
      }
    };
    extendClass(KJUR.asn1.x509.TBSCertList, KJUR.asn1.ASN1Object);
    KJUR.asn1.x509.CRLEntry = function(e) {
      KJUR.asn1.x509.CRLEntry.superclass.constructor.call(this);
      var d = null, c = null, b = KJUR, a = b.asn1;
      this.setCertSerial = function(f) {
        this.sn = new a.DERInteger(f);
      };
      this.setRevocationDate = function(f) {
        this.time = new a.x509.Time(f);
      };
      this.getEncodedHex = function() {
        var f = new a.DERSequence({ array: [this.sn, this.time] });
        this.TLV = f.getEncodedHex();
        return this.TLV;
      };
      if (e !== void 0) {
        if (e.time !== void 0) {
          this.setRevocationDate(e.time);
        }
        if (e.sn !== void 0) {
          this.setCertSerial(e.sn);
        }
      }
    };
    extendClass(KJUR.asn1.x509.CRLEntry, KJUR.asn1.ASN1Object);
    KJUR.asn1.x509.CRLNumber = function(a) {
      KJUR.asn1.x509.CRLNumber.superclass.constructor.call(this, a);
      this.params = void 0;
      this.getExtnValueHex = function() {
        this.asn1ExtnValue = new KJUR.asn1.DERInteger(this.params.num);
        return this.asn1ExtnValue.getEncodedHex();
      };
      this.oid = "2.5.29.20";
      if (a != void 0) {
        this.params = a;
      }
    };
    extendClass(KJUR.asn1.x509.CRLNumber, KJUR.asn1.x509.Extension);
    KJUR.asn1.x509.CRLReason = function(a) {
      KJUR.asn1.x509.CRLReason.superclass.constructor.call(this, a);
      this.params = void 0;
      this.getExtnValueHex = function() {
        this.asn1ExtnValue = new KJUR.asn1.DEREnumerated(this.params.code);
        return this.asn1ExtnValue.getEncodedHex();
      };
      this.oid = "2.5.29.21";
      if (a != void 0) {
        this.params = a;
      }
    };
    extendClass(KJUR.asn1.x509.CRLReason, KJUR.asn1.x509.Extension);
    KJUR.asn1.x509.OCSPNonce = function(a) {
      KJUR.asn1.x509.OCSPNonce.superclass.constructor.call(this, a);
      this.params = void 0;
      this.getExtnValueHex = function() {
        this.asn1ExtnValue = new KJUR.asn1.DEROctetString(this.params);
        return this.asn1ExtnValue.getEncodedHex();
      };
      this.oid = "1.3.6.1.5.5.7.48.1.2";
      if (a != void 0) {
        this.params = a;
      }
    };
    extendClass(KJUR.asn1.x509.OCSPNonce, KJUR.asn1.x509.Extension);
    KJUR.asn1.x509.OCSPNoCheck = function(a) {
      KJUR.asn1.x509.OCSPNoCheck.superclass.constructor.call(this, a);
      this.params = void 0;
      this.getExtnValueHex = function() {
        this.asn1ExtnValue = new KJUR.asn1.DERNull();
        return this.asn1ExtnValue.getEncodedHex();
      };
      this.oid = "1.3.6.1.5.5.7.48.1.5";
      if (a != void 0) {
        this.params = a;
      }
    };
    extendClass(KJUR.asn1.x509.OCSPNoCheck, KJUR.asn1.x509.Extension);
    KJUR.asn1.x509.AdobeTimeStamp = function(g) {
      KJUR.asn1.x509.AdobeTimeStamp.superclass.constructor.call(this, g);
      var c = KJUR, b = c.asn1, f = b.DERInteger, d = b.DERBoolean, a = b.DERSequence, e = b.x509.GeneralName;
      this.params = null;
      this.getExtnValueHex = function() {
        var i = this.params;
        var h = [new f(1)];
        h.push(new e({ uri: i.uri }));
        if (i.reqauth != void 0) {
          h.push(new d(i.reqauth));
        }
        this.asn1ExtnValue = new a({ array: h });
        return this.asn1ExtnValue.getEncodedHex();
      };
      this.oid = "1.2.840.113583.1.1.9.1";
      if (g !== void 0) {
        this.setByParam(g);
      }
    };
    extendClass(KJUR.asn1.x509.AdobeTimeStamp, KJUR.asn1.x509.Extension);
    KJUR.asn1.x509.X500Name = function(f) {
      KJUR.asn1.x509.X500Name.superclass.constructor.call(this);
      this.asn1Array = [];
      this.paramArray = [];
      this.sRule = "utf8";
      var c = KJUR, b = c.asn1, e = b.x509, d = e.RDN, a = pemtohex;
      this.setByString = function(g, l) {
        if (l !== void 0) {
          this.sRule = l;
        }
        var k = g.split("/");
        k.shift();
        var j = [];
        for (var m = 0; m < k.length; m++) {
          if (k[m].match(/^[^=]+=.+$/)) {
            j.push(k[m]);
          } else {
            var h = j.length - 1;
            j[h] = j[h] + "/" + k[m];
          }
        }
        for (var m = 0; m < j.length; m++) {
          this.asn1Array.push(new d({ str: j[m], rule: this.sRule }));
        }
      };
      this.setByLdapString = function(g, h) {
        if (h !== void 0) {
          this.sRule = h;
        }
        var i = e.X500Name.ldapToCompat(g);
        this.setByString(i, h);
      };
      this.setByObject = function(j, i) {
        if (i !== void 0) {
          this.sRule = i;
        }
        for (var g in j) {
          if (j.hasOwnProperty(g)) {
            var h = new d({ str: g + "=" + j[g], rule: this.sRule });
            this.asn1Array ? this.asn1Array.push(h) : this.asn1Array = [h];
          }
        }
      };
      this.setByParam = function(h) {
        if (h.rule !== void 0) {
          this.sRule = h.rule;
        }
        if (h.array !== void 0) {
          this.paramArray = h.array;
        } else {
          if (h.str !== void 0) {
            this.setByString(h.str);
          } else {
            if (h.ldapstr !== void 0) {
              this.setByLdapString(h.ldapstr);
            } else {
              if (h.hex !== void 0) {
                this.hTLV = h.hex;
              } else {
                if (h.certissuer !== void 0) {
                  var g = new X509();
                  g.readCertPEM(h.certissuer);
                  this.hTLV = g.getIssuerHex();
                } else {
                  if (h.certsubject !== void 0) {
                    var g = new X509();
                    g.readCertPEM(h.certsubject);
                    this.hTLV = g.getSubjectHex();
                  } else {
                    if (typeof h === "object" && h.certsubject === void 0 && h.certissuer === void 0) {
                      this.setByObject(h);
                    }
                  }
                }
              }
            }
          }
        }
      };
      this.getEncodedHex = function() {
        if (typeof this.hTLV == "string") {
          return this.hTLV;
        }
        if (this.asn1Array.length == 0 && this.paramArray.length > 0) {
          for (var g = 0; g < this.paramArray.length; g++) {
            var k = { array: this.paramArray[g] };
            if (this.sRule != "utf8") {
              k.rule = this.sRule;
            }
            var h = new d(k);
            this.asn1Array.push(h);
          }
        }
        var j = new b.DERSequence({ array: this.asn1Array });
        this.hTLV = j.getEncodedHex();
        return this.hTLV;
      };
      if (f !== void 0) {
        this.setByParam(f);
      }
    };
    extendClass(KJUR.asn1.x509.X500Name, KJUR.asn1.ASN1Object);
    KJUR.asn1.x509.X500Name.compatToLDAP = function(d) {
      if (d.substr(0, 1) !== "/") {
        throw "malformed input";
      }
      var b = "";
      d = d.substr(1);
      var c = d.split("/");
      c.reverse();
      c = c.map(function(a) {
        return a.replace(/,/, "\\,");
      });
      return c.join(",");
    };
    KJUR.asn1.x509.X500Name.onelineToLDAP = function(a) {
      return KJUR.asn1.x509.X500Name.compatToLDAP(a);
    };
    KJUR.asn1.x509.X500Name.ldapToCompat = function(g) {
      var c = g.split(",");
      var e = false;
      var b = [];
      for (var f = 0; c.length > 0; f++) {
        var h = c.shift();
        if (e === true) {
          var d = b.pop();
          var j = (d + "," + h).replace(/\\,/g, ",");
          b.push(j);
          e = false;
        } else {
          b.push(h);
        }
        if (h.substr(-1, 1) === "\\") {
          e = true;
        }
      }
      b = b.map(function(a) {
        return a.replace("/", "\\/");
      });
      b.reverse();
      return "/" + b.join("/");
    };
    KJUR.asn1.x509.X500Name.ldapToOneline = function(a) {
      return KJUR.asn1.x509.X500Name.ldapToCompat(a);
    };
    KJUR.asn1.x509.RDN = function(b) {
      KJUR.asn1.x509.RDN.superclass.constructor.call(this);
      this.asn1Array = [];
      this.paramArray = [];
      this.sRule = "utf8";
      var a = KJUR.asn1.x509.AttributeTypeAndValue;
      this.setByParam = function(c) {
        if (c.rule !== void 0) {
          this.sRule = c.rule;
        }
        if (c.str !== void 0) {
          this.addByMultiValuedString(c.str);
        }
        if (c.array !== void 0) {
          this.paramArray = c.array;
        }
      };
      this.addByString = function(c) {
        this.asn1Array.push(new KJUR.asn1.x509.AttributeTypeAndValue({ str: c, rule: this.sRule }));
      };
      this.addByMultiValuedString = function(e) {
        var c = KJUR.asn1.x509.RDN.parseString(e);
        for (var d = 0; d < c.length; d++) {
          this.addByString(c[d]);
        }
      };
      this.getEncodedHex = function() {
        if (this.asn1Array.length == 0 && this.paramArray.length > 0) {
          for (var d = 0; d < this.paramArray.length; d++) {
            var f = this.paramArray[d];
            if (f.rule !== void 0 && this.sRule != "utf8") {
              f.rule = this.sRule;
            }
            var c = new a(f);
            this.asn1Array.push(c);
          }
        }
        var e = new KJUR.asn1.DERSet({ array: this.asn1Array });
        this.TLV = e.getEncodedHex();
        return this.TLV;
      };
      if (b !== void 0) {
        this.setByParam(b);
      }
    };
    extendClass(KJUR.asn1.x509.RDN, KJUR.asn1.ASN1Object);
    KJUR.asn1.x509.RDN.parseString = function(m) {
      var j = m.split(/\+/);
      var h = false;
      var c = [];
      for (var g = 0; j.length > 0; g++) {
        var k = j.shift();
        if (h === true) {
          var f = c.pop();
          var d = (f + "+" + k).replace(/\\\+/g, "+");
          c.push(d);
          h = false;
        } else {
          c.push(k);
        }
        if (k.substr(-1, 1) === "\\") {
          h = true;
        }
      }
      var l = false;
      var b = [];
      for (var g = 0; c.length > 0; g++) {
        var k = c.shift();
        if (l === true) {
          var e = b.pop();
          if (k.match(/"$/)) {
            var d = (e + "+" + k).replace(/^([^=]+)="(.*)"$/, "$1=$2");
            b.push(d);
            l = false;
          } else {
            b.push(e + "+" + k);
          }
        } else {
          b.push(k);
        }
        if (k.match(/^[^=]+="/)) {
          l = true;
        }
      }
      return b;
    };
    KJUR.asn1.x509.AttributeTypeAndValue = function(c) {
      KJUR.asn1.x509.AttributeTypeAndValue.superclass.constructor.call(this);
      this.sRule = "utf8";
      this.sType = null;
      this.sValue = null;
      this.dsType = null;
      var a = KJUR, g = a.asn1, d = g.DERSequence, l = g.DERUTF8String, i = g.DERPrintableString, h = g.DERTeletexString, b = g.DERIA5String, e = g.DERVisibleString, k = g.DERBMPString, f = a.lang.String.isMail, j = a.lang.String.isPrintable;
      this.setByParam = function(o) {
        if (o.rule !== void 0) {
          this.sRule = o.rule;
        }
        if (o.ds !== void 0) {
          this.dsType = o.ds;
        }
        if (o.value === void 0 && o.str !== void 0) {
          var n = o.str;
          var m = n.match(/^([^=]+)=(.+)$/);
          if (m) {
            this.sType = m[1];
            this.sValue = m[2];
          } else {
            throw new Error("malformed attrTypeAndValueStr: " + attrTypeAndValueStr);
          }
        } else {
          this.sType = o.type;
          this.sValue = o.value;
        }
      };
      this.setByString = function(n, o) {
        if (o !== void 0) {
          this.sRule = o;
        }
        var m = n.match(/^([^=]+)=(.+)$/);
        if (m) {
          this.setByAttrTypeAndValueStr(m[1], m[2]);
        } else {
          throw new Error("malformed attrTypeAndValueStr: " + attrTypeAndValueStr);
        }
      };
      this._getDsType = function() {
        var o = this.sType;
        var n = this.sValue;
        var m = this.sRule;
        if (m === "prn") {
          if (o == "CN" && f(n)) {
            return "ia5";
          }
          if (j(n)) {
            return "prn";
          }
          return "utf8";
        } else {
          if (m === "utf8") {
            if (o == "CN" && f(n)) {
              return "ia5";
            }
            if (o == "C") {
              return "prn";
            }
            return "utf8";
          }
        }
        return "utf8";
      };
      this.setByAttrTypeAndValueStr = function(o, n, m) {
        if (m !== void 0) {
          this.sRule = m;
        }
        this.sType = o;
        this.sValue = n;
      };
      this.getValueObj = function(n, m) {
        if (n == "utf8") {
          return new l({ str: m });
        }
        if (n == "prn") {
          return new i({ str: m });
        }
        if (n == "tel") {
          return new h({ str: m });
        }
        if (n == "ia5") {
          return new b({ str: m });
        }
        if (n == "vis") {
          return new e({ str: m });
        }
        if (n == "bmp") {
          return new k({ str: m });
        }
        throw new Error("unsupported directory string type: type=" + n + " value=" + m);
      };
      this.getEncodedHex = function() {
        if (this.dsType == null) {
          this.dsType = this._getDsType();
        }
        var n = KJUR.asn1.x509.OID.atype2obj(this.sType);
        var m = this.getValueObj(this.dsType, this.sValue);
        var p = new d({ array: [n, m] });
        this.TLV = p.getEncodedHex();
        return this.TLV;
      };
      if (c !== void 0) {
        this.setByParam(c);
      }
    };
    extendClass(KJUR.asn1.x509.AttributeTypeAndValue, KJUR.asn1.ASN1Object);
    KJUR.asn1.x509.SubjectPublicKeyInfo = function(f) {
      KJUR.asn1.x509.SubjectPublicKeyInfo.superclass.constructor.call(this);
      var l = null, k = null, a = KJUR, j = a.asn1, i = j.DERInteger, b = j.DERBitString, m = j.DERObjectIdentifier, e = j.DERSequence, h = j.ASN1Util.newObject, d = j.x509, o = d.AlgorithmIdentifier, g = a.crypto, n = g.ECDSA, c = g.DSA;
      this.getASN1Object = function() {
        if (this.asn1AlgId == null || this.asn1SubjPKey == null) {
          throw "algId and/or subjPubKey not set";
        }
        var p = new e({ array: [this.asn1AlgId, this.asn1SubjPKey] });
        return p;
      };
      this.getEncodedHex = function() {
        var p = this.getASN1Object();
        this.hTLV = p.getEncodedHex();
        return this.hTLV;
      };
      this.setPubKey = function(q) {
        try {
          if (q instanceof RSAKey) {
            var u = h({ seq: [{ "int": { bigint: q.n } }, { "int": { "int": q.e } }] });
            var s = u.getEncodedHex();
            this.asn1AlgId = new o({ name: "rsaEncryption" });
            this.asn1SubjPKey = new b({ hex: "00" + s });
          }
        } catch (p) {
        }
        try {
          if (q instanceof KJUR.crypto.ECDSA) {
            var r = new m({ name: q.curveName });
            this.asn1AlgId = new o({ name: "ecPublicKey", asn1params: r });
            this.asn1SubjPKey = new b({ hex: "00" + q.pubKeyHex });
          }
        } catch (p) {
        }
        try {
          if (q instanceof KJUR.crypto.DSA) {
            var r = new h({ seq: [{ "int": { bigint: q.p } }, { "int": { bigint: q.q } }, { "int": { bigint: q.g } }] });
            this.asn1AlgId = new o({ name: "dsa", asn1params: r });
            var t2 = new i({ bigint: q.y });
            this.asn1SubjPKey = new b({ hex: "00" + t2.getEncodedHex() });
          }
        } catch (p) {
        }
      };
      if (f !== void 0) {
        this.setPubKey(f);
      }
    };
    extendClass(KJUR.asn1.x509.SubjectPublicKeyInfo, KJUR.asn1.ASN1Object);
    KJUR.asn1.x509.Time = function(f) {
      KJUR.asn1.x509.Time.superclass.constructor.call(this);
      var e = null, a = null, d = KJUR, c = d.asn1, b = c.DERUTCTime, g = c.DERGeneralizedTime;
      this.setTimeParams = function(h) {
        this.timeParams = h;
      };
      this.getEncodedHex = function() {
        var h = null;
        if (this.timeParams != null) {
          if (this.type == "utc") {
            h = new b(this.timeParams);
          } else {
            h = new g(this.timeParams);
          }
        } else {
          if (this.type == "utc") {
            h = new b();
          } else {
            h = new g();
          }
        }
        this.TLV = h.getEncodedHex();
        return this.TLV;
      };
      this.type = "utc";
      if (f !== void 0) {
        if (f.type !== void 0) {
          this.type = f.type;
        } else {
          if (f.str !== void 0) {
            if (f.str.match(/^[0-9]{12}Z$/)) {
              this.type = "utc";
            }
            if (f.str.match(/^[0-9]{14}Z$/)) {
              this.type = "gen";
            }
          }
        }
        this.timeParams = f;
      }
    };
    extendClass(KJUR.asn1.x509.Time, KJUR.asn1.ASN1Object);
    KJUR.asn1.x509.AlgorithmIdentifier = function(e) {
      KJUR.asn1.x509.AlgorithmIdentifier.superclass.constructor.call(this);
      this.nameAlg = null;
      this.asn1Alg = null;
      this.asn1Params = null;
      this.paramEmpty = false;
      var b = KJUR, a = b.asn1, c = a.x509.AlgorithmIdentifier.PSSNAME2ASN1TLV;
      this.getEncodedHex = function() {
        if (this.nameAlg === null && this.asn1Alg === null) {
          throw new Error("algorithm not specified");
        }
        if (this.nameAlg !== null) {
          var f = null;
          for (var h in c) {
            if (h === this.nameAlg) {
              f = c[h];
            }
          }
          if (f !== null) {
            this.hTLV = f;
            return this.hTLV;
          }
        }
        if (this.nameAlg !== null && this.asn1Alg === null) {
          this.asn1Alg = a.x509.OID.name2obj(this.nameAlg);
        }
        var g = [this.asn1Alg];
        if (this.asn1Params !== null) {
          g.push(this.asn1Params);
        }
        var i = new a.DERSequence({ array: g });
        this.hTLV = i.getEncodedHex();
        return this.hTLV;
      };
      if (e !== void 0) {
        if (e.name !== void 0) {
          this.nameAlg = e.name;
        }
        if (e.asn1params !== void 0) {
          this.asn1Params = e.asn1params;
        }
        if (e.paramempty !== void 0) {
          this.paramEmpty = e.paramempty;
        }
      }
      if (this.asn1Params === null && this.paramEmpty === false && this.nameAlg !== null) {
        if (this.nameAlg.name !== void 0) {
          this.nameAlg = this.nameAlg.name;
        }
        var d = this.nameAlg.toLowerCase();
        if (d.substr(-7, 7) !== "withdsa" && d.substr(-9, 9) !== "withecdsa") {
          this.asn1Params = new a.DERNull();
        }
      }
    };
    extendClass(KJUR.asn1.x509.AlgorithmIdentifier, KJUR.asn1.ASN1Object);
    KJUR.asn1.x509.AlgorithmIdentifier.PSSNAME2ASN1TLV = { SHAwithRSAandMGF1: "300d06092a864886f70d01010a3000", SHA256withRSAandMGF1: "303d06092a864886f70d01010a3030a00d300b0609608648016503040201a11a301806092a864886f70d010108300b0609608648016503040201a203020120", SHA384withRSAandMGF1: "303d06092a864886f70d01010a3030a00d300b0609608648016503040202a11a301806092a864886f70d010108300b0609608648016503040202a203020130", SHA512withRSAandMGF1: "303d06092a864886f70d01010a3030a00d300b0609608648016503040203a11a301806092a864886f70d010108300b0609608648016503040203a203020140" };
    KJUR.asn1.x509.GeneralName = function(e) {
      KJUR.asn1.x509.GeneralName.superclass.constructor.call(this);
      var m = null, i = null, k = { rfc822: "81", dns: "82", dn: "a4", uri: "86", ip: "87" }, b = KJUR, g = b.asn1, f = g.DERSequence, j = g.DEROctetString, d = g.DERIA5String, c = g.DERTaggedObject, l = g.ASN1Object, a = g.x509.X500Name, h = pemtohex;
      this.explicit = false;
      this.setByParam = function(p) {
        var r = null;
        var u = null;
        if (p === void 0) {
          return;
        }
        if (p.rfc822 !== void 0) {
          this.type = "rfc822";
          u = new d({ str: p[this.type] });
        }
        if (p.dns !== void 0) {
          this.type = "dns";
          u = new d({ str: p[this.type] });
        }
        if (p.uri !== void 0) {
          this.type = "uri";
          u = new d({ str: p[this.type] });
        }
        if (p.dn !== void 0) {
          this.type = "dn";
          this.explicit = true;
          if (typeof p.dn === "string") {
            u = new a({ str: p.dn });
          } else {
            if (p.dn instanceof KJUR.asn1.x509.X500Name) {
              u = p.dn;
            } else {
              u = new a(p.dn);
            }
          }
        }
        if (p.ldapdn !== void 0) {
          this.type = "dn";
          this.explicit = true;
          u = new a({ ldapstr: p.ldapdn });
        }
        if (p.certissuer !== void 0) {
          this.type = "dn";
          this.explicit = true;
          var o = p.certissuer;
          var w = null;
          if (o.match(/^[0-9A-Fa-f]+$/)) {
            w == o;
          }
          if (o.indexOf("-----BEGIN ") != -1) {
            w = h(o);
          }
          if (w == null) {
            throw "certissuer param not cert";
          }
          var t2 = new X509();
          t2.hex = w;
          var y = t2.getIssuerHex();
          u = new l();
          u.hTLV = y;
        }
        if (p.certsubj !== void 0) {
          this.type = "dn";
          this.explicit = true;
          var o = p.certsubj;
          var w = null;
          if (o.match(/^[0-9A-Fa-f]+$/)) {
            w == o;
          }
          if (o.indexOf("-----BEGIN ") != -1) {
            w = h(o);
          }
          if (w == null) {
            throw "certsubj param not cert";
          }
          var t2 = new X509();
          t2.hex = w;
          var y = t2.getSubjectHex();
          u = new l();
          u.hTLV = y;
        }
        if (p.ip !== void 0) {
          this.type = "ip";
          this.explicit = false;
          var q = p.ip;
          var s;
          var n = "malformed IP address";
          if (q.match(/^[0-9.]+[.][0-9.]+$/)) {
            s = intarystrtohex("[" + q.split(".").join(",") + "]");
            if (s.length !== 8) {
              throw n;
            }
          } else {
            if (q.match(/^[0-9A-Fa-f:]+:[0-9A-Fa-f:]+$/)) {
              s = ipv6tohex(q);
            } else {
              if (q.match(/^([0-9A-Fa-f][0-9A-Fa-f]){1,}$/)) {
                s = q;
              } else {
                throw n;
              }
            }
          }
          u = new j({ hex: s });
        }
        if (this.type == null) {
          throw "unsupported type in params=" + p;
        }
        this.asn1Obj = new c({ explicit: this.explicit, tag: k[this.type], obj: u });
      };
      this.getEncodedHex = function() {
        return this.asn1Obj.getEncodedHex();
      };
      if (e !== void 0) {
        this.setByParam(e);
      }
    };
    extendClass(KJUR.asn1.x509.GeneralName, KJUR.asn1.ASN1Object);
    KJUR.asn1.x509.GeneralNames = function(d) {
      KJUR.asn1.x509.GeneralNames.superclass.constructor.call(this);
      var a = null, c = KJUR, b = c.asn1;
      this.setByParamArray = function(g) {
        for (var e = 0; e < g.length; e++) {
          var f = new b.x509.GeneralName(g[e]);
          this.asn1Array.push(f);
        }
      };
      this.getEncodedHex = function() {
        var e = new b.DERSequence({ array: this.asn1Array });
        return e.getEncodedHex();
      };
      this.asn1Array = new Array();
      if (typeof d != "undefined") {
        this.setByParamArray(d);
      }
    };
    extendClass(KJUR.asn1.x509.GeneralNames, KJUR.asn1.ASN1Object);
    KJUR.asn1.x509.OID = new function(a) {
      this.atype2oidList = { CN: "2.5.4.3", L: "2.5.4.7", ST: "2.5.4.8", O: "2.5.4.10", OU: "2.5.4.11", C: "2.5.4.6", STREET: "2.5.4.9", DC: "0.9.2342.19200300.100.1.25", UID: "0.9.2342.19200300.100.1.1", SN: "2.5.4.4", T: "2.5.4.12", DN: "2.5.4.49", E: "1.2.840.113549.1.9.1", description: "2.5.4.13", businessCategory: "2.5.4.15", postalCode: "2.5.4.17", serialNumber: "2.5.4.5", uniqueIdentifier: "2.5.4.45", organizationIdentifier: "2.5.4.97", jurisdictionOfIncorporationL: "1.3.6.1.4.1.311.60.2.1.1", jurisdictionOfIncorporationSP: "1.3.6.1.4.1.311.60.2.1.2", jurisdictionOfIncorporationC: "1.3.6.1.4.1.311.60.2.1.3" };
      this.name2oidList = { sha1: "1.3.14.3.2.26", sha256: "2.16.840.1.101.3.4.2.1", sha384: "2.16.840.1.101.3.4.2.2", sha512: "2.16.840.1.101.3.4.2.3", sha224: "2.16.840.1.101.3.4.2.4", md5: "1.2.840.113549.2.5", md2: "1.3.14.7.2.2.1", ripemd160: "1.3.36.3.2.1", MD2withRSA: "1.2.840.113549.1.1.2", MD4withRSA: "1.2.840.113549.1.1.3", MD5withRSA: "1.2.840.113549.1.1.4", SHA1withRSA: "1.2.840.113549.1.1.5", "pkcs1-MGF": "1.2.840.113549.1.1.8", rsaPSS: "1.2.840.113549.1.1.10", SHA224withRSA: "1.2.840.113549.1.1.14", SHA256withRSA: "1.2.840.113549.1.1.11", SHA384withRSA: "1.2.840.113549.1.1.12", SHA512withRSA: "1.2.840.113549.1.1.13", SHA1withECDSA: "1.2.840.10045.4.1", SHA224withECDSA: "1.2.840.10045.4.3.1", SHA256withECDSA: "1.2.840.10045.4.3.2", SHA384withECDSA: "1.2.840.10045.4.3.3", SHA512withECDSA: "1.2.840.10045.4.3.4", dsa: "1.2.840.10040.4.1", SHA1withDSA: "1.2.840.10040.4.3", SHA224withDSA: "2.16.840.1.101.3.4.3.1", SHA256withDSA: "2.16.840.1.101.3.4.3.2", rsaEncryption: "1.2.840.113549.1.1.1", commonName: "2.5.4.3", countryName: "2.5.4.6", localityName: "2.5.4.7", stateOrProvinceName: "2.5.4.8", streetAddress: "2.5.4.9", organizationName: "2.5.4.10", organizationalUnitName: "2.5.4.11", domainComponent: "0.9.2342.19200300.100.1.25", userId: "0.9.2342.19200300.100.1.1", surname: "2.5.4.4", givenName: "2.5.4.42", title: "2.5.4.12", distinguishedName: "2.5.4.49", emailAddress: "1.2.840.113549.1.9.1", description: "2.5.4.13", businessCategory: "2.5.4.15", postalCode: "2.5.4.17", uniqueIdentifier: "2.5.4.45", organizationIdentifier: "2.5.4.97", jurisdictionOfIncorporationL: "1.3.6.1.4.1.311.60.2.1.1", jurisdictionOfIncorporationSP: "1.3.6.1.4.1.311.60.2.1.2", jurisdictionOfIncorporationC: "1.3.6.1.4.1.311.60.2.1.3", subjectDirectoryAttributes: "2.5.29.9", subjectKeyIdentifier: "2.5.29.14", keyUsage: "2.5.29.15", subjectAltName: "2.5.29.17", issuerAltName: "2.5.29.18", basicConstraints: "2.5.29.19", cRLNumber: "2.5.29.20", cRLReason: "2.5.29.21", nameConstraints: "2.5.29.30", cRLDistributionPoints: "2.5.29.31", certificatePolicies: "2.5.29.32", anyPolicy: "2.5.29.32.0", authorityKeyIdentifier: "2.5.29.35", policyConstraints: "2.5.29.36", extKeyUsage: "2.5.29.37", authorityInfoAccess: "1.3.6.1.5.5.7.1.1", ocsp: "1.3.6.1.5.5.7.48.1", ocspBasic: "1.3.6.1.5.5.7.48.1.1", ocspNonce: "1.3.6.1.5.5.7.48.1.2", ocspNoCheck: "1.3.6.1.5.5.7.48.1.5", caIssuers: "1.3.6.1.5.5.7.48.2", anyExtendedKeyUsage: "2.5.29.37.0", serverAuth: "1.3.6.1.5.5.7.3.1", clientAuth: "1.3.6.1.5.5.7.3.2", codeSigning: "1.3.6.1.5.5.7.3.3", emailProtection: "1.3.6.1.5.5.7.3.4", timeStamping: "1.3.6.1.5.5.7.3.8", ocspSigning: "1.3.6.1.5.5.7.3.9", dateOfBirth: "1.3.6.1.5.5.7.9.1", placeOfBirth: "1.3.6.1.5.5.7.9.2", gender: "1.3.6.1.5.5.7.9.3", countryOfCitizenship: "1.3.6.1.5.5.7.9.4", countryOfResidence: "1.3.6.1.5.5.7.9.5", ecPublicKey: "1.2.840.10045.2.1", "P-256": "1.2.840.10045.3.1.7", secp256r1: "1.2.840.10045.3.1.7", secp256k1: "1.3.132.0.10", secp384r1: "1.3.132.0.34", pkcs5PBES2: "1.2.840.113549.1.5.13", pkcs5PBKDF2: "1.2.840.113549.1.5.12", "des-EDE3-CBC": "1.2.840.113549.3.7", data: "1.2.840.113549.1.7.1", "signed-data": "1.2.840.113549.1.7.2", "enveloped-data": "1.2.840.113549.1.7.3", "digested-data": "1.2.840.113549.1.7.5", "encrypted-data": "1.2.840.113549.1.7.6", "authenticated-data": "1.2.840.113549.1.9.16.1.2", tstinfo: "1.2.840.113549.1.9.16.1.4", signingCertificate: "1.2.840.113549.1.9.16.2.12", timeStampToken: "1.2.840.113549.1.9.16.2.14", signaturePolicyIdentifier: "1.2.840.113549.1.9.16.2.15", etsArchiveTimeStamp: "1.2.840.113549.1.9.16.2.27", signingCertificateV2: "1.2.840.113549.1.9.16.2.47", etsArchiveTimeStampV2: "1.2.840.113549.1.9.16.2.48", extensionRequest: "1.2.840.113549.1.9.14", contentType: "1.2.840.113549.1.9.3", messageDigest: "1.2.840.113549.1.9.4", signingTime: "1.2.840.113549.1.9.5", counterSignature: "1.2.840.113549.1.9.6", archiveTimeStampV3: "0.4.0.1733.2.4", pdfRevocationInfoArchival: "1.2.840.113583.1.1.8", adobeTimeStamp: "1.2.840.113583.1.1.9.1" };
      this.objCache = {};
      this.name2obj = function(b) {
        if (typeof this.objCache[b] != "undefined") {
          return this.objCache[b];
        }
        if (typeof this.name2oidList[b] == "undefined") {
          throw "Name of ObjectIdentifier not defined: " + b;
        }
        var c = this.name2oidList[b];
        var d = new KJUR.asn1.DERObjectIdentifier({ oid: c });
        this.objCache[b] = d;
        return d;
      };
      this.atype2obj = function(b) {
        if (this.objCache[b] !== void 0) {
          return this.objCache[b];
        }
        var c;
        if (b.match(/^\d+\.\d+\.[0-9.]+$/)) {
          c = b;
        } else {
          if (this.atype2oidList[b] !== void 0) {
            c = this.atype2oidList[b];
          } else {
            if (this.name2oidList[b] !== void 0) {
              c = this.name2oidList[b];
            } else {
              throw "AttributeType name undefined: " + b;
            }
          }
        }
        var d = new KJUR.asn1.DERObjectIdentifier({ oid: c });
        this.objCache[b] = d;
        return d;
      };
    }();
    KJUR.asn1.x509.OID.oid2name = function(b) {
      var c = KJUR.asn1.x509.OID.name2oidList;
      for (var a in c) {
        if (c[a] == b) {
          return a;
        }
      }
      return "";
    };
    KJUR.asn1.x509.OID.oid2atype = function(b) {
      var c = KJUR.asn1.x509.OID.atype2oidList;
      for (var a in c) {
        if (c[a] == b) {
          return a;
        }
      }
      return b;
    };
    KJUR.asn1.x509.OID.name2oid = function(a) {
      if (a.match(/^[0-9.]+$/)) {
        return a;
      }
      var b = KJUR.asn1.x509.OID.name2oidList;
      if (b[a] === void 0) {
        return "";
      }
      return b[a];
    };
    KJUR.asn1.x509.X509Util = {};
    KJUR.asn1.x509.X509Util.newCertPEM = function(e) {
      var d = KJUR.asn1.x509, b = d.TBSCertificate, a = d.Certificate;
      var c = new a(e);
      return c.getPEM();
    };
    if (typeof KJUR == "undefined" || !KJUR) {
      KJUR = {};
    }
    if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) {
      KJUR.asn1 = {};
    }
    if (typeof KJUR.asn1.cms == "undefined" || !KJUR.asn1.cms) {
      KJUR.asn1.cms = {};
    }
    KJUR.asn1.cms.Attribute = function(f) {
      var e = Error, d = KJUR, c = d.asn1, b = c.DERSequence, a = c.DERSet, g = c.DERObjectIdentifier;
      this.params = null;
      this.typeOid = null;
      this.setByParam = function(h) {
        this.params = h;
      };
      this.getValueArray = function() {
        throw new e("not yet implemented abstract");
      };
      this.getEncodedHex = function() {
        var j = new g({ oid: this.typeOid });
        var h = new a({ array: this.getValueArray() });
        var i = new b({ array: [j, h] });
        return i.getEncodedHex();
      };
    };
    extendClass(KJUR.asn1.cms.Attribute, KJUR.asn1.ASN1Object);
    KJUR.asn1.cms.ContentType = function(c) {
      var b = KJUR, a = b.asn1;
      a.cms.ContentType.superclass.constructor.call(this);
      this.typeOid = "1.2.840.113549.1.9.3";
      this.getValueArray = function() {
        var d = new a.DERObjectIdentifier(this.params.type);
        return [d];
      };
      if (c != void 0) {
        this.setByParam(c);
      }
    };
    extendClass(KJUR.asn1.cms.ContentType, KJUR.asn1.cms.Attribute);
    KJUR.asn1.cms.MessageDigest = function(e) {
      var b = KJUR, a = b.asn1, c = a.DEROctetString, d = a.cms;
      d.MessageDigest.superclass.constructor.call(this);
      this.typeOid = "1.2.840.113549.1.9.4";
      this.getValueArray = function() {
        var f = new c(this.params);
        return [f];
      };
      if (e != void 0) {
        this.setByParam(e);
      }
    };
    extendClass(KJUR.asn1.cms.MessageDigest, KJUR.asn1.cms.Attribute);
    KJUR.asn1.cms.SigningTime = function(c) {
      var b = KJUR, a = b.asn1;
      a.cms.SigningTime.superclass.constructor.call(this);
      this.typeOid = "1.2.840.113549.1.9.5";
      this.getValueArray = function() {
        var d = new a.x509.Time(this.params);
        return [d];
      };
      if (c != void 0) {
        this.setByParam(c);
      }
    };
    extendClass(KJUR.asn1.cms.SigningTime, KJUR.asn1.cms.Attribute);
    KJUR.asn1.cms.SigningCertificate = function(h) {
      var e = Error, d = KJUR, c = d.asn1, b = c.DERSequence, g = c.cms, a = g.ESSCertID, f = d.crypto;
      g.SigningCertificate.superclass.constructor.call(this);
      this.typeOid = "1.2.840.113549.1.9.16.2.12";
      this.getValueArray = function() {
        if (this.params == null || this.params == void 0 || this.params.array == void 0) {
          throw new e("parameter 'array' not specified");
        }
        var o = this.params.array;
        var k = [];
        for (var l = 0; l < o.length; l++) {
          var n = o[l];
          if (h.hasis == false && (typeof n == "string" && (n.indexOf("-----BEGIN") != -1 || ASN1HEX.isASN1HEX(n)))) {
            n = { cert: n };
          }
          if (n.hasis != false && h.hasis == false) {
            n.hasis = false;
          }
          k.push(new a(n));
        }
        var j = new b({ array: k });
        var m = new b({ array: [j] });
        return [m];
      };
      if (h != void 0) {
        this.setByParam(h);
      }
    };
    extendClass(KJUR.asn1.cms.SigningCertificate, KJUR.asn1.cms.Attribute);
    KJUR.asn1.cms.ESSCertID = function(g) {
      KJUR.asn1.cms.ESSCertID.superclass.constructor.call(this);
      var d = Error, c = KJUR, b = c.asn1, f = b.DEROctetString, a = b.DERSequence, e = b.cms.IssuerSerial;
      this.params = null;
      this.getCertHash = function(k, h) {
        if (k.hash != void 0) {
          return k.hash;
        }
        if (typeof k == "string" && k.indexOf("-----BEGIN") == -1 && !ASN1HEX.isASN1HEX(k)) {
          return k;
        }
        var i;
        if (typeof k == "string") {
          i = k;
        } else {
          if (k.cert != void 0) {
            i = k.cert;
          } else {
            throw new d("hash nor cert unspecified");
          }
        }
        var j;
        if (i.indexOf("-----BEGIN") != -1) {
          j = pemtohex(i);
        } else {
          j = i;
        }
        if (typeof k == "string") {
          if (k.indexOf("-----BEGIN") != -1) {
            j = pemtohex(k);
          } else {
            if (ASN1HEX.isASN1HEX(k)) {
              j = k;
            }
          }
        }
        var l;
        if (k.alg != void 0) {
          l = k.alg;
        } else {
          if (h != void 0) {
            l = h;
          } else {
            throw new d("hash alg unspecified");
          }
        }
        return c.crypto.Util.hashHex(j, l);
      };
      this.getEncodedHex = function() {
        var k = this.params;
        var j = this.getCertHash(k, "sha1");
        var h = [];
        h.push(new f({ hex: j }));
        if (typeof k == "string" && k.indexOf("-----BEGIN") != -1 || k.cert != void 0 && k.hasis != false || k.issuer != void 0 && k.serial != void 0) {
          h.push(new e(k));
        }
        var i = new a({ array: h });
        return i.getEncodedHex();
      };
      if (g != void 0) {
        this.setByParam(g);
      }
    };
    extendClass(KJUR.asn1.cms.ESSCertID, KJUR.asn1.ASN1Object);
    KJUR.asn1.cms.SigningCertificateV2 = function(d) {
      var h = Error, a = KJUR, g = a.asn1, e = g.DERSequence, b = g.x509, i = g.cms, c = i.ESSCertIDv2, f = a.crypto;
      i.SigningCertificateV2.superclass.constructor.call(this);
      this.typeOid = "1.2.840.113549.1.9.16.2.47";
      this.getValueArray = function() {
        if (this.params == null || this.params == void 0 || this.params.array == void 0) {
          throw new h("parameter 'array' not specified");
        }
        var o = this.params.array;
        var l = [];
        for (var m = 0; m < o.length; m++) {
          var n = o[m];
          if ((d.alg != void 0 || d.hasis == false) && (typeof n == "string" && (n.indexOf("-----BEGIN") != -1 || ASN1HEX.isASN1HEX(n)))) {
            n = { cert: n };
          }
          if (n.alg == void 0 && d.alg != void 0) {
            n.alg = d.alg;
          }
          if (n.hasis != false && d.hasis == false) {
            n.hasis = false;
          }
          l.push(new c(n));
        }
        var k = new e({ array: l });
        var j = new e({ array: [k] });
        return [j];
      };
      if (d != void 0) {
        this.setByParam(d);
      }
    };
    extendClass(KJUR.asn1.cms.SigningCertificateV2, KJUR.asn1.cms.Attribute);
    KJUR.asn1.cms.ESSCertIDv2 = function(h) {
      KJUR.asn1.cms.ESSCertIDv2.superclass.constructor.call(this);
      var d = Error, c = KJUR, b = c.asn1, f = b.DEROctetString, a = b.DERSequence, e = b.cms.IssuerSerial, g = b.x509.AlgorithmIdentifier;
      this.params = null;
      this.getEncodedHex = function() {
        var l = this.params;
        var k = this.getCertHash(l, "sha256");
        var i = [];
        if (l.alg != void 0 && l.alg != "sha256") {
          i.push(new g({ name: l.alg }));
        }
        i.push(new f({ hex: k }));
        if (typeof l == "string" && l.indexOf("-----BEGIN") != -1 || l.cert != void 0 && l.hasis != false || l.issuer != void 0 && l.serial != void 0) {
          i.push(new e(l));
        }
        var j = new a({ array: i });
        return j.getEncodedHex();
      };
      if (h != void 0) {
        this.setByParam(h);
      }
    };
    extendClass(KJUR.asn1.cms.ESSCertIDv2, KJUR.asn1.cms.ESSCertID);
    KJUR.asn1.cms.IssuerSerial = function(e) {
      var i = Error, c = KJUR, h = c.asn1, g = h.DERInteger, f = h.DERSequence, j = h.cms, d = h.x509, a = d.GeneralNames, b = X509;
      j.IssuerSerial.superclass.constructor.call(this);
      this.setByParam = function(k) {
        this.params = k;
      };
      this.getEncodedHex = function() {
        var p = this.params;
        var l, r;
        if (typeof p == "string" && p.indexOf("-----BEGIN") != -1 || p.cert != void 0) {
          var n;
          if (p.cert != void 0) {
            n = p.cert;
          } else {
            n = p;
          }
          var k = new b();
          k.readCertPEM(n);
          l = k.getIssuer();
          r = { hex: k.getSerialNumberHex() };
        } else {
          if (p.issuer != void 0 && p.serial) {
            l = p.issuer;
            r = p.serial;
          } else {
            throw new i("cert or issuer and serial parameter not specified");
          }
        }
        var q = new a([{ dn: l }]);
        var o = new g(r);
        var m = new f({ array: [q, o] });
        return m.getEncodedHex();
      };
      if (e != void 0) {
        this.setByParam(e);
      }
    };
    extendClass(KJUR.asn1.cms.IssuerSerial, KJUR.asn1.ASN1Object);
    KJUR.asn1.cms.SignerIdentifier = function(f) {
      var c = KJUR, i = c.asn1, h = i.DERInteger, g = i.DERSequence, l = i.cms, k = l.IssuerAndSerialNumber, d = l.SubjectKeyIdentifier, e = i.x509, a = e.X500Name, b = X509, j = Error;
      l.SignerIdentifier.superclass.constructor.call(this);
      this.params = null;
      this.getEncodedHex = function() {
        var o = this.params;
        if (o.type == "isssn") {
          var m = new k(o);
          return m.getEncodedHex();
        } else {
          if (o.type == "skid") {
            var n = new d(o);
            return n.getEncodedHex();
          } else {
            throw new Error("wrong property for isssn or skid");
          }
        }
      };
      if (f != void 0) {
        this.setByParam(f);
      }
    };
    extendClass(KJUR.asn1.cms.SignerIdentifier, KJUR.asn1.ASN1Object);
    KJUR.asn1.cms.IssuerAndSerialNumber = function(e) {
      var c = KJUR, h = c.asn1, g = h.DERInteger, f = h.DERSequence, j = h.cms, d = h.x509, a = d.X500Name, b = X509, i = Error;
      j.IssuerAndSerialNumber.superclass.constructor.call(this);
      this.params = null;
      this.getEncodedHex = function() {
        var p = this.params;
        var l, r;
        if (typeof p == "string" && p.indexOf("-----BEGIN") != -1 || p.cert != void 0) {
          var n;
          if (p.cert != void 0) {
            n = p.cert;
          } else {
            n = p;
          }
          var k = new b();
          k.readCertPEM(n);
          l = k.getIssuer();
          r = { hex: k.getSerialNumberHex() };
        } else {
          if (p.issuer != void 0 && p.serial) {
            l = p.issuer;
            r = p.serial;
          } else {
            throw new i("cert or issuer and serial parameter not specified");
          }
        }
        var q = new a(l);
        var o = new g(r);
        var m = new f({ array: [q, o] });
        return m.getEncodedHex();
      };
      this.setByParam = function(k) {
        this.params = k;
      };
      if (e != void 0) {
        this.setByParam(e);
      }
    };
    extendClass(KJUR.asn1.cms.IssuerAndSerialNumber, KJUR.asn1.ASN1Object);
    KJUR.asn1.cms.SubjectKeyIdentifier = function(g) {
      var d = KJUR, k = d.asn1, i = k.DERInteger, h = k.DERSequence, j = k.ASN1Util.newObject, m = k.cms, f = m.IssuerAndSerialName, c = m.SubjectKeyIdentifier, e = k.x509, a = e.X500Name, b = X509, l = Error;
      m.SubjectKeyIdentifier.superclass.constructor.call(this);
      this.getEncodedHex = function() {
        var r = this.params;
        if (r.cert == void 0 && r.skid == void 0) {
          throw new l("property cert nor skid undefined");
        }
        var q;
        if (r.cert != void 0) {
          var n = new b(r.cert);
          var o = n.getExtSubjectKeyIdentifier();
          q = o.kid.hex;
        } else {
          if (r.skid != void 0) {
            q = r.skid;
          }
        }
        var p = j({ tag: { tage: "a0", obj: { octstr: { hex: q } } } });
        return p.getEncodedHex();
      };
      if (g != void 0) {
        this.setByParam(g);
      }
    };
    extendClass(KJUR.asn1.cms.SubjectKeyIdentifier, KJUR.asn1.ASN1Object);
    KJUR.asn1.cms.AttributeList = function(f) {
      var d = Error, c = KJUR, b = c.asn1, a = b.DERSet, e = b.cms;
      e.AttributeList.superclass.constructor.call(this);
      this.params = null;
      this.hTLV = null;
      this.setByParam = function(g) {
        this.params = g;
      };
      this.getEncodedHex = function() {
        var o = this.params;
        if (this.hTLV != null) {
          return this.hTLV;
        }
        var m = true;
        if (o.sortflag != void 0) {
          m = o.sortflag;
        }
        var j = o.array;
        var g = [];
        for (var l = 0; l < j.length; l++) {
          var n = j[l];
          var k = n.attr;
          if (k == "contentType") {
            g.push(new e.ContentType(n));
          } else {
            if (k == "messageDigest") {
              g.push(new e.MessageDigest(n));
            } else {
              if (k == "signingTime") {
                g.push(new e.SigningTime(n));
              } else {
                if (k == "signingCertificate") {
                  g.push(new e.SigningCertificate(n));
                } else {
                  if (k == "signingCertificateV2") {
                    g.push(new e.SigningCertificateV2(n));
                  } else {
                    if (k == "signaturePolicyIdentifier") {
                      g.push(new KJUR.asn1.cades.SignaturePolicyIdentifier(n));
                    } else {
                      if (k == "signatureTimeStamp" || k == "timeStampToken") {
                        g.push(new KJUR.asn1.cades.SignatureTimeStamp(n));
                      } else {
                        throw new d("unknown attr: " + k);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        var h = new a({ array: g, sortflag: m });
        this.hTLV = h.getEncodedHex();
        return this.hTLV;
      };
      if (f != void 0) {
        this.setByParam(f);
      }
    };
    extendClass(KJUR.asn1.cms.AttributeList, KJUR.asn1.ASN1Object);
    KJUR.asn1.cms.SignerInfo = function(q) {
      var n = Error, r = KJUR, i = r.asn1, c = i.DERInteger, f = i.DEROctetString, h = i.DERSequence, m = i.DERTaggedObject, k = i.cms, p = k.SignerIdentifier, l = k.AttributeList, g = k.ContentType, e = k.EncapsulatedContentInfo, d = k.MessageDigest, j = k.SignedData, a = i.x509, s = a.AlgorithmIdentifier, b = r.crypto, o = KEYUTIL;
      k.SignerInfo.superclass.constructor.call(this);
      this.params = null;
      this.sign = function() {
        var y = this.params;
        var x = y.sigalg;
        var u = new l(y.sattrs).getEncodedHex();
        var v = o.getKey(y.signkey);
        var w = new b.Signature({ alg: x });
        w.init(v);
        w.updateHex(u);
        var t2 = w.sign();
        y.sighex = t2;
      };
      this.getEncodedHex = function() {
        var w = this.params;
        var t2 = [];
        t2.push(new c({ "int": w.version }));
        t2.push(new p(w.id));
        t2.push(new s({ name: w.hashalg }));
        if (w.sattrs != void 0) {
          var x = new l(w.sattrs);
          try {
            t2.push(new m({ tag: "a0", explicit: false, obj: x }));
          } catch (v) {
            throw new n("si sattr error: " + v);
          }
        }
        if (w.sigalgfield != void 0) {
          t2.push(new s({ name: w.sigalgfield }));
        } else {
          t2.push(new s({ name: w.sigalg }));
        }
        if (w.sighex == void 0 && w.signkey != void 0) {
          this.sign();
        }
        t2.push(new f({ hex: w.sighex }));
        if (w.uattrs != void 0) {
          var x = new l(w.uattrs);
          try {
            t2.push(new m({ tag: "a1", explicit: false, obj: x }));
          } catch (v) {
            throw new n("si uattr error: " + v);
          }
        }
        var u = new h({ array: t2 });
        return u.getEncodedHex();
      };
      if (q != void 0) {
        this.setByParam(q);
      }
    };
    extendClass(KJUR.asn1.cms.SignerInfo, KJUR.asn1.ASN1Object);
    KJUR.asn1.cms.EncapsulatedContentInfo = function(g) {
      var c = KJUR, b = c.asn1, e = b.DERTaggedObject, a = b.DERSequence, h = b.DERObjectIdentifier, d = b.DEROctetString, f = b.cms;
      f.EncapsulatedContentInfo.superclass.constructor.call(this);
      this.params = null;
      this.getEncodedHex = function() {
        var m = this.params;
        var i = [];
        i.push(new h(m.type));
        if (m.content != void 0 && (m.content.hex != void 0 || m.content.str != void 0) && m.isDetached != true) {
          var k = new d(m.content);
          var l = new e({ tag: "a0", explicit: true, obj: k });
          i.push(l);
        }
        var j = new a({ array: i });
        return j.getEncodedHex();
      };
      this.setByParam = function(i) {
        this.params = i;
      };
      if (g != void 0) {
        this.setByParam(g);
      }
    };
    extendClass(KJUR.asn1.cms.EncapsulatedContentInfo, KJUR.asn1.ASN1Object);
    KJUR.asn1.cms.ContentInfo = function(g) {
      var c = KJUR, b = c.asn1, d = b.DERTaggedObject, a = b.DERSequence, h = b.DERObjectIdentifier, f = b.x509, e = f.OID.name2obj;
      KJUR.asn1.cms.ContentInfo.superclass.constructor.call(this);
      this.params = null;
      this.getEncodedHex = function() {
        var l = this.params;
        var i = [];
        i.push(new h(l.type));
        var k = new d({ tag: "a0", explicit: true, obj: l.obj });
        i.push(k);
        var j = new a({ array: i });
        return j.getEncodedHex();
      };
      this.setByParam = function(i) {
        this.params = i;
      };
      if (g != void 0) {
        this.setByParam(g);
      }
    };
    extendClass(KJUR.asn1.cms.ContentInfo, KJUR.asn1.ASN1Object);
    KJUR.asn1.cms.SignedData = function(e) {
      var j = Error, a = KJUR, h = a.asn1, m = h.ASN1Object, g = h.DERInteger, p = h.DERSet, f = h.DERSequence, b = h.DERTaggedObject, o = h.cms, l = o.EncapsulatedContentInfo, d = o.SignerInfo, q = o.ContentInfo, k = o.CertificateSet, i = o.RevocationInfoChoices, c = h.x509, n = c.AlgorithmIdentifier;
      KJUR.asn1.cms.SignedData.superclass.constructor.call(this);
      this.params = null;
      this.checkAndFixParam = function() {
        var r = this.params;
        this._setDigestAlgs(r);
        this._setContentTypeByEContent(r);
        this._setMessageDigestByEContent(r);
        this._setSignerInfoVersion(r);
        this._setSignedDataVersion(r);
      };
      this._setDigestAlgs = function(v) {
        var u = {};
        var t2 = v.sinfos;
        for (var r = 0; r < t2.length; r++) {
          var s = t2[r];
          u[s.hashalg] = 1;
        }
        v.hashalgs = Object.keys(u).sort();
      };
      this._setContentTypeByEContent = function(w) {
        var u = w.econtent.type;
        var v = w.sinfos;
        for (var r = 0; r < v.length; r++) {
          var t2 = v[r];
          var s = this._getAttrParamByName(t2, "contentType");
          s.type = u;
        }
      };
      this._setMessageDigestByEContent = function(r) {
        var v = r.econtent;
        var y = r.econtent.type;
        var x = v.content.hex;
        if (x == void 0 && v.type == "data" && v.content.str != void 0) {
          x = rstrtohex(v.content.str);
        }
        var A = r.sinfos;
        for (var u = 0; u < A.length; u++) {
          var t2 = A[u];
          var s = t2.hashalg;
          var z2 = this._getAttrParamByName(t2, "messageDigest");
          var w = KJUR.crypto.Util.hashHex(x, s);
          z2.hex = w;
        }
      };
      this._getAttrParamByName = function(t2, s) {
        var u = t2.sattrs.array;
        for (var r = 0; r < u.length; r++) {
          if (u[r].attr == s) {
            return u[r];
          }
        }
      };
      this._setSignerInfoVersion = function(v) {
        var t2 = v.sinfos;
        for (var r = 0; r < t2.length; r++) {
          var s = t2[r];
          var u = 1;
          if (s.id.type == "skid") {
            u = 3;
          }
          s.version = u;
        }
      };
      this._setSignedDataVersion = function(s) {
        var r = this._getSignedDataVersion(s);
        s.version = r;
      };
      this._getSignedDataVersion = function(w) {
        if (w.revinfos != void 0) {
          var r = w.revinfos;
          for (var t2 = 0; t2 < r.length; t2++) {
            var s = r[t2];
            if (s.ocsp != void 0) {
              return 5;
            }
          }
        }
        var v = w.sinfos;
        for (var t2 = 0; t2 < v.length; t2++) {
          var u = w.sinfos[t2];
          if (u.version == 3) {
            return 3;
          }
        }
        if (w.econtent.type != "data") {
          return 3;
        }
        return 1;
      };
      this.getEncodedHex = function() {
        var y = this.params;
        if (this.getEncodedHexPrepare != void 0) {
          this.getEncodedHexPrepare();
        }
        if (y.fixed != true) {
          this.checkAndFixParam();
        }
        var r = [];
        r.push(new g({ "int": y.version }));
        var w = [];
        for (var v = 0; v < y.hashalgs.length; v++) {
          var t2 = y.hashalgs[v];
          w.push(new n({ name: t2 }));
        }
        r.push(new p({ array: w }));
        r.push(new l(y.econtent));
        if (y.certs != void 0) {
          r.push(new k(y.certs));
        }
        if (y.revinfos != void 0) {
          r.push(new i(y.revinfos));
        }
        var u = [];
        for (var v = 0; v < y.sinfos.length; v++) {
          var x = y.sinfos[v];
          u.push(new d(x));
        }
        r.push(new p({ array: u }));
        var s = new f({ array: r });
        return s.getEncodedHex();
      };
      this.getContentInfo = function() {
        var r = new q({ type: "signed-data", obj: this });
        return r;
      };
      this.getContentInfoEncodedHex = function() {
        return this.getContentInfo().getEncodedHex();
      };
      if (e != void 0) {
        this.setByParam(e);
      }
    };
    extendClass(KJUR.asn1.cms.SignedData, KJUR.asn1.ASN1Object);
    KJUR.asn1.cms.CertificateSet = function(f) {
      KJUR.asn1.cms.CertificateSet.superclass.constructor.call(this);
      var c = Error, b = KJUR.asn1, e = b.DERTaggedObject, a = b.DERSet, d = b.ASN1Object;
      this.params = null;
      this.getEncodedHex = function() {
        var j = this.params;
        var p = [];
        var q;
        if (j instanceof Array) {
          q = j;
        } else {
          if (j.array != void 0) {
            q = j.array;
          } else {
            throw new c("cert array not specified");
          }
        }
        for (var k = 0; k < q.length; k++) {
          var l = q[k];
          var n = pemtohex(l);
          var g = new d();
          g.hTLV = n;
          p.push(g);
        }
        var m = { array: p };
        if (j.sortflag == false) {
          m.sortflag = false;
        }
        var o = new a(m);
        var h = new e({ tag: "a0", explicit: false, obj: o });
        return h.getEncodedHex();
      };
      if (f != void 0) {
        this.setByParam(f);
      }
    };
    extendClass(KJUR.asn1.cms.CertificateSet, KJUR.asn1.ASN1Object);
    KJUR.asn1.cms.RevocationInfoChoices = function(a) {
      KJUR.asn1.cms.RevocationInfoChoices.superclass.constructor.call(this);
      this.params = null;
      this.getEncodedHex = function() {
        var e = this.params;
        if (!e instanceof Array) {
          throw new Error("params is not array");
        }
        var b = [];
        for (var c = 0; c < e.length; c++) {
          b.push(new KJUR.asn1.cms.RevocationInfoChoice(e[c]));
        }
        var d = KJUR.asn1.ASN1Util.newObject({ tag: { tagi: "a1", obj: { set: b } } });
        return d.getEncodedHex();
      };
      if (a != void 0) {
        this.setByParam(a);
      }
    };
    extendClass(KJUR.asn1.cms.RevocationInfoChoices, KJUR.asn1.ASN1Object);
    KJUR.asn1.cms.RevocationInfoChoice = function(a) {
      KJUR.asn1.cms.RevocationInfoChoice.superclass.constructor.call(this);
      this.params = null;
      this.getEncodedHex = function() {
        var d = this.params;
        if (d.crl != void 0 && typeof d.crl == "string") {
          var b = d.crl;
          if (d.crl.indexOf("-----BEGIN") != -1) {
            b = pemtohex(d.crl);
          }
          return b;
        } else {
          if (d.ocsp != void 0) {
            var c = KJUR.asn1.ASN1Util.newObject({ tag: { tagi: "a1", obj: new KJUR.asn1.cms.OtherRevocationFormat(d) } });
            return c.getEncodedHex();
          } else {
            throw new Error("property crl or ocsp undefined");
          }
        }
      };
      if (a != void 0) {
        this.setByParam(a);
      }
    };
    extendClass(KJUR.asn1.cms.RevocationInfoChoice, KJUR.asn1.ASN1Object);
    KJUR.asn1.cms.OtherRevocationFormat = function(f) {
      KJUR.asn1.cms.OtherRevocationFormat.superclass.constructor.call(this);
      var d = Error, c = KJUR, b = c.asn1, a = b.ASN1Util.newObject, e = c.lang.String.isHex;
      this.params = null;
      this.getEncodedHex = function() {
        var h = this.params;
        if (h.ocsp == void 0) {
          throw new d("property ocsp not specified");
        }
        if (!e(h.ocsp) || !ASN1HEX.isASN1HEX(h.ocsp)) {
          throw new d("ocsp value not ASN.1 hex string");
        }
        var g = a({ seq: [{ oid: "1.3.6.1.5.5.7.16.2" }, { asn1: { tlv: h.ocsp } }] });
        return g.getEncodedHex();
      };
      if (f != void 0) {
        this.setByParam(f);
      }
    };
    extendClass(KJUR.asn1.cms.OtherRevocationFormat, KJUR.asn1.ASN1Object);
    KJUR.asn1.cms.CMSUtil = new function() {
    }();
    KJUR.asn1.cms.CMSUtil.newSignedData = function(a) {
      return new KJUR.asn1.cms.SignedData(a);
    };
    KJUR.asn1.cms.CMSUtil.verifySignedData = function(n) {
      var C = KJUR, p = C.asn1, s = p.cms, D = s.SignerInfo, q = s.SignedData, y = s.SigningTime, b = s.SigningCertificate, d = s.SigningCertificateV2, A = p.cades, u = A.SignaturePolicyIdentifier, i = C.lang.String.isHex, v = ASN1HEX, h = v.getVbyList, a = v.getTLVbyList, t2 = v.getIdxbyList, z2 = v.getChildIdx, c = v.getTLV, B = v.oidname, j = C.crypto.Util.hashHex;
      if (n.cms === void 0 && !i(n.cms)) {
      }
      var E = n.cms;
      var g = function(J, H) {
        var G;
        for (var I = 3; I < 6; I++) {
          G = t2(J, 0, [1, 0, I]);
          if (G !== void 0) {
            var F = J.substr(G, 2);
            if (F === "a0") {
              H.certsIdx = G;
            }
            if (F === "a1") {
              H.revinfosIdx = G;
            }
            if (F === "31") {
              H.signerinfosIdx = G;
            }
          }
        }
      };
      var l = function(I, F) {
        var H = F.signerinfosIdx;
        if (H === void 0) {
          return;
        }
        var L = z2(I, H);
        F.signerInfoIdxList = L;
        for (var G = 0; G < L.length; G++) {
          var K = L[G];
          var J = { idx: K };
          k(I, J);
          F.signerInfos.push(J);
        }
      };
      var k = function(I, J) {
        var F = J.idx;
        J.signerid_issuer1 = a(I, F, [1, 0], "30");
        J.signerid_serial1 = h(I, F, [1, 1], "02");
        J.hashalg = B(h(I, F, [2, 0], "06"));
        var H = t2(I, F, [3], "a0");
        J.idxSignedAttrs = H;
        f(I, J, H);
        var G = z2(I, F);
        var K = G.length;
        if (K < 6) {
          throw "malformed SignerInfo";
        }
        J.sigalg = B(h(I, F, [K - 2, 0], "06"));
        J.sigval = h(I, F, [K - 1], "04");
      };
      var f = function(L, M, F) {
        var J = z2(L, F);
        M.signedAttrIdxList = J;
        for (var K = 0; K < J.length; K++) {
          var I = J[K];
          var G = h(L, I, [0], "06");
          var H;
          if (G === "2a864886f70d010905") {
            H = hextoutf8(h(L, I, [1, 0]));
            M.saSigningTime = H;
          } else {
            if (G === "2a864886f70d010904") {
              H = h(L, I, [1, 0], "04");
              M.saMessageDigest = H;
            }
          }
        }
      };
      var w = function(G, F) {
        if (h(G, 0, [0], "06") !== "2a864886f70d010702") {
          return F;
        }
        F.cmsType = "signedData";
        F.econtent = h(G, 0, [1, 0, 2, 1, 0]);
        g(G, F);
        F.signerInfos = [];
        l(G, F);
      };
      var o = function(J, F) {
        var G = F.parse.signerInfos;
        var L = G.length;
        var K = true;
        for (var I = 0; I < L; I++) {
          var H = G[I];
          e(J, F, H, I);
          if (!H.isValid) {
            K = false;
          }
        }
        F.isValid = K;
      };
      var x = function(F, Q, J, P) {
        var N = Q.parse.certsIdx;
        var H;
        if (Q.certs === void 0) {
          H = [];
          Q.certkeys = [];
          var K = z2(F, N);
          for (var I = 0; I < K.length; I++) {
            var M = c(F, K[I]);
            var O = new X509();
            O.readCertHex(M);
            H[I] = O;
            Q.certkeys[I] = O.getPublicKey();
          }
          Q.certs = H;
        } else {
          H = Q.certs;
        }
        Q.cccc = H.length;
        Q.cccci = K.length;
        for (var I = 0; I < H.length; I++) {
          var L = O.getIssuerHex();
          var G = O.getSerialNumberHex();
          if (J.signerid_issuer1 === L && J.signerid_serial1 === G) {
            J.certkey_idx = I;
          }
        }
      };
      var e = function(F, R, I, N) {
        I.verifyDetail = {};
        var Q = I.verifyDetail;
        var K = R.parse.econtent;
        var G = I.hashalg;
        var L = I.saMessageDigest;
        Q.validMessageDigest = false;
        if (j(K, G) === L) {
          Q.validMessageDigest = true;
        }
        x(F, R, I, N);
        Q.validSignatureValue = false;
        var H = I.sigalg;
        var M = "31" + c(F, I.idxSignedAttrs).substr(2);
        I.signedattrshex = M;
        var J = R.certs[I.certkey_idx].getPublicKey();
        var P = new KJUR.crypto.Signature({ alg: H });
        P.init(J);
        P.updateHex(M);
        var O = P.verify(I.sigval);
        Q.validSignatureValue_isValid = O;
        if (O === true) {
          Q.validSignatureValue = true;
        }
        I.isValid = false;
        if (Q.validMessageDigest && Q.validSignatureValue) {
          I.isValid = true;
        }
      };
      var m = function() {
      };
      var r = { isValid: false, parse: {} };
      w(E, r.parse);
      o(E, r);
      return r;
    };
    KJUR.asn1.cms.CMSParser = function() {
      var g = Error, a = X509, h = new a(), l = ASN1HEX, i = l.getV, b = l.getTLV, f = l.getIdxbyList, c = l.getTLVbyList, d = l.getTLVbyListEx, e = l.getVbyList, k = l.getVbyListEx, j = l.getChildIdx;
      this.getCMSSignedData = function(m) {
        var o = c(m, 0, [1, 0]);
        var n = this.getSignedData(o);
        return n;
      };
      this.getSignedData = function(o) {
        var q = j(o, 0);
        var v = {};
        var p = i(o, q[0]);
        var n = parseInt(p, 16);
        v.version = n;
        var r = b(o, q[1]);
        v.hashalgs = this.getHashAlgArray(r);
        var t2 = b(o, q[2]);
        v.econtent = this.getEContent(t2);
        var m = d(o, 0, ["[0]"]);
        if (m != null) {
          v.certs = this.getCertificateSet(m);
        }
        var u = d(o, 0, ["[1]"]);
        if (u != null) {
        }
        var s = d(o, 0, [3]);
        v.sinfos = this.getSignerInfos(s);
        return v;
      };
      this.getHashAlgArray = function(s) {
        var q = j(s, 0);
        var m = new a();
        var n = [];
        for (var r = 0; r < q.length; r++) {
          var p = b(s, q[r]);
          var o = m.getAlgorithmIdentifierName(p);
          n.push(o);
        }
        return n;
      };
      this.getEContent = function(m) {
        var n = {};
        var p = e(m, 0, [0]);
        var o = e(m, 0, [1, 0]);
        n.type = KJUR.asn1.x509.OID.oid2name(ASN1HEX.hextooidstr(p));
        n.content = { hex: o };
        return n;
      };
      this.getSignerInfos = function(p) {
        var r = [];
        var m = j(p, 0);
        for (var n = 0; n < m.length; n++) {
          var o = b(p, m[n]);
          var q = this.getSignerInfo(o);
          r.push(q);
        }
        return r;
      };
      this.getSignerInfo = function(s) {
        var y = {};
        var u = j(s, 0);
        var q = l.getInt(s, u[0], -1);
        if (q != -1) {
          y.version = q;
        }
        var t2 = b(s, u[1]);
        var p = this.getIssuerAndSerialNumber(t2);
        y.id = p;
        var z2 = b(s, u[2]);
        var n = h.getAlgorithmIdentifierName(z2);
        y.hashalg = n;
        var w = d(s, 0, ["[0]"]);
        if (w != null) {
          var A = this.getAttributeList(w);
          y.sattrs = A;
        }
        var m = d(s, 0, [3]);
        var x = h.getAlgorithmIdentifierName(m);
        y.sigalg = x;
        var o = k(s, 0, [4]);
        y.sighex = o;
        var r = d(s, 0, ["[1]"]);
        if (r != null) {
          var v = this.getAttributeList(r);
          y.uattrs = v;
        }
        return y;
      };
      this.getSignerIdentifier = function(m) {
        if (m.substr(0, 2) == "30") {
          return this.getIssuerAndSerialNumber(m);
        } else {
          throw new Error("SKID of signerIdentifier not supported");
        }
      };
      this.getIssuerAndSerialNumber = function(n) {
        var o = { type: "isssn" };
        var m = j(n, 0);
        var p = b(n, m[0]);
        o.issuer = h.getX500Name(p);
        var q = i(n, m[1]);
        o.serial = { hex: q };
        return o;
      };
      this.getAttributeList = function(q) {
        var m = [];
        var n = j(q, 0);
        for (var o = 0; o < n.length; o++) {
          var p = b(q, n[o]);
          var r = this.getAttribute(p);
          m.push(r);
        }
        return { array: m };
      };
      this.getAttribute = function(p) {
        var t2 = {};
        var q = j(p, 0);
        var o = l.getOID(p, q[0]);
        var m = KJUR.asn1.x509.OID.oid2name(o);
        t2.attr = m;
        var r = b(p, q[1]);
        var u = j(r, 0);
        if (u.length == 1) {
          t2.valhex = b(r, u[0]);
        } else {
          var s = [];
          for (var n = 0; n < u.length; n++) {
            s.push(b(r, u[n]));
          }
          t2.valhex = s;
        }
        if (m == "contentType") {
          this.setContentType(t2);
        } else {
          if (m == "messageDigest") {
            this.setMessageDigest(t2);
          } else {
            if (m == "signingTime") {
              this.setSigningTime(t2);
            } else {
              if (m == "signingCertificate") {
                this.setSigningCertificate(t2);
              } else {
                if (m == "signingCertificateV2") {
                  this.setSigningCertificateV2(t2);
                } else {
                  if (m == "signaturePolicyIdentifier") {
                    this.setSignaturePolicyIdentifier(t2);
                  }
                }
              }
            }
          }
        }
        return t2;
      };
      this.setContentType = function(m) {
        var n = l.getOIDName(m.valhex, 0, null);
        if (n != null) {
          m.type = n;
          delete m.valhex;
        }
      };
      this.setSigningTime = function(o) {
        var n = i(o.valhex, 0);
        var m = hextoutf8(n);
        o.str = m;
        delete o.valhex;
      };
      this.setMessageDigest = function(m) {
        var n = i(m.valhex, 0);
        m.hex = n;
        delete m.valhex;
      };
      this.setSigningCertificate = function(n) {
        var q = j(n.valhex, 0);
        if (q.length > 0) {
          var m = b(n.valhex, q[0]);
          var p = j(m, 0);
          var t2 = [];
          for (var o = 0; o < p.length; o++) {
            var s = b(m, p[o]);
            var u = this.getESSCertID(s);
            t2.push(u);
          }
          n.array = t2;
        }
        if (q.length > 1) {
          var r = b(n.valhex, q[1]);
          n.polhex = r;
        }
        delete n.valhex;
      };
      this.setSignaturePolicyIdentifier = function(s) {
        var q = j(s.valhex, 0);
        if (q.length > 0) {
          var r = l.getOID(s.valhex, q[0]);
          s.oid = r;
        }
        if (q.length > 1) {
          var m = new a();
          var t2 = j(s.valhex, q[1]);
          var p = b(s.valhex, t2[0]);
          var o = m.getAlgorithmIdentifierName(p);
          s.alg = o;
          var n = i(s.valhex, t2[1]);
          s.hash = n;
        }
        delete s.valhex;
      };
      this.setSigningCertificateV2 = function(o) {
        var s = j(o.valhex, 0);
        if (s.length > 0) {
          var n = b(o.valhex, s[0]);
          var r = j(n, 0);
          var u = [];
          for (var q = 0; q < r.length; q++) {
            var m = b(n, r[q]);
            var p = this.getESSCertIDv2(m);
            u.push(p);
          }
          o.array = u;
        }
        if (s.length > 1) {
          var t2 = b(o.valhex, s[1]);
          o.polhex = t2;
        }
        delete o.valhex;
      };
      this.getESSCertID = function(o) {
        var p = {};
        var n = j(o, 0);
        if (n.length > 0) {
          var q = i(o, n[0]);
          p.hash = q;
        }
        if (n.length > 1) {
          var m = b(o, n[1]);
          var r = this.getIssuerSerial(m);
          if (r.serial != void 0) {
            p.serial = r.serial;
          }
          if (r.issuer != void 0) {
            p.issuer = r.issuer;
          }
        }
        return p;
      };
      this.getESSCertIDv2 = function(q) {
        var s = {};
        var p = j(q, 0);
        if (p.length < 1 || 3 < p.length) {
          throw new g("wrong number of elements");
        }
        var r = 0;
        if (q.substr(p[0], 2) == "30") {
          var o = b(q, p[0]);
          s.alg = h.getAlgorithmIdentifierName(o);
          r++;
        } else {
          s.alg = "sha256";
        }
        var n = i(q, p[r]);
        s.hash = n;
        if (p.length > r + 1) {
          var m = b(q, p[r + 1]);
          var t2 = this.getIssuerSerial(m);
          s.issuer = t2.issuer;
          s.serial = t2.serial;
        }
        return s;
      };
      this.getIssuerSerial = function(q) {
        var r = {};
        var n = j(q, 0);
        var m = b(q, n[0]);
        var p = h.getGeneralNames(m);
        var o = p[0].dn;
        r.issuer = o;
        var s = i(q, n[1]);
        r.serial = { hex: s };
        return r;
      };
      this.getCertificateSet = function(p) {
        var n = j(p, 0);
        var m = [];
        for (var o = 0; o < n.length; o++) {
          var r = b(p, n[o]);
          if (r.substr(0, 2) == "30") {
            var q = hextopem(r, "CERTIFICATE");
            m.push(q);
          }
        }
        return { array: m, sortflag: false };
      };
    };
    if (typeof KJUR == "undefined" || !KJUR) {
      KJUR = {};
    }
    if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) {
      KJUR.asn1 = {};
    }
    if (typeof KJUR.asn1.tsp == "undefined" || !KJUR.asn1.tsp) {
      KJUR.asn1.tsp = {};
    }
    KJUR.asn1.tsp.TimeStampToken = function(d) {
      var c = KJUR, b = c.asn1, a = b.tsp;
      a.TimeStampToken.superclass.constructor.call(this);
      this.params = null;
      this.getEncodedHexPrepare = function() {
        var e = new a.TSTInfo(this.params.econtent.content);
        this.params.econtent.content.hex = e.getEncodedHex();
      };
      if (d != void 0) {
        this.setByParam(d);
      }
    };
    extendClass(KJUR.asn1.tsp.TimeStampToken, KJUR.asn1.cms.SignedData);
    KJUR.asn1.tsp.TSTInfo = function(f) {
      var m = Error, c = KJUR, j = c.asn1, g = j.DERSequence, i = j.DERInteger, l = j.DERBoolean, h = j.DERGeneralizedTime, n = j.DERObjectIdentifier, e = j.DERTaggedObject, k = j.tsp, d = k.MessageImprint, b = k.Accuracy, a = j.x509.X500Name, o = j.x509.GeneralName;
      k.TSTInfo.superclass.constructor.call(this);
      this.dVersion = new i({ "int": 1 });
      this.dPolicy = null;
      this.dMessageImprint = null;
      this.dSerial = null;
      this.dGenTime = null;
      this.dAccuracy = null;
      this.dOrdering = null;
      this.dNonce = null;
      this.dTsa = null;
      this.getEncodedHex = function() {
        var p = [this.dVersion];
        if (this.dPolicy == null) {
          throw new Error("policy shall be specified.");
        }
        p.push(this.dPolicy);
        if (this.dMessageImprint == null) {
          throw new Error("messageImprint shall be specified.");
        }
        p.push(this.dMessageImprint);
        if (this.dSerial == null) {
          throw new Error("serialNumber shall be specified.");
        }
        p.push(this.dSerial);
        if (this.dGenTime == null) {
          throw new Error("genTime shall be specified.");
        }
        p.push(this.dGenTime);
        if (this.dAccuracy != null) {
          p.push(this.dAccuracy);
        }
        if (this.dOrdering != null) {
          p.push(this.dOrdering);
        }
        if (this.dNonce != null) {
          p.push(this.dNonce);
        }
        if (this.dTsa != null) {
          p.push(this.dTsa);
        }
        var q = new g({ array: p });
        this.hTLV = q.getEncodedHex();
        return this.hTLV;
      };
      if (f !== void 0) {
        if (typeof f.policy == "string") {
          if (!f.policy.match(/^[0-9.]+$/)) {
            throw "policy shall be oid like 0.1.4.134";
          }
          this.dPolicy = new n({ oid: f.policy });
        }
        if (f.messageImprint !== void 0) {
          this.dMessageImprint = new d(f.messageImprint);
        }
        if (f.serial !== void 0) {
          this.dSerial = new i(f.serial);
        }
        if (f.genTime !== void 0) {
          this.dGenTime = new h(f.genTime);
        }
        if (f.accuracy !== void 0) {
          this.dAccuracy = new b(f.accuracy);
        }
        if (f.ordering !== void 0 && f.ordering == true) {
          this.dOrdering = new l();
        }
        if (f.nonce !== void 0) {
          this.dNonce = new i(f.nonce);
        }
        if (f.tsa !== void 0) {
          this.dTsa = new e({ tag: "a0", explicit: true, obj: new o({ dn: f.tsa }) });
        }
      }
    };
    extendClass(KJUR.asn1.tsp.TSTInfo, KJUR.asn1.ASN1Object);
    KJUR.asn1.tsp.Accuracy = function(d) {
      var c = KJUR, b = c.asn1, a = b.ASN1Util.newObject;
      b.tsp.Accuracy.superclass.constructor.call(this);
      this.params = null;
      this.getEncodedHex = function() {
        var f = this.params;
        var e = [];
        if (f.seconds != void 0 && typeof f.seconds == "number") {
          e.push({ "int": f.seconds });
        }
        if (f.millis != void 0 && typeof f.millis == "number") {
          e.push({ tag: { tagi: "80", obj: { "int": f.millis } } });
        }
        if (f.micros != void 0 && typeof f.micros == "number") {
          e.push({ tag: { tagi: "81", obj: { "int": f.micros } } });
        }
        return a({ seq: e }).getEncodedHex();
      };
      if (d != void 0) {
        this.setByParam(d);
      }
    };
    extendClass(KJUR.asn1.tsp.Accuracy, KJUR.asn1.ASN1Object);
    KJUR.asn1.tsp.MessageImprint = function(g) {
      var c = KJUR, b = c.asn1, a = b.DERSequence, d = b.DEROctetString, f = b.x509, e = f.AlgorithmIdentifier;
      b.tsp.MessageImprint.superclass.constructor.call(this);
      this.params = null;
      this.getEncodedHex = function() {
        var k = this.params;
        var j = new e({ name: k.alg });
        var h = new d({ hex: k.hash });
        var i = new a({ array: [j, h] });
        return i.getEncodedHex();
      };
      if (g !== void 0) {
        this.setByParam(g);
      }
    };
    extendClass(KJUR.asn1.tsp.MessageImprint, KJUR.asn1.ASN1Object);
    KJUR.asn1.tsp.TimeStampReq = function(c) {
      var a = KJUR, f = a.asn1, d = f.DERSequence, e = f.DERInteger, h = f.DERBoolean, j = f.ASN1Object, i = f.DERObjectIdentifier, g = f.tsp, b = g.MessageImprint;
      g.TimeStampReq.superclass.constructor.call(this);
      this.params = null;
      this.getEncodedHex = function() {
        var m = this.params;
        var k = [];
        k.push(new e({ "int": 1 }));
        if (m.messageImprint instanceof KJUR.asn1.ASN1Object) {
          k.push(m.messageImprint);
        } else {
          k.push(new b(m.messageImprint));
        }
        if (m.policy != void 0) {
          k.push(new i(m.policy));
        }
        if (m.nonce != void 0) {
          k.push(new e(m.nonce));
        }
        if (m.certreq == true) {
          k.push(new h());
        }
        var l = new d({ array: k });
        return l.getEncodedHex();
      };
      if (c != void 0) {
        this.setByParam(c);
      }
    };
    extendClass(KJUR.asn1.tsp.TimeStampReq, KJUR.asn1.ASN1Object);
    KJUR.asn1.tsp.TimeStampResp = function(g) {
      var e = KJUR, d = e.asn1, c = d.DERSequence, f = d.ASN1Object, a = d.tsp, b = a.PKIStatusInfo;
      a.TimeStampResp.superclass.constructor.call(this);
      this.params = null;
      this.getEncodedHex = function() {
        var j = this.params;
        var h = [new b(j.statusinfo)];
        if (j.econtent != void 0) {
          h.push(new a.TimeStampToken(j).getContentInfo());
        }
        if (j.tst != void 0 && j.tst instanceof d.ASN1Object) {
          h.push(j.tst);
        }
        var i = new c({ array: h });
        return i.getEncodedHex();
      };
      if (g != void 0) {
        this.setByParam(g);
      }
    };
    extendClass(KJUR.asn1.tsp.TimeStampResp, KJUR.asn1.ASN1Object);
    KJUR.asn1.tsp.PKIStatusInfo = function(d) {
      var h = Error, a = KJUR, g = a.asn1, e = g.DERSequence, i = g.tsp, f = i.PKIStatus, c = i.PKIFreeText, b = i.PKIFailureInfo;
      i.PKIStatusInfo.superclass.constructor.call(this);
      this.params = null;
      this.getEncodedHex = function() {
        var l = this.params;
        var j = [];
        if (typeof l == "string") {
          j.push(new f(l));
        } else {
          if (l.status == void 0) {
            throw new h("property 'status' unspecified");
          }
          j.push(new f(l.status));
          if (l.statusstr != void 0) {
            j.push(new c(l.statusstr));
          }
          if (l.failinfo != void 0) {
            j.push(new b(l.failinfo));
          }
        }
        var k = new e({ array: j });
        return k.getEncodedHex();
      };
      if (d != void 0) {
        this.setByParam(d);
      }
    };
    extendClass(KJUR.asn1.tsp.PKIStatusInfo, KJUR.asn1.ASN1Object);
    KJUR.asn1.tsp.PKIStatus = function(g) {
      var e = Error, d = KJUR, c = d.asn1, f = c.DERInteger, b = c.tsp;
      b.PKIStatus.superclass.constructor.call(this);
      var a = { granted: 0, grantedWithMods: 1, rejection: 2, waiting: 3, revocationWarning: 4, revocationNotification: 5 };
      this.params = null;
      this.getEncodedHex = function() {
        var k = this.params;
        var h, j;
        if (typeof k == "string") {
          try {
            j = a[k];
          } catch (i) {
            throw new e("undefined name: " + k);
          }
        } else {
          if (typeof k == "number") {
            j = k;
          } else {
            throw new e("unsupported params");
          }
        }
        return new f({ "int": j }).getEncodedHex();
      };
      if (g != void 0) {
        this.setByParam(g);
      }
    };
    extendClass(KJUR.asn1.tsp.PKIStatus, KJUR.asn1.ASN1Object);
    KJUR.asn1.tsp.PKIFreeText = function(g) {
      var f = Error, e = KJUR, d = e.asn1, b = d.DERSequence, c = d.DERUTF8String, a = d.tsp;
      a.PKIFreeText.superclass.constructor.call(this);
      this.params = null;
      this.getEncodedHex = function() {
        var l = this.params;
        if (!l instanceof Array) {
          throw new f("wrong params: not array");
        }
        var h = [];
        for (var k = 0; k < l.length; k++) {
          h.push(new c({ str: l[k] }));
        }
        var j = new b({ array: h });
        return j.getEncodedHex();
      };
      if (g != void 0) {
        this.setByParam(g);
      }
    };
    extendClass(KJUR.asn1.tsp.PKIFreeText, KJUR.asn1.ASN1Object);
    KJUR.asn1.tsp.PKIFailureInfo = function(h) {
      var f = Error, e = KJUR, d = e.asn1, g = d.DERBitString, b = d.tsp, c = b.PKIFailureInfo;
      var a = { badAlg: 0, badRequest: 2, badDataFormat: 5, timeNotAvailable: 14, unacceptedPolicy: 15, unacceptedExtension: 16, addInfoNotAvailable: 17, systemFailure: 25 };
      c.superclass.constructor.call(this);
      this.params = null;
      this.getEncodedHex = function() {
        var k = this.params;
        var j;
        if (typeof k == "string") {
          try {
            j = a[k];
          } catch (i) {
            throw new f("undefined name: " + k);
          }
        } else {
          if (typeof k == "number") {
            j = k;
          } else {
            throw new f("wrong params");
          }
        }
        return new g({ bin: j.toString(2) }).getEncodedHex();
      };
      if (h != void 0) {
        this.setByParam(h);
      }
    };
    extendClass(KJUR.asn1.tsp.PKIFailureInfo, KJUR.asn1.ASN1Object);
    KJUR.asn1.tsp.AbstractTSAAdapter = function(a) {
      this.getTSTHex = function(c, b) {
        throw "not implemented yet";
      };
    };
    KJUR.asn1.tsp.SimpleTSAAdapter = function(e) {
      var d = KJUR, c = d.asn1, a = c.tsp, b = d.crypto.Util.hashHex;
      a.SimpleTSAAdapter.superclass.constructor.call(this);
      this.params = null;
      this.serial = 0;
      this.getTSTHex = function(g, f) {
        var i = b(g, f);
        this.params.econtent.content.messageImprint = { alg: f, hash: i };
        this.params.econtent.content.serial = { "int": this.serial++ };
        var h = Math.floor(Math.random() * 1e9);
        this.params.econtent.content.nonce = { "int": h };
        var j = new a.TimeStampToken(this.params);
        return j.getContentInfoEncodedHex();
      };
      if (e !== void 0) {
        this.params = e;
      }
    };
    extendClass(KJUR.asn1.tsp.SimpleTSAAdapter, KJUR.asn1.tsp.AbstractTSAAdapter);
    KJUR.asn1.tsp.FixedTSAAdapter = function(e) {
      var d = KJUR, c = d.asn1, a = c.tsp, b = d.crypto.Util.hashHex;
      a.FixedTSAAdapter.superclass.constructor.call(this);
      this.params = null;
      this.getTSTHex = function(g, f) {
        var h = b(g, f);
        this.params.econtent.content.messageImprint = { alg: f, hash: h };
        var i = new a.TimeStampToken(this.params);
        return i.getContentInfoEncodedHex();
      };
      if (e !== void 0) {
        this.params = e;
      }
    };
    extendClass(KJUR.asn1.tsp.FixedTSAAdapter, KJUR.asn1.tsp.AbstractTSAAdapter);
    KJUR.asn1.tsp.TSPUtil = new function() {
    }();
    KJUR.asn1.tsp.TSPUtil.newTimeStampToken = function(a) {
      return new KJUR.asn1.tsp.TimeStampToken(a);
    };
    KJUR.asn1.tsp.TSPUtil.parseTimeStampReq = function(m) {
      var l = ASN1HEX;
      var h = l.getChildIdx;
      var f = l.getV;
      var b = l.getTLV;
      var j = {};
      j.certreq = false;
      var a = h(m, 0);
      if (a.length < 2) {
        throw "TimeStampReq must have at least 2 items";
      }
      var e = b(m, a[1]);
      j.messageImprint = KJUR.asn1.tsp.TSPUtil.parseMessageImprint(e);
      for (var d = 2; d < a.length; d++) {
        var g = a[d];
        var k = m.substr(g, 2);
        if (k == "06") {
          var c = f(m, g);
          j.policy = l.hextooidstr(c);
        }
        if (k == "02") {
          j.nonce = f(m, g);
        }
        if (k == "01") {
          j.certreq = true;
        }
      }
      return j;
    };
    KJUR.asn1.tsp.TSPUtil.parseMessageImprint = function(c) {
      var m = ASN1HEX;
      var j = m.getChildIdx;
      var i = m.getV;
      var g = m.getIdxbyList;
      var k = {};
      if (c.substr(0, 2) != "30") {
        throw "head of messageImprint hex shall be '30'";
      }
      var a = j(c, 0);
      var l = g(c, 0, [0, 0]);
      var e = i(c, l);
      var d = m.hextooidstr(e);
      var h = KJUR.asn1.x509.OID.oid2name(d);
      if (h == "") {
        throw "hashAlg name undefined: " + d;
      }
      var b = h;
      var f = g(c, 0, [1]);
      k.alg = b;
      k.hash = i(c, f);
      return k;
    };
    KJUR.asn1.tsp.TSPParser = function() {
      var e = Error, a = X509, f = new a(), k = ASN1HEX, g = k.getV, b = k.getTLV, d = k.getIdxbyList, c = k.getTLVbyListEx, i = k.getChildIdx;
      var j = ["granted", "grantedWithMods", "rejection", "waiting", "revocationWarning", "revocationNotification"];
      var h = { 0: "badAlg", 2: "badRequest", 5: "badDataFormat", 14: "timeNotAvailable", 15: "unacceptedPolicy", 16: "unacceptedExtension", 17: "addInfoNotAvailable", 25: "systemFailure" };
      this.getResponse = function(n) {
        var l = i(n, 0);
        if (l.length == 1) {
          return this.getPKIStatusInfo(b(n, l[0]));
        } else {
          if (l.length > 1) {
            var o = this.getPKIStatusInfo(b(n, l[0]));
            var m = b(n, l[1]);
            var p = this.getToken(m);
            p.statusinfo = o;
            return p;
          }
        }
      };
      this.getToken = function(m) {
        var l = new KJUR.asn1.cms.CMSParser();
        var n = l.getCMSSignedData(m);
        this.setTSTInfo(n);
        return n;
      };
      this.setTSTInfo = function(l) {
        var o = l.econtent;
        if (o.type == "tstinfo") {
          var n = o.content.hex;
          var m = this.getTSTInfo(n);
          o.content = m;
        }
      };
      this.getTSTInfo = function(r) {
        var x = {};
        var s = i(r, 0);
        var p = g(r, s[1]);
        x.policy = hextooid(p);
        var o = b(r, s[2]);
        x.messageImprint = this.getMessageImprint(o);
        var u = g(r, s[3]);
        x.serial = { hex: u };
        var y = g(r, s[4]);
        x.genTime = { str: hextoutf8(y) };
        var q = 0;
        if (s.length > 5 && r.substr(s[5], 2) == "30") {
          var v = b(r, s[5]);
          x.accuracy = this.getAccuracy(v);
          q++;
        }
        if (s.length > 5 + q && r.substr(s[5 + q], 2) == "01") {
          var z2 = g(r, s[5 + q]);
          if (z2 == "ff") {
            x.ordering = true;
          }
          q++;
        }
        if (s.length > 5 + q && r.substr(s[5 + q], 2) == "02") {
          var n = g(r, s[5 + q]);
          x.nonce = { hex: n };
          q++;
        }
        if (s.length > 5 + q && r.substr(s[5 + q], 2) == "a0") {
          var m = b(r, s[5 + q]);
          m = "30" + m.substr(2);
          pGeneralNames = f.getGeneralNames(m);
          var t2 = pGeneralNames[0].dn;
          x.tsa = t2;
          q++;
        }
        if (s.length > 5 + q && r.substr(s[5 + q], 2) == "a1") {
          var l = b(r, s[5 + q]);
          l = "30" + l.substr(2);
          var w = f.getExtParamArray(l);
          x.ext = w;
          q++;
        }
        return x;
      };
      this.getAccuracy = function(q) {
        var r = {};
        var o = i(q, 0);
        for (var p = 0; p < o.length; p++) {
          var m = q.substr(o[p], 2);
          var l = g(q, o[p]);
          var n = parseInt(l, 16);
          if (m == "02") {
            r.seconds = n;
          } else {
            if (m == "80") {
              r.millis = n;
            } else {
              if (m == "81") {
                r.micros = n;
              }
            }
          }
        }
        return r;
      };
      this.getMessageImprint = function(n) {
        if (n.substr(0, 2) != "30") {
          throw new Error("head of messageImprint hex shall be x30");
        }
        var s = {};
        var l = i(n, 0);
        var t2 = d(n, 0, [0, 0]);
        var o = g(n, t2);
        var p = k.hextooidstr(o);
        var r = KJUR.asn1.x509.OID.oid2name(p);
        if (r == "") {
          throw new Error("hashAlg name undefined: " + p);
        }
        var m = r;
        var q = d(n, 0, [1]);
        s.alg = m;
        s.hash = g(n, q);
        return s;
      };
      this.getPKIStatusInfo = function(o) {
        var t2 = {};
        var r = i(o, 0);
        var n = 0;
        try {
          var l = g(o, r[0]);
          var p = parseInt(l, 16);
          t2.status = j[p];
        } catch (s) {
        }
        if (r.length > 1 && o.substr(r[1], 2) == "30") {
          var m = b(o, r[1]);
          t2.statusstr = this.getPKIFreeText(m);
          n++;
        }
        if (r.length > n && o.substr(r[1 + n], 2) == "03") {
          var q = b(o, r[1 + n]);
          t2.failinfo = this.getPKIFailureInfo(q);
        }
        return t2;
      };
      this.getPKIFreeText = function(n) {
        var o = [];
        var l = i(n, 0);
        for (var m = 0; m < l.length; m++) {
          o.push(k.getString(n, l[m]));
        }
        return o;
      };
      this.getPKIFailureInfo = function(l) {
        var m = k.getInt(l, 0);
        if (h[m] != void 0) {
          return h[m];
        } else {
          return m;
        }
      };
    };
    if (typeof KJUR == "undefined" || !KJUR) {
      KJUR = {};
    }
    if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) {
      KJUR.asn1 = {};
    }
    if (typeof KJUR.asn1.cades == "undefined" || !KJUR.asn1.cades) {
      KJUR.asn1.cades = {};
    }
    KJUR.asn1.cades.SignaturePolicyIdentifier = function(e) {
      var c = KJUR, b = c.asn1, a = b.cades, d = a.SignaturePolicyId;
      a.SignaturePolicyIdentifier.superclass.constructor.call(this);
      this.typeOid = "1.2.840.113549.1.9.16.2.15";
      this.params = null;
      this.getValueArray = function() {
        return [new d(this.params)];
      };
      this.setByParam = function(f) {
        this.params = f;
      };
      if (e != void 0) {
        this.setByParam(e);
      }
    };
    extendClass(KJUR.asn1.cades.SignaturePolicyIdentifier, KJUR.asn1.cms.Attribute);
    KJUR.asn1.cades.SignaturePolicyId = function(e) {
      var a = KJUR, g = a.asn1, f = g.DERSequence, i = g.DERObjectIdentifier, d = g.x509, j = d.AlgorithmIdentifier, c = g.cades, h = c.SignaturePolicyId, b = c.OtherHashAlgAndValue;
      h.superclass.constructor.call(this);
      this.params = null;
      this.getEncodedHex = function() {
        var m = this.params;
        var k = [];
        k.push(new i(m.oid));
        k.push(new b(m));
        var l = new f({ array: k });
        return l.getEncodedHex();
      };
      this.setByParam = function(k) {
        this.params = k;
      };
      if (e != void 0) {
        this.setByParam(e);
      }
    };
    extendClass(KJUR.asn1.cades.SignaturePolicyId, KJUR.asn1.ASN1Object);
    KJUR.asn1.cades.OtherHashAlgAndValue = function(e) {
      var h = Error, a = KJUR, g = a.asn1, f = g.DERSequence, i = g.DEROctetString, d = g.x509, j = d.AlgorithmIdentifier, c = g.cades, b = c.OtherHashAlgAndValue;
      b.superclass.constructor.call(this);
      this.params = null;
      this.getEncodedHex = function() {
        var o = this.params;
        if (o.alg == void 0) {
          throw new h("property 'alg' not specified");
        }
        if (o.hash == void 0 && o.cert == void 0) {
          throw new h("property 'hash' nor 'cert' not specified");
        }
        var m = null;
        if (o.hash != void 0) {
          m = o.hash;
        } else {
          if (o.cert != void 0) {
            if (typeof o.cert != "string") {
              throw new h("cert not string");
            }
            var n = o.cert;
            if (o.cert.indexOf("-----BEGIN") != -1) {
              n = pemtohex(o.cert);
            }
            m = KJUR.crypto.Util.hashHex(n, o.alg);
          }
        }
        var k = [];
        k.push(new j({ name: o.alg }));
        k.push(new i({ hex: m }));
        var l = new f({ array: k });
        return l.getEncodedHex();
      };
      if (e != void 0) {
        this.setByParam(e);
      }
    };
    extendClass(KJUR.asn1.cades.OtherHashAlgAndValue, KJUR.asn1.ASN1Object);
    KJUR.asn1.cades.OtherHashValue = function(g) {
      KJUR.asn1.cades.OtherHashValue.superclass.constructor.call(this);
      var d = Error, c = KJUR, f = c.lang.String.isHex, b = c.asn1, e = b.DEROctetString, a = c.crypto.Util.hashHex;
      this.params = null;
      this.getEncodedHex = function() {
        var j = this.params;
        if (j.hash == void 0 && j.cert == void 0) {
          throw new d("hash or cert not specified");
        }
        var h = null;
        if (j.hash != void 0) {
          h = j.hash;
        } else {
          if (j.cert != void 0) {
            if (typeof j.cert != "string") {
              throw new d("cert not string");
            }
            var i = j.cert;
            if (j.cert.indexOf("-----BEGIN") != -1) {
              i = pemtohex(j.cert);
            }
            h = KJUR.crypto.Util.hashHex(i, "sha1");
          }
        }
        return new e({ hex: h }).getEncodedHex();
      };
      if (g != void 0) {
        this.setByParam(g);
      }
    };
    extendClass(KJUR.asn1.cades.OtherHashValue, KJUR.asn1.ASN1Object);
    KJUR.asn1.cades.SignatureTimeStamp = function(h) {
      var d = Error, c = KJUR, f = c.lang.String.isHex, b = c.asn1, e = b.ASN1Object, g = b.x509, a = b.cades;
      a.SignatureTimeStamp.superclass.constructor.call(this);
      this.typeOid = "1.2.840.113549.1.9.16.2.14";
      this.params = null;
      this.getValueArray = function() {
        var l = this.params;
        if (l.tst != void 0) {
          if (f(l.tst)) {
            var j = new e();
            j.hTLV = l.tst;
            return [j];
          } else {
            if (l.tst instanceof e) {
              return [l.tst];
            } else {
              throw new d("params.tst has wrong value");
            }
          }
        } else {
          if (l.res != void 0) {
            var k = l.res;
            if (k instanceof e) {
              k = k.getEncodedHex();
            }
            if (typeof k != "string" || !f(k)) {
              throw new d("params.res has wrong value");
            }
            var i = ASN1HEX.getTLVbyList(k, 0, [1]);
            var j = new e();
            j.hTLV = l.tst;
            return [j];
          }
        }
      };
      if (h != null) {
        this.setByParam(h);
      }
    };
    extendClass(KJUR.asn1.cades.SignatureTimeStamp, KJUR.asn1.cms.Attribute);
    KJUR.asn1.cades.CompleteCertificateRefs = function(h) {
      var f = Error, e = KJUR, d = e.asn1, b = d.DERSequence, c = d.cades, a = c.OtherCertID, g = e.lang.String.isHex;
      c.CompleteCertificateRefs.superclass.constructor.call(this);
      this.typeOid = "1.2.840.113549.1.9.16.2.21";
      this.params = null;
      this.getValueArray = function() {
        var o = this.params;
        var k = [];
        for (var m = 0; m < o.array.length; m++) {
          var n = o.array[m];
          if (typeof n == "string") {
            if (n.indexOf("-----BEGIN") != -1) {
              n = { cert: n };
            } else {
              if (g(n)) {
                n = { hash: n };
              } else {
                throw new f("unsupported value: " + n);
              }
            }
          }
          if (o.alg != void 0 && n.alg == void 0) {
            n.alg = o.alg;
          }
          if (o.hasis != void 0 && n.hasis == void 0) {
            n.hasis = o.hasis;
          }
          var j = new a(n);
          k.push(j);
        }
        var l = new b({ array: k });
        return [l];
      };
      if (h != void 0) {
        this.setByParam(h);
      }
    };
    extendClass(KJUR.asn1.cades.CompleteCertificateRefs, KJUR.asn1.cms.Attribute);
    KJUR.asn1.cades.OtherCertID = function(e) {
      var a = KJUR, h = a.asn1, f = h.DERSequence, i = h.cms, g = i.IssuerSerial, c = h.cades, d = c.OtherHashValue, b = c.OtherHashAlgAndValue;
      c.OtherCertID.superclass.constructor.call(this);
      this.params = e;
      this.getEncodedHex = function() {
        var n = this.params;
        if (typeof n == "string") {
          if (n.indexOf("-----BEGIN") != -1) {
            n = { cert: n };
          } else {
            if (_isHex(n)) {
              n = { hash: n };
            }
          }
        }
        var j = [];
        var m = null;
        if (n.alg != void 0) {
          m = new b(n);
        } else {
          m = new d(n);
        }
        j.push(m);
        if (n.cert != void 0 && n.hasis == true || n.issuer != void 0 && n.serial != void 0) {
          var l = new g(n);
          j.push(l);
        }
        var k = new f({ array: j });
        return k.getEncodedHex();
      };
      if (e != void 0) {
        this.setByParam(e);
      }
    };
    extendClass(KJUR.asn1.cades.OtherCertID, KJUR.asn1.ASN1Object);
    KJUR.asn1.cades.OtherHash = function(g) {
      var i = Error, a = KJUR, h = a.asn1, j = h.cms, c = h.cades, b = c.OtherHashAlgAndValue, e = c.OtherHashValue, d = a.crypto.Util.hashHex, f = a.lang.String.isHex;
      c.OtherHash.superclass.constructor.call(this);
      this.params = null;
      this.getEncodedHex = function() {
        var l = this.params;
        if (typeof l == "string") {
          if (l.indexOf("-----BEGIN") != -1) {
            l = { cert: l };
          } else {
            if (f(l)) {
              l = { hash: l };
            }
          }
        }
        var k = null;
        if (l.alg != void 0) {
          k = new b(l);
        } else {
          k = new e(l);
        }
        return k.getEncodedHex();
      };
      if (g != void 0) {
        this.setByParam(g);
      }
    };
    extendClass(KJUR.asn1.cades.OtherHash, KJUR.asn1.ASN1Object);
    KJUR.asn1.cades.CAdESUtil = new function() {
    }();
    KJUR.asn1.cades.CAdESUtil.parseSignedDataForAddingUnsigned = function(a) {
      var c = new KJUR.asn1.cms.CMSParser();
      var b = c.getCMSSignedData(a);
      return b;
    };
    KJUR.asn1.cades.CAdESUtil.parseSignerInfoForAddingUnsigned = function(g, q, c) {
      var p = ASN1HEX, s = p.getChildIdx, a = p.getTLV, l = p.getV, v = KJUR, h = v.asn1, n = h.ASN1Object, j = h.cms, k = j.AttributeList, w = j.SignerInfo;
      var o = {};
      var t2 = s(g, q);
      if (t2.length != 6) {
        throw "not supported items for SignerInfo (!=6)";
      }
      var d = t2.shift();
      o.version = a(g, d);
      var e = t2.shift();
      o.si = a(g, e);
      var m = t2.shift();
      o.digalg = a(g, m);
      var f = t2.shift();
      o.sattrs = a(g, f);
      var i = t2.shift();
      o.sigalg = a(g, i);
      var b = t2.shift();
      o.sig = a(g, b);
      o.sigval = l(g, b);
      var u = null;
      o.obj = new w();
      u = new n();
      u.hTLV = o.version;
      o.obj.dCMSVersion = u;
      u = new n();
      u.hTLV = o.si;
      o.obj.dSignerIdentifier = u;
      u = new n();
      u.hTLV = o.digalg;
      o.obj.dDigestAlgorithm = u;
      u = new n();
      u.hTLV = o.sattrs;
      o.obj.dSignedAttrs = u;
      u = new n();
      u.hTLV = o.sigalg;
      o.obj.dSigAlg = u;
      u = new n();
      u.hTLV = o.sig;
      o.obj.dSig = u;
      o.obj.dUnsignedAttrs = new k();
      return o;
    };
    if (typeof KJUR.asn1.csr == "undefined" || !KJUR.asn1.csr) {
      KJUR.asn1.csr = {};
    }
    KJUR.asn1.csr.CertificationRequest = function(g) {
      var d = KJUR, c = d.asn1, e = c.DERBitString, b = c.DERSequence, a = c.csr, f = c.x509, h = a.CertificationRequestInfo;
      a.CertificationRequest.superclass.constructor.call(this);
      this.setByParam = function(i) {
        this.params = i;
      };
      this.sign = function() {
        var j = new h(this.params).getEncodedHex();
        var k = new KJUR.crypto.Signature({ alg: this.params.sigalg });
        k.init(this.params.sbjprvkey);
        k.updateHex(j);
        var i = k.sign();
        this.params.sighex = i;
      };
      this.getPEM = function() {
        return hextopem(this.getEncodedHex(), "CERTIFICATE REQUEST");
      };
      this.getEncodedHex = function() {
        var l = this.params;
        var j = new KJUR.asn1.csr.CertificationRequestInfo(this.params);
        var m = new KJUR.asn1.x509.AlgorithmIdentifier({ name: l.sigalg });
        if (l.sighex == void 0 && l.sbjprvkey != void 0) {
          this.sign();
        }
        if (l.sighex == void 0) {
          throw new Error("sighex or sbjprvkey parameter not defined");
        }
        var k = new e({ hex: "00" + l.sighex });
        var i = new b({ array: [j, m, k] });
        return i.getEncodedHex();
      };
      if (g !== void 0) {
        this.setByParam(g);
      }
    };
    extendClass(KJUR.asn1.csr.CertificationRequest, KJUR.asn1.ASN1Object);
    KJUR.asn1.csr.CertificationRequestInfo = function(f) {
      var b = KJUR, j = b.asn1, c = j.DERBitString, g = j.DERSequence, i = j.DERInteger, n = j.DERUTF8String, d = j.DERTaggedObject, h = j.ASN1Util.newObject, l = j.csr, e = j.x509, a = e.X500Name, k = e.Extensions, m = e.SubjectPublicKeyInfo;
      l.CertificationRequestInfo.superclass.constructor.call(this);
      this.params = null;
      this.setByParam = function(o) {
        if (o != void 0) {
          this.params = o;
        }
      };
      this.getEncodedHex = function() {
        var s = this.params;
        var p = [];
        p.push(new i({ "int": 0 }));
        p.push(new a(s.subject));
        p.push(new m(KEYUTIL.getKey(s.sbjpubkey)));
        if (s.extreq != void 0) {
          var o = new k(s.extreq);
          var r = h({ tag: { tag: "a0", explict: true, obj: { seq: [{ oid: "1.2.840.113549.1.9.14" }, { set: [o] }] } } });
          p.push(r);
        } else {
          p.push(new d({ tag: "a0", explicit: false, obj: new n({ str: "" }) }));
        }
        var q = new g({ array: p });
        return q.getEncodedHex();
      };
      if (f != void 0) {
        this.setByParam(f);
      }
    };
    extendClass(KJUR.asn1.csr.CertificationRequestInfo, KJUR.asn1.ASN1Object);
    KJUR.asn1.csr.CSRUtil = new function() {
    }();
    KJUR.asn1.csr.CSRUtil.newCSRPEM = function(e) {
      var b = KEYUTIL, a = KJUR.asn1.csr;
      var c = new a.CertificationRequest(e);
      var d = c.getPEM();
      return d;
    };
    KJUR.asn1.csr.CSRUtil.getParam = function(c) {
      var m = ASN1HEX, j = m.getV;
      _getIdxbyList = m.getIdxbyList;
      _getTLVbyList = m.getTLVbyList, _getTLVbyListEx = m.getTLVbyListEx, _getVbyListEx = m.getVbyListEx;
      var b = function(p) {
        var o = _getIdxbyList(p, 0, [0, 3, 0, 0], "06");
        if (j(p, o) != "2a864886f70d01090e") {
          return null;
        }
        return _getTLVbyList(p, 0, [0, 3, 0, 1, 0], "30");
      };
      var n = {};
      if (c.indexOf("-----BEGIN CERTIFICATE REQUEST") == -1) {
        throw new Error("argument is not PEM file");
      }
      var e = pemtohex(c, "CERTIFICATE REQUEST");
      try {
        var g = _getTLVbyListEx(e, 0, [0, 1]);
        if (g == "3000") {
          n.subject = {};
        } else {
          var k = new X509();
          n.subject = k.getX500Name(g);
        }
      } catch (h) {
      }
      var d = _getTLVbyListEx(e, 0, [0, 2]);
      var f = KEYUTIL.getKey(d, null, "pkcs8pub");
      n.sbjpubkey = KEYUTIL.getPEM(f, "PKCS8PUB");
      var i = b(e);
      var k = new X509();
      if (i != null) {
        n.extreq = k.getExtParamArray(i);
      }
      try {
        var a = _getTLVbyListEx(e, 0, [1], "30");
        var k = new X509();
        n.sigalg = k.getAlgorithmIdentifierName(a);
      } catch (h) {
      }
      try {
        var l = _getVbyListEx(e, 0, [2]);
        n.sighex = l;
      } catch (h) {
      }
      return n;
    };
    if (typeof KJUR == "undefined" || !KJUR) {
      KJUR = {};
    }
    if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) {
      KJUR.asn1 = {};
    }
    if (typeof KJUR.asn1.ocsp == "undefined" || !KJUR.asn1.ocsp) {
      KJUR.asn1.ocsp = {};
    }
    KJUR.asn1.ocsp.DEFAULT_HASH = "sha1";
    KJUR.asn1.ocsp.OCSPResponse = function(e) {
      KJUR.asn1.ocsp.OCSPResponse.superclass.constructor.call(this);
      var a = KJUR.asn1.DEREnumerated, b = KJUR.asn1.ASN1Util.newObject, c = KJUR.asn1.ocsp.ResponseBytes;
      var d = ["successful", "malformedRequest", "internalError", "tryLater", "_not_used_", "sigRequired", "unauthorized"];
      this.params = null;
      this._getStatusCode = function() {
        var f = this.params.resstatus;
        if (typeof f == "number") {
          return f;
        }
        if (typeof f != "string") {
          return -1;
        }
        return d.indexOf(f);
      };
      this.setByParam = function(f) {
        this.params = f;
      };
      this.getEncodedHex = function() {
        var h = this.params;
        var g = this._getStatusCode();
        if (g == -1) {
          throw new Error("responseStatus not supported: " + h.resstatus);
        }
        if (g != 0) {
          return b({ seq: [{ "enum": { "int": g } }] }).getEncodedHex();
        }
        var f = new c(h);
        return b({ seq: [{ "enum": { "int": 0 } }, { tag: { tag: "a0", explicit: true, obj: f } }] }).getEncodedHex();
      };
      if (e !== void 0) {
        this.setByParam(e);
      }
    };
    extendClass(KJUR.asn1.ocsp.OCSPResponse, KJUR.asn1.ASN1Object);
    KJUR.asn1.ocsp.ResponseBytes = function(e) {
      KJUR.asn1.ocsp.ResponseBytes.superclass.constructor.call(this);
      var b = KJUR.asn1, a = b.DERSequence, f = b.DERObjectIdentifier, c = b.DEROctetString, d = b.ocsp.BasicOCSPResponse;
      this.params = null;
      this.setByParam = function(g) {
        this.params = g;
      };
      this.getEncodedHex = function() {
        var j = this.params;
        if (j.restype != "ocspBasic") {
          throw new Error("not supported responseType: " + j.restype);
        }
        var i = new d(j);
        var g = [];
        g.push(new f({ name: "ocspBasic" }));
        g.push(new c({ hex: i.getEncodedHex() }));
        var h = new a({ array: g });
        return h.getEncodedHex();
      };
      if (e !== void 0) {
        this.setByParam(e);
      }
    };
    extendClass(KJUR.asn1.ocsp.ResponseBytes, KJUR.asn1.ASN1Object);
    KJUR.asn1.ocsp.BasicOCSPResponse = function(d) {
      KJUR.asn1.ocsp.BasicOCSPResponse.superclass.constructor.call(this);
      var i = Error, g = KJUR.asn1, j = g.ASN1Object, e = g.DERSequence, f = g.DERGeneralizedTime, c = g.DERTaggedObject, b = g.DERBitString, h = g.x509.Extensions, k = g.x509.AlgorithmIdentifier, l = g.ocsp, a = l.ResponderID;
      _SingleResponseList = l.SingleResponseList, _ResponseData = l.ResponseData;
      this.params = null;
      this.setByParam = function(m) {
        this.params = m;
      };
      this.sign = function() {
        var o = this.params;
        var m = o.tbsresp.getEncodedHex();
        var n = new KJUR.crypto.Signature({ alg: o.sigalg });
        n.init(o.reskey);
        n.updateHex(m);
        o.sighex = n.sign();
      };
      this.getEncodedHex = function() {
        var t2 = this.params;
        if (t2.tbsresp == void 0) {
          t2.tbsresp = new _ResponseData(t2);
        }
        if (t2.sighex == void 0 && t2.reskey != void 0) {
          this.sign();
        }
        var n = [];
        n.push(t2.tbsresp);
        n.push(new k({ name: t2.sigalg }));
        n.push(new b({ hex: "00" + t2.sighex }));
        if (t2.certs != void 0 && t2.certs.length != void 0) {
          var m = [];
          for (var q = 0; q < t2.certs.length; q++) {
            var s = t2.certs[q];
            var r = null;
            if (ASN1HEX.isASN1HEX(s)) {
              r = s;
            } else {
              if (s.match(/-----BEGIN/)) {
                r = pemtohex(s);
              } else {
                throw new i("certs[" + q + "] not hex or PEM");
              }
            }
            m.push(new j({ tlv: r }));
          }
          var p = new e({ array: m });
          n.push(new c({ tag: "a0", explicit: true, obj: p }));
        }
        var o = new e({ array: n });
        return o.getEncodedHex();
      };
      if (d !== void 0) {
        this.setByParam(d);
      }
    };
    extendClass(KJUR.asn1.ocsp.BasicOCSPResponse, KJUR.asn1.ASN1Object);
    KJUR.asn1.ocsp.ResponseData = function(c) {
      KJUR.asn1.ocsp.ResponseData.superclass.constructor.call(this);
      var h = Error, f = KJUR.asn1, d = f.DERSequence, e = f.DERGeneralizedTime, b = f.DERTaggedObject, g = f.x509.Extensions, i = f.ocsp, a = i.ResponderID;
      _SingleResponseList = i.SingleResponseList;
      this.params = null;
      this.getEncodedHex = function() {
        var m = this.params;
        if (m.respid != void 0) {
          new h("respid not specified");
        }
        if (m.prodat != void 0) {
          new h("prodat not specified");
        }
        if (m.array != void 0) {
          new h("array not specified");
        }
        var j = [];
        j.push(new a(m.respid));
        j.push(new e(m.prodat));
        j.push(new _SingleResponseList(m.array));
        if (m.ext != void 0) {
          var l = new g(m.ext);
          j.push(new b({ tag: "a1", explicit: true, obj: l }));
        }
        var k = new d({ array: j });
        return k.getEncodedHex();
      };
      this.setByParam = function(j) {
        this.params = j;
      };
      if (c !== void 0) {
        this.setByParam(c);
      }
    };
    extendClass(KJUR.asn1.ocsp.ResponseData, KJUR.asn1.ASN1Object);
    KJUR.asn1.ocsp.ResponderID = function(d) {
      KJUR.asn1.ocsp.ResponderID.superclass.constructor.call(this);
      var b = KJUR.asn1, a = b.ASN1Util.newObject, c = b.x509.X500Name;
      this.params = null;
      this.getEncodedHex = function() {
        var f = this.params;
        if (f.key != void 0) {
          var e = a({ tag: { tag: "a2", explicit: true, obj: { octstr: { hex: f.key } } } });
          return e.getEncodedHex();
        } else {
          if (f.name != void 0) {
            var e = a({ tag: { tag: "a1", explicit: true, obj: new c(f.name) } });
            return e.getEncodedHex();
          }
        }
        throw new Error("key or name not specified");
      };
      this.setByParam = function(e) {
        this.params = e;
      };
      if (d !== void 0) {
        this.setByParam(d);
      }
    };
    extendClass(KJUR.asn1.ocsp.ResponderID, KJUR.asn1.ASN1Object);
    KJUR.asn1.ocsp.SingleResponseList = function(d) {
      KJUR.asn1.ocsp.SingleResponseList.superclass.constructor.call(this);
      var c = KJUR.asn1, b = c.DERSequence, a = c.ocsp.SingleResponse;
      this.params = null;
      this.getEncodedHex = function() {
        var h = this.params;
        if (typeof h != "object" || h.length == void 0) {
          throw new Error("params not specified properly");
        }
        var e = [];
        for (var g = 0; g < h.length; g++) {
          e.push(new a(h[g]));
        }
        var f = new b({ array: e });
        return f.getEncodedHex();
      };
      this.setByParam = function(e) {
        this.params = e;
      };
      if (d !== void 0) {
        this.setByParam(d);
      }
    };
    extendClass(KJUR.asn1.ocsp.SingleResponseList, KJUR.asn1.ASN1Object);
    KJUR.asn1.ocsp.SingleResponse = function(e) {
      var k = Error, a = KJUR, i = a.asn1, f = i.DERSequence, g = i.DERGeneralizedTime, b = i.DERTaggedObject, l = i.ocsp, h = l.CertID, c = l.CertStatus, d = i.x509, j = d.Extensions;
      l.SingleResponse.superclass.constructor.call(this);
      this.params = null;
      this.getEncodedHex = function() {
        var q = this.params;
        var n = [];
        if (q.certid == void 0) {
          throw new k("certid unspecified");
        }
        if (q.status == void 0) {
          throw new k("status unspecified");
        }
        if (q.thisupdate == void 0) {
          throw new k("thisupdate unspecified");
        }
        n.push(new h(q.certid));
        n.push(new c(q.status));
        n.push(new g(q.thisupdate));
        if (q.nextupdate != void 0) {
          var m = new g(q.nextupdate);
          n.push(new b({ tag: "a0", explicit: true, obj: m }));
        }
        if (q.ext != void 0) {
          var p = new j(q.ext);
          n.push(new b({ tag: "a1", explicit: true, obj: p }));
        }
        var o = new f({ array: n });
        return o.getEncodedHex();
      };
      this.setByParam = function(m) {
        this.params = m;
      };
      if (e !== void 0) {
        this.setByParam(e);
      }
    };
    extendClass(KJUR.asn1.ocsp.SingleResponse, KJUR.asn1.ASN1Object);
    KJUR.asn1.ocsp.CertID = function(g) {
      var d = KJUR, k = d.asn1, m = k.DEROctetString, j = k.DERInteger, h = k.DERSequence, f = k.x509, n = f.AlgorithmIdentifier, o = k.ocsp, l = o.DEFAULT_HASH, i = d.crypto, e = i.Util.hashHex, c = X509, q = ASN1HEX;
      o.CertID.superclass.constructor.call(this);
      this.dHashAlg = null;
      this.dIssuerNameHash = null;
      this.dIssuerKeyHash = null;
      this.dSerialNumber = null;
      this.setByValue = function(t2, s, p, r) {
        if (r === void 0) {
          r = l;
        }
        this.dHashAlg = new n({ name: r });
        this.dIssuerNameHash = new m({ hex: t2 });
        this.dIssuerKeyHash = new m({ hex: s });
        this.dSerialNumber = new j({ hex: p });
      };
      this.setByCert = function(x, t2, v) {
        if (v === void 0) {
          v = l;
        }
        var p = new c();
        p.readCertPEM(t2);
        var y = new c();
        y.readCertPEM(x);
        var z2 = y.getPublicKeyHex();
        var w = q.getTLVbyList(z2, 0, [1, 0], "30");
        var r = p.getSerialNumberHex();
        var s = e(y.getSubjectHex(), v);
        var u = e(w, v);
        this.setByValue(s, u, r, v);
        this.hoge = p.getSerialNumberHex();
      };
      this.getEncodedHex = function() {
        if (this.dHashAlg === null && this.dIssuerNameHash === null && this.dIssuerKeyHash === null && this.dSerialNumber === null) {
          throw "not yet set values";
        }
        var p = [this.dHashAlg, this.dIssuerNameHash, this.dIssuerKeyHash, this.dSerialNumber];
        var r = new h({ array: p });
        this.hTLV = r.getEncodedHex();
        return this.hTLV;
      };
      if (g !== void 0) {
        var b = g;
        if (b.issuerCert !== void 0 && b.subjectCert !== void 0) {
          var a = l;
          if (b.alg === void 0) {
            a = void 0;
          }
          this.setByCert(b.issuerCert, b.subjectCert, a);
        } else {
          if (b.issname !== void 0 && b.isskey !== void 0 && b.sbjsn !== void 0) {
            var a = l;
            if (b.alg === void 0) {
              a = void 0;
            }
            this.setByValue(b.issname, b.isskey, b.sbjsn, a);
          } else {
            throw new Error("invalid constructor arguments");
          }
        }
      }
    };
    extendClass(KJUR.asn1.ocsp.CertID, KJUR.asn1.ASN1Object);
    KJUR.asn1.ocsp.CertStatus = function(a) {
      KJUR.asn1.ocsp.CertStatus.superclass.constructor.call(this);
      this.params = null;
      this.getEncodedHex = function() {
        var d = this.params;
        if (d.status == "good") {
          return "8000";
        }
        if (d.status == "unknown") {
          return "8200";
        }
        if (d.status == "revoked") {
          var c = [{ gentime: { str: d.time } }];
          if (d.reason != void 0) {
            c.push({ tag: { tag: "a0", explicit: true, obj: { "enum": { "int": d.reason } } } });
          }
          var b = { tag: "a1", explicit: false, obj: { seq: c } };
          return KJUR.asn1.ASN1Util.newObject({ tag: b }).getEncodedHex();
        }
        throw new Error("bad status");
      };
      this.setByParam = function(b) {
        this.params = b;
      };
      if (a !== void 0) {
        this.setByParam(a);
      }
    };
    extendClass(KJUR.asn1.ocsp.CertStatus, KJUR.asn1.ASN1Object);
    KJUR.asn1.ocsp.Request = function(f) {
      var c = KJUR, b = c.asn1, a = b.DERSequence, d = b.ocsp;
      d.Request.superclass.constructor.call(this);
      this.dReqCert = null;
      this.dExt = null;
      this.getEncodedHex = function() {
        var g = [];
        if (this.dReqCert === null) {
          throw "reqCert not set";
        }
        g.push(this.dReqCert);
        var h = new a({ array: g });
        this.hTLV = h.getEncodedHex();
        return this.hTLV;
      };
      if (typeof f !== "undefined") {
        var e = new d.CertID(f);
        this.dReqCert = e;
      }
    };
    extendClass(KJUR.asn1.ocsp.Request, KJUR.asn1.ASN1Object);
    KJUR.asn1.ocsp.TBSRequest = function(e) {
      var c = KJUR, b = c.asn1, a = b.DERSequence, d = b.ocsp;
      d.TBSRequest.superclass.constructor.call(this);
      this.version = 0;
      this.dRequestorName = null;
      this.dRequestList = [];
      this.dRequestExt = null;
      this.setRequestListByParam = function(h) {
        var f = [];
        for (var g = 0; g < h.length; g++) {
          var j = new d.Request(h[0]);
          f.push(j);
        }
        this.dRequestList = f;
      };
      this.getEncodedHex = function() {
        var f = [];
        if (this.version !== 0) {
          throw "not supported version: " + this.version;
        }
        if (this.dRequestorName !== null) {
          throw "requestorName not supported";
        }
        var h = new a({ array: this.dRequestList });
        f.push(h);
        if (this.dRequestExt !== null) {
          throw "requestExtensions not supported";
        }
        var g = new a({ array: f });
        this.hTLV = g.getEncodedHex();
        return this.hTLV;
      };
      if (e !== void 0) {
        if (e.reqList !== void 0) {
          this.setRequestListByParam(e.reqList);
        }
      }
    };
    extendClass(KJUR.asn1.ocsp.TBSRequest, KJUR.asn1.ASN1Object);
    KJUR.asn1.ocsp.OCSPRequest = function(f) {
      var c = KJUR, b = c.asn1, a = b.DERSequence, d = b.ocsp;
      d.OCSPRequest.superclass.constructor.call(this);
      this.dTbsRequest = null;
      this.dOptionalSignature = null;
      this.getEncodedHex = function() {
        var g = [];
        if (this.dTbsRequest !== null) {
          g.push(this.dTbsRequest);
        } else {
          throw "tbsRequest not set";
        }
        if (this.dOptionalSignature !== null) {
          throw "optionalSignature not supported";
        }
        var h = new a({ array: g });
        this.hTLV = h.getEncodedHex();
        return this.hTLV;
      };
      if (f !== void 0) {
        if (f.reqList !== void 0) {
          var e = new d.TBSRequest(f);
          this.dTbsRequest = e;
        }
      }
    };
    extendClass(KJUR.asn1.ocsp.OCSPRequest, KJUR.asn1.ASN1Object);
    KJUR.asn1.ocsp.OCSPUtil = {};
    KJUR.asn1.ocsp.OCSPUtil.getRequestHex = function(a, b, h) {
      var d = KJUR, c = d.asn1, e = c.ocsp;
      if (h === void 0) {
        h = e.DEFAULT_HASH;
      }
      var g = { alg: h, issuerCert: a, subjectCert: b };
      var f = new e.OCSPRequest({ reqList: [g] });
      return f.getEncodedHex();
    };
    KJUR.asn1.ocsp.OCSPUtil.getOCSPResponseInfo = function(b) {
      var m = ASN1HEX, c = m.getVbyList, k = m.getVbyListEx, e = m.getIdxbyList, d = m.getIdxbyListEx, g = m.getV;
      var n = {};
      try {
        var j = k(b, 0, [0], "0a");
        n.responseStatus = parseInt(j, 16);
      } catch (f) {
      }
      if (n.responseStatus !== 0) {
        return n;
      }
      try {
        var i = e(b, 0, [1, 0, 1, 0, 0, 2, 0, 1]);
        if (b.substr(i, 2) === "80") {
          n.certStatus = "good";
        } else {
          if (b.substr(i, 2) === "a1") {
            n.certStatus = "revoked";
            n.revocationTime = hextoutf8(c(b, i, [0]));
          } else {
            if (b.substr(i, 2) === "82") {
              n.certStatus = "unknown";
            }
          }
        }
      } catch (f) {
      }
      try {
        var a = e(b, 0, [1, 0, 1, 0, 0, 2, 0, 2]);
        n.thisUpdate = hextoutf8(g(b, a));
      } catch (f) {
      }
      try {
        var l = e(b, 0, [1, 0, 1, 0, 0, 2, 0, 3]);
        if (b.substr(l, 2) === "a0") {
          n.nextUpdate = hextoutf8(c(b, l, [0]));
        }
      } catch (f) {
      }
      return n;
    };
    KJUR.asn1.ocsp.OCSPParser = function() {
      var e = Error, a = X509, f = new a(), i = ASN1HEX, g = i.getV, b = i.getTLV, d = i.getIdxbyList, c = i.getTLVbyListEx, h = i.getChildIdx;
      this.getOCSPRequest = function(l) {
        var k = h(l, 0);
        if (k.length != 1 && k.length != 2) {
          throw new e("wrong number elements: " + k.length);
        }
        var j = this.getTBSRequest(b(l, k[0]));
        return j;
      };
      this.getTBSRequest = function(l) {
        var j = {};
        var k = c(l, 0, [0], "30");
        j.array = this.getRequestList(k);
        var m = c(l, 0, ["[2]", 0], "30");
        if (m != null) {
          j.ext = f.getExtParamArray(m);
        }
        return j;
      };
      this.getRequestList = function(m) {
        var j = [];
        var k = h(m, 0);
        for (var l = 0; l < k.length; l++) {
          var m = b(m, k[l]);
          j.push(this.getRequest(m));
        }
        return j;
      };
      this.getRequest = function(k) {
        var j = h(k, 0);
        if (j.length != 1 && j.length != 2) {
          throw new e("wrong number elements: " + j.length);
        }
        var m = this.getCertID(b(k, j[0]));
        if (j.length == 2) {
          var l = d(k, 0, [1, 0]);
          m.ext = f.getExtParamArray(b(k, l));
        }
        return m;
      };
      this.getCertID = function(m) {
        var l = h(m, 0);
        if (l.length != 4) {
          throw new e("wrong number elements: " + l.length);
        }
        var k = new a();
        var j = {};
        j.alg = k.getAlgorithmIdentifierName(b(m, l[0]));
        j.issname = g(m, l[1]);
        j.isskey = g(m, l[2]);
        j.sbjsn = g(m, l[3]);
        return j;
      };
    };
    var KJUR;
    if (typeof KJUR == "undefined" || !KJUR) {
      KJUR = {};
    }
    if (typeof KJUR.lang == "undefined" || !KJUR.lang) {
      KJUR.lang = {};
    }
    KJUR.lang.String = function() {
    };
    function stoBA(d) {
      var b = new Array();
      for (var c = 0; c < d.length; c++) {
        b[c] = d.charCodeAt(c);
      }
      return b;
    }
    function BAtos(b) {
      var d = "";
      for (var c = 0; c < b.length; c++) {
        d = d + String.fromCharCode(b[c]);
      }
      return d;
    }
    function BAtohex(b) {
      var e = "";
      for (var d = 0; d < b.length; d++) {
        var c = b[d].toString(16);
        if (c.length == 1) {
          c = "0" + c;
        }
        e = e + c;
      }
      return e;
    }
    function stohex(a) {
      return BAtohex(stoBA(a));
    }
    function stob64(a) {
      return hex2b64(stohex(a));
    }
    function stob64u(a) {
      return b64tob64u(hex2b64(stohex(a)));
    }
    function b64utos(a) {
      return BAtos(b64toBA(b64utob64(a)));
    }
    function b64tob64u(a) {
      a = a.replace(/\=/g, "");
      a = a.replace(/\+/g, "-");
      a = a.replace(/\//g, "_");
      return a;
    }
    function b64utob64(a) {
      if (a.length % 4 == 2) {
        a = a + "==";
      } else {
        if (a.length % 4 == 3) {
          a = a + "=";
        }
      }
      a = a.replace(/-/g, "+");
      a = a.replace(/_/g, "/");
      return a;
    }
    function hextob64u(a) {
      if (a.length % 2 == 1) {
        a = "0" + a;
      }
      return b64tob64u(hex2b64(a));
    }
    function b64utohex(a) {
      return b64tohex(b64utob64(a));
    }
    var utf8tob64u;
    var b64utoutf8;
    if (typeof Buffer === "function") {
      utf8tob64u = function(a) {
        return b64tob64u(Buffer.from(a, "utf8").toString("base64"));
      };
      b64utoutf8 = function(a) {
        return Buffer.from(b64utob64(a), "base64").toString("utf8");
      };
    } else {
      utf8tob64u = function(a) {
        return hextob64u(uricmptohex(encodeURIComponentAll(a)));
      };
      b64utoutf8 = function(a) {
        return decodeURIComponent(hextouricmp(b64utohex(a)));
      };
    }
    function utf8tob64(a) {
      return hex2b64(uricmptohex(encodeURIComponentAll(a)));
    }
    function b64toutf8(a) {
      return decodeURIComponent(hextouricmp(b64tohex(a)));
    }
    function utf8tohex(a) {
      return uricmptohex(encodeURIComponentAll(a));
    }
    function hextoutf8(a) {
      return decodeURIComponent(hextouricmp(a));
    }
    function hextorstr(c) {
      var b = "";
      for (var a = 0; a < c.length - 1; a += 2) {
        b += String.fromCharCode(parseInt(c.substr(a, 2), 16));
      }
      return b;
    }
    function rstrtohex(c) {
      var a = "";
      for (var b = 0; b < c.length; b++) {
        a += ("0" + c.charCodeAt(b).toString(16)).slice(-2);
      }
      return a;
    }
    function hextob64(a) {
      return hex2b64(a);
    }
    function hextob64nl(b) {
      var a = hextob64(b);
      var c = a.replace(/(.{64})/g, "$1\r\n");
      c = c.replace(/\r\n$/, "");
      return c;
    }
    function b64nltohex(b) {
      var a = b.replace(/[^0-9A-Za-z\/+=]*/g, "");
      var c = b64tohex(a);
      return c;
    }
    function hextopem(a, b) {
      var c = hextob64nl(a);
      return "-----BEGIN " + b + "-----\r\n" + c + "\r\n-----END " + b + "-----\r\n";
    }
    function pemtohex(a, b) {
      if (a.indexOf("-----BEGIN ") == -1) {
        throw "can't find PEM header: " + b;
      }
      if (b !== void 0) {
        a = a.replace(new RegExp("^[^]*-----BEGIN " + b + "-----"), "");
        a = a.replace(new RegExp("-----END " + b + "-----[^]*$"), "");
      } else {
        a = a.replace(/^[^]*-----BEGIN [^-]+-----/, "");
        a = a.replace(/-----END [^-]+-----[^]*$/, "");
      }
      return b64nltohex(a);
    }
    function hextoArrayBuffer(d) {
      if (d.length % 2 != 0) {
        throw "input is not even length";
      }
      if (d.match(/^[0-9A-Fa-f]+$/) == null) {
        throw "input is not hexadecimal";
      }
      var b = new ArrayBuffer(d.length / 2);
      var a = new DataView(b);
      for (var c = 0; c < d.length / 2; c++) {
        a.setUint8(c, parseInt(d.substr(c * 2, 2), 16));
      }
      return b;
    }
    function ArrayBuffertohex(b) {
      var d = "";
      var a = new DataView(b);
      for (var c = 0; c < b.byteLength; c++) {
        d += ("00" + a.getUint8(c).toString(16)).slice(-2);
      }
      return d;
    }
    function zulutomsec(n) {
      var l, j, m, e, f, i, b, k;
      var a, h, g, c;
      c = n.match(/^(\d{2}|\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(|\.\d+)Z$/);
      if (c) {
        a = c[1];
        l = parseInt(a);
        if (a.length === 2) {
          if (50 <= l && l < 100) {
            l = 1900 + l;
          } else {
            if (0 <= l && l < 50) {
              l = 2e3 + l;
            }
          }
        }
        j = parseInt(c[2]) - 1;
        m = parseInt(c[3]);
        e = parseInt(c[4]);
        f = parseInt(c[5]);
        i = parseInt(c[6]);
        b = 0;
        h = c[7];
        if (h !== "") {
          g = (h.substr(1) + "00").substr(0, 3);
          b = parseInt(g);
        }
        return Date.UTC(l, j, m, e, f, i, b);
      }
      throw "unsupported zulu format: " + n;
    }
    function zulutosec(a) {
      var b = zulutomsec(a);
      return ~~(b / 1e3);
    }
    function zulutodate(a) {
      return new Date(zulutomsec(a));
    }
    function datetozulu(g, e, f) {
      var b;
      var a = g.getUTCFullYear();
      if (e) {
        if (a < 1950 || 2049 < a) {
          throw "not proper year for UTCTime: " + a;
        }
        b = ("" + a).slice(-2);
      } else {
        b = ("000" + a).slice(-4);
      }
      b += ("0" + (g.getUTCMonth() + 1)).slice(-2);
      b += ("0" + g.getUTCDate()).slice(-2);
      b += ("0" + g.getUTCHours()).slice(-2);
      b += ("0" + g.getUTCMinutes()).slice(-2);
      b += ("0" + g.getUTCSeconds()).slice(-2);
      if (f) {
        var c = g.getUTCMilliseconds();
        if (c !== 0) {
          c = ("00" + c).slice(-3);
          c = c.replace(/0+$/g, "");
          b += "." + c;
        }
      }
      b += "Z";
      return b;
    }
    function uricmptohex(a) {
      return a.replace(/%/g, "");
    }
    function hextouricmp(a) {
      return a.replace(/(..)/g, "%$1");
    }
    function ipv6tohex(g) {
      var b = "malformed IPv6 address";
      if (!g.match(/^[0-9A-Fa-f:]+$/)) {
        throw b;
      }
      g = g.toLowerCase();
      var d = g.split(":").length - 1;
      if (d < 2) {
        throw b;
      }
      var e = ":".repeat(7 - d + 2);
      g = g.replace("::", e);
      var c = g.split(":");
      if (c.length != 8) {
        throw b;
      }
      for (var f = 0; f < 8; f++) {
        c[f] = ("0000" + c[f]).slice(-4);
      }
      return c.join("");
    }
    function hextoipv6(e) {
      if (!e.match(/^[0-9A-Fa-f]{32}$/)) {
        throw "malformed IPv6 address octet";
      }
      e = e.toLowerCase();
      var b = e.match(/.{1,4}/g);
      for (var d = 0; d < 8; d++) {
        b[d] = b[d].replace(/^0+/, "");
        if (b[d] == "") {
          b[d] = "0";
        }
      }
      e = ":" + b.join(":") + ":";
      var c = e.match(/:(0:){2,}/g);
      if (c === null) {
        return e.slice(1, -1);
      }
      var f = "";
      for (var d = 0; d < c.length; d++) {
        if (c[d].length > f.length) {
          f = c[d];
        }
      }
      e = e.replace(f, "::");
      return e.slice(1, -1);
    }
    function hextoip(b) {
      var d = "malformed hex value";
      if (!b.match(/^([0-9A-Fa-f][0-9A-Fa-f]){1,}$/)) {
        throw d;
      }
      if (b.length == 8) {
        var c;
        try {
          c = parseInt(b.substr(0, 2), 16) + "." + parseInt(b.substr(2, 2), 16) + "." + parseInt(b.substr(4, 2), 16) + "." + parseInt(b.substr(6, 2), 16);
          return c;
        } catch (a) {
          throw d;
        }
      } else {
        if (b.length == 32) {
          return hextoipv6(b);
        } else {
          return b;
        }
      }
    }
    function iptohex(f) {
      var j = "malformed IP address";
      f = f.toLowerCase(f);
      if (f.match(/^[0-9.]+$/)) {
        var b = f.split(".");
        if (b.length !== 4) {
          throw j;
        }
        var g = "";
        try {
          for (var e = 0; e < 4; e++) {
            var h = parseInt(b[e]);
            g += ("0" + h.toString(16)).slice(-2);
          }
          return g;
        } catch (c) {
          throw j;
        }
      } else {
        if (f.match(/^[0-9a-f:]+$/) && f.indexOf(":") !== -1) {
          return ipv6tohex(f);
        } else {
          throw j;
        }
      }
    }
    function ucs2hextoutf8(d) {
      function e(f) {
        var h = parseInt(f.substr(0, 2), 16);
        var a = parseInt(f.substr(2), 16);
        if (h == 0 & a < 128) {
          return String.fromCharCode(a);
        }
        if (h < 8) {
          var j = 192 | (h & 7) << 3 | (a & 192) >> 6;
          var i = 128 | a & 63;
          return hextoutf8(j.toString(16) + i.toString(16));
        }
        var j = 224 | (h & 240) >> 4;
        var i = 128 | (h & 15) << 2 | (a & 192) >> 6;
        var g = 128 | a & 63;
        return hextoutf8(j.toString(16) + i.toString(16) + g.toString(16));
      }
      var c = d.match(/.{4}/g);
      var b = c.map(e);
      return b.join("");
    }
    function encodeURIComponentAll(a) {
      var d = encodeURIComponent(a);
      var b = "";
      for (var c = 0; c < d.length; c++) {
        if (d[c] == "%") {
          b = b + d.substr(c, 3);
          c = c + 2;
        } else {
          b = b + "%" + stohex(d[c]);
        }
      }
      return b;
    }
    function newline_toUnix(a) {
      a = a.replace(/\r\n/mg, "\n");
      return a;
    }
    function newline_toDos(a) {
      a = a.replace(/\r\n/mg, "\n");
      a = a.replace(/\n/mg, "\r\n");
      return a;
    }
    KJUR.lang.String.isInteger = function(a) {
      if (a.match(/^[0-9]+$/)) {
        return true;
      } else {
        if (a.match(/^-[0-9]+$/)) {
          return true;
        } else {
          return false;
        }
      }
    };
    KJUR.lang.String.isHex = function(a) {
      return ishex(a);
    };
    function ishex(a) {
      if (a.length % 2 == 0 && (a.match(/^[0-9a-f]+$/) || a.match(/^[0-9A-F]+$/))) {
        return true;
      } else {
        return false;
      }
    }
    KJUR.lang.String.isBase64 = function(a) {
      a = a.replace(/\s+/g, "");
      if (a.match(/^[0-9A-Za-z+\/]+={0,3}$/) && a.length % 4 == 0) {
        return true;
      } else {
        return false;
      }
    };
    KJUR.lang.String.isBase64URL = function(a) {
      if (a.match(/[+/=]/)) {
        return false;
      }
      a = b64utob64(a);
      return KJUR.lang.String.isBase64(a);
    };
    KJUR.lang.String.isIntegerArray = function(a) {
      a = a.replace(/\s+/g, "");
      if (a.match(/^\[[0-9,]+\]$/)) {
        return true;
      } else {
        return false;
      }
    };
    KJUR.lang.String.isPrintable = function(a) {
      if (a.match(/^[0-9A-Za-z '()+,-./:=?]*$/) !== null) {
        return true;
      }
      return false;
    };
    KJUR.lang.String.isIA5 = function(a) {
      if (a.match(/^[\x20-\x21\x23-\x7f]*$/) !== null) {
        return true;
      }
      return false;
    };
    KJUR.lang.String.isMail = function(a) {
      if (a.match(/^[A-Za-z0-9]{1}[A-Za-z0-9_.-]*@{1}[A-Za-z0-9_.-]{1,}\.[A-Za-z0-9]{1,}$/) !== null) {
        return true;
      }
      return false;
    };
    function hextoposhex(a) {
      if (a.length % 2 == 1) {
        return "0" + a;
      }
      if (a.substr(0, 1) > "7") {
        return "00" + a;
      }
      return a;
    }
    function intarystrtohex(b) {
      b = b.replace(/^\s*\[\s*/, "");
      b = b.replace(/\s*\]\s*$/, "");
      b = b.replace(/\s*/g, "");
      try {
        var c = b.split(/,/).map(function(g, e, h) {
          var f = parseInt(g);
          if (f < 0 || 255 < f) {
            throw "integer not in range 0-255";
          }
          var d = ("00" + f.toString(16)).slice(-2);
          return d;
        }).join("");
        return c;
      } catch (a) {
        throw "malformed integer array string: " + a;
      }
    }
    var strdiffidx = function(c, a) {
      var d = c.length;
      if (c.length > a.length) {
        d = a.length;
      }
      for (var b = 0; b < d; b++) {
        if (c.charCodeAt(b) != a.charCodeAt(b)) {
          return b;
        }
      }
      if (c.length != a.length) {
        return d;
      }
      return -1;
    };
    function oidtohex(g) {
      var f = function(a) {
        var l = a.toString(16);
        if (l.length == 1) {
          l = "0" + l;
        }
        return l;
      };
      var e = function(p) {
        var o = "";
        var l = parseInt(p, 10);
        var a = l.toString(2);
        var m = 7 - a.length % 7;
        if (m == 7) {
          m = 0;
        }
        var r = "";
        for (var n = 0; n < m; n++) {
          r += "0";
        }
        a = r + a;
        for (var n = 0; n < a.length - 1; n += 7) {
          var q = a.substr(n, 7);
          if (n != a.length - 7) {
            q = "1" + q;
          }
          o += f(parseInt(q, 2));
        }
        return o;
      };
      try {
        if (!g.match(/^[0-9.]+$/)) {
          return null;
        }
        var j = "";
        var b = g.split(".");
        var k = parseInt(b[0], 10) * 40 + parseInt(b[1], 10);
        j += f(k);
        b.splice(0, 2);
        for (var d = 0; d < b.length; d++) {
          j += e(b[d]);
        }
        return j;
      } catch (c) {
        return null;
      }
    }
    function hextooid(g) {
      if (!ishex(g)) {
        return null;
      }
      try {
        var m = [];
        var p = g.substr(0, 2);
        var e = parseInt(p, 16);
        m[0] = new String(Math.floor(e / 40));
        m[1] = new String(e % 40);
        var n = g.substr(2);
        var l = [];
        for (var f = 0; f < n.length / 2; f++) {
          l.push(parseInt(n.substr(f * 2, 2), 16));
        }
        var k = [];
        var d = "";
        for (var f = 0; f < l.length; f++) {
          if (l[f] & 128) {
            d = d + strpad((l[f] & 127).toString(2), 7);
          } else {
            d = d + strpad((l[f] & 127).toString(2), 7);
            k.push(new String(parseInt(d, 2)));
            d = "";
          }
        }
        var o = m.join(".");
        if (k.length > 0) {
          o = o + "." + k.join(".");
        }
        return o;
      } catch (j) {
        return null;
      }
    }
    var strpad = function(c, b, a) {
      if (a == void 0) {
        a = "0";
      }
      if (c.length >= b) {
        return c;
      }
      return new Array(b - c.length + 1).join(a) + c;
    };
    function bitstrtoint(e) {
      try {
        var a = e.substr(0, 2);
        if (a == "00") {
          return parseInt(e.substr(2), 16);
        }
        var b = parseInt(a, 16);
        var f = e.substr(2);
        var d = parseInt(f, 16).toString(2);
        if (d == "0") {
          d = "00000000";
        }
        d = d.slice(0, 0 - b);
        return parseInt(d, 2);
      } catch (c) {
        return -1;
      }
    }
    function inttobitstr(e) {
      var c = Number(e).toString(2);
      var b = 8 - c.length % 8;
      if (b == 8) {
        b = 0;
      }
      c = c + strpad("", b, "0");
      var d = parseInt(c, 2).toString(16);
      if (d.length % 2 == 1) {
        d = "0" + d;
      }
      var a = "0" + b;
      return a + d;
    }
    function extendClass(c, a) {
      var b = function() {
      };
      b.prototype = a.prototype;
      c.prototype = new b();
      c.prototype.constructor = c;
      c.superclass = a.prototype;
      if (a.prototype.constructor == Object.prototype.constructor) {
        a.prototype.constructor = a;
      }
    }
    if (typeof KJUR == "undefined" || !KJUR) {
      KJUR = {};
    }
    if (typeof KJUR.crypto == "undefined" || !KJUR.crypto) {
      KJUR.crypto = {};
    }
    KJUR.crypto.Util = new function() {
      this.DIGESTINFOHEAD = { sha1: "3021300906052b0e03021a05000414", sha224: "302d300d06096086480165030402040500041c", sha256: "3031300d060960864801650304020105000420", sha384: "3041300d060960864801650304020205000430", sha512: "3051300d060960864801650304020305000440", md2: "3020300c06082a864886f70d020205000410", md5: "3020300c06082a864886f70d020505000410", ripemd160: "3021300906052b2403020105000414" };
      this.DEFAULTPROVIDER = { md5: "cryptojs", sha1: "cryptojs", sha224: "cryptojs", sha256: "cryptojs", sha384: "cryptojs", sha512: "cryptojs", ripemd160: "cryptojs", hmacmd5: "cryptojs", hmacsha1: "cryptojs", hmacsha224: "cryptojs", hmacsha256: "cryptojs", hmacsha384: "cryptojs", hmacsha512: "cryptojs", hmacripemd160: "cryptojs", MD5withRSA: "cryptojs/jsrsa", SHA1withRSA: "cryptojs/jsrsa", SHA224withRSA: "cryptojs/jsrsa", SHA256withRSA: "cryptojs/jsrsa", SHA384withRSA: "cryptojs/jsrsa", SHA512withRSA: "cryptojs/jsrsa", RIPEMD160withRSA: "cryptojs/jsrsa", MD5withECDSA: "cryptojs/jsrsa", SHA1withECDSA: "cryptojs/jsrsa", SHA224withECDSA: "cryptojs/jsrsa", SHA256withECDSA: "cryptojs/jsrsa", SHA384withECDSA: "cryptojs/jsrsa", SHA512withECDSA: "cryptojs/jsrsa", RIPEMD160withECDSA: "cryptojs/jsrsa", SHA1withDSA: "cryptojs/jsrsa", SHA224withDSA: "cryptojs/jsrsa", SHA256withDSA: "cryptojs/jsrsa", MD5withRSAandMGF1: "cryptojs/jsrsa", SHAwithRSAandMGF1: "cryptojs/jsrsa", SHA1withRSAandMGF1: "cryptojs/jsrsa", SHA224withRSAandMGF1: "cryptojs/jsrsa", SHA256withRSAandMGF1: "cryptojs/jsrsa", SHA384withRSAandMGF1: "cryptojs/jsrsa", SHA512withRSAandMGF1: "cryptojs/jsrsa", RIPEMD160withRSAandMGF1: "cryptojs/jsrsa" };
      this.CRYPTOJSMESSAGEDIGESTNAME = { md5: CryptoJS.algo.MD5, sha1: CryptoJS.algo.SHA1, sha224: CryptoJS.algo.SHA224, sha256: CryptoJS.algo.SHA256, sha384: CryptoJS.algo.SHA384, sha512: CryptoJS.algo.SHA512, ripemd160: CryptoJS.algo.RIPEMD160 };
      this.getDigestInfoHex = function(a, b) {
        if (typeof this.DIGESTINFOHEAD[b] == "undefined") {
          throw "alg not supported in Util.DIGESTINFOHEAD: " + b;
        }
        return this.DIGESTINFOHEAD[b] + a;
      };
      this.getPaddedDigestInfoHex = function(h, a, j) {
        var c = this.getDigestInfoHex(h, a);
        var d = j / 4;
        if (c.length + 22 > d) {
          throw "key is too short for SigAlg: keylen=" + j + "," + a;
        }
        var b = "0001";
        var k = "00" + c;
        var g = "";
        var l = d - b.length - k.length;
        for (var f = 0; f < l; f += 2) {
          g += "ff";
        }
        var e = b + g + k;
        return e;
      };
      this.hashString = function(a, c) {
        var b = new KJUR.crypto.MessageDigest({ alg: c });
        return b.digestString(a);
      };
      this.hashHex = function(b, c) {
        var a = new KJUR.crypto.MessageDigest({ alg: c });
        return a.digestHex(b);
      };
      this.sha1 = function(a) {
        return this.hashString(a, "sha1");
      };
      this.sha256 = function(a) {
        return this.hashString(a, "sha256");
      };
      this.sha256Hex = function(a) {
        return this.hashHex(a, "sha256");
      };
      this.sha512 = function(a) {
        return this.hashString(a, "sha512");
      };
      this.sha512Hex = function(a) {
        return this.hashHex(a, "sha512");
      };
      this.isKey = function(a) {
        if (a instanceof RSAKey || a instanceof KJUR.crypto.DSA || a instanceof KJUR.crypto.ECDSA) {
          return true;
        } else {
          return false;
        }
      };
    }();
    KJUR.crypto.Util.md5 = function(a) {
      var b = new KJUR.crypto.MessageDigest({ alg: "md5", prov: "cryptojs" });
      return b.digestString(a);
    };
    KJUR.crypto.Util.ripemd160 = function(a) {
      var b = new KJUR.crypto.MessageDigest({ alg: "ripemd160", prov: "cryptojs" });
      return b.digestString(a);
    };
    KJUR.crypto.Util.SECURERANDOMGEN = new SecureRandom();
    KJUR.crypto.Util.getRandomHexOfNbytes = function(b) {
      var a = new Array(b);
      KJUR.crypto.Util.SECURERANDOMGEN.nextBytes(a);
      return BAtohex(a);
    };
    KJUR.crypto.Util.getRandomBigIntegerOfNbytes = function(a) {
      return new BigInteger(KJUR.crypto.Util.getRandomHexOfNbytes(a), 16);
    };
    KJUR.crypto.Util.getRandomHexOfNbits = function(d) {
      var c = d % 8;
      var a = (d - c) / 8;
      var b = new Array(a + 1);
      KJUR.crypto.Util.SECURERANDOMGEN.nextBytes(b);
      b[0] = (255 << c & 255 ^ 255) & b[0];
      return BAtohex(b);
    };
    KJUR.crypto.Util.getRandomBigIntegerOfNbits = function(a) {
      return new BigInteger(KJUR.crypto.Util.getRandomHexOfNbits(a), 16);
    };
    KJUR.crypto.Util.getRandomBigIntegerZeroToMax = function(b) {
      var a = b.bitLength();
      while (1) {
        var c = KJUR.crypto.Util.getRandomBigIntegerOfNbits(a);
        if (b.compareTo(c) != -1) {
          return c;
        }
      }
    };
    KJUR.crypto.Util.getRandomBigIntegerMinToMax = function(e, b) {
      var c = e.compareTo(b);
      if (c == 1) {
        throw "biMin is greater than biMax";
      }
      if (c == 0) {
        return e;
      }
      var a = b.subtract(e);
      var d = KJUR.crypto.Util.getRandomBigIntegerZeroToMax(a);
      return d.add(e);
    };
    KJUR.crypto.MessageDigest = function(c) {
      var b = null;
      var a = null;
      var d = null;
      this.setAlgAndProvider = function(g, f) {
        g = KJUR.crypto.MessageDigest.getCanonicalAlgName(g);
        if (g !== null && f === void 0) {
          f = KJUR.crypto.Util.DEFAULTPROVIDER[g];
        }
        if (":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(g) != -1 && f == "cryptojs") {
          try {
            this.md = KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[g].create();
          } catch (e) {
            throw "setAlgAndProvider hash alg set fail alg=" + g + "/" + e;
          }
          this.updateString = function(h) {
            this.md.update(h);
          };
          this.updateHex = function(h) {
            var i = CryptoJS.enc.Hex.parse(h);
            this.md.update(i);
          };
          this.digest = function() {
            var h = this.md.finalize();
            return h.toString(CryptoJS.enc.Hex);
          };
          this.digestString = function(h) {
            this.updateString(h);
            return this.digest();
          };
          this.digestHex = function(h) {
            this.updateHex(h);
            return this.digest();
          };
        }
        if (":sha256:".indexOf(g) != -1 && f == "sjcl") {
          try {
            this.md = new sjcl.hash.sha256();
          } catch (e) {
            throw "setAlgAndProvider hash alg set fail alg=" + g + "/" + e;
          }
          this.updateString = function(h) {
            this.md.update(h);
          };
          this.updateHex = function(i) {
            var h = sjcl.codec.hex.toBits(i);
            this.md.update(h);
          };
          this.digest = function() {
            var h = this.md.finalize();
            return sjcl.codec.hex.fromBits(h);
          };
          this.digestString = function(h) {
            this.updateString(h);
            return this.digest();
          };
          this.digestHex = function(h) {
            this.updateHex(h);
            return this.digest();
          };
        }
      };
      this.updateString = function(e) {
        throw "updateString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;
      };
      this.updateHex = function(e) {
        throw "updateHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;
      };
      this.digest = function() {
        throw "digest() not supported for this alg/prov: " + this.algName + "/" + this.provName;
      };
      this.digestString = function(e) {
        throw "digestString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;
      };
      this.digestHex = function(e) {
        throw "digestHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;
      };
      if (c !== void 0) {
        if (c.alg !== void 0) {
          this.algName = c.alg;
          if (c.prov === void 0) {
            this.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName];
          }
          this.setAlgAndProvider(this.algName, this.provName);
        }
      }
    };
    KJUR.crypto.MessageDigest.getCanonicalAlgName = function(a) {
      if (typeof a === "string") {
        a = a.toLowerCase();
        a = a.replace(/-/, "");
      }
      return a;
    };
    KJUR.crypto.MessageDigest.getHashLength = function(c) {
      var b = KJUR.crypto.MessageDigest;
      var a = b.getCanonicalAlgName(c);
      if (b.HASHLENGTH[a] === void 0) {
        throw "not supported algorithm: " + c;
      }
      return b.HASHLENGTH[a];
    };
    KJUR.crypto.MessageDigest.HASHLENGTH = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, ripemd160: 20 };
    KJUR.crypto.Mac = function(d) {
      var f = null;
      var c = null;
      var a = null;
      var e = null;
      var b = null;
      this.setAlgAndProvider = function(k, i) {
        k = k.toLowerCase();
        if (k == null) {
          k = "hmacsha1";
        }
        k = k.toLowerCase();
        if (k.substr(0, 4) != "hmac") {
          throw "setAlgAndProvider unsupported HMAC alg: " + k;
        }
        if (i === void 0) {
          i = KJUR.crypto.Util.DEFAULTPROVIDER[k];
        }
        this.algProv = k + "/" + i;
        var g = k.substr(4);
        if (":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(g) != -1 && i == "cryptojs") {
          try {
            var j = KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[g];
            this.mac = CryptoJS.algo.HMAC.create(j, this.pass);
          } catch (h) {
            throw "setAlgAndProvider hash alg set fail hashAlg=" + g + "/" + h;
          }
          this.updateString = function(l) {
            this.mac.update(l);
          };
          this.updateHex = function(l) {
            var m = CryptoJS.enc.Hex.parse(l);
            this.mac.update(m);
          };
          this.doFinal = function() {
            var l = this.mac.finalize();
            return l.toString(CryptoJS.enc.Hex);
          };
          this.doFinalString = function(l) {
            this.updateString(l);
            return this.doFinal();
          };
          this.doFinalHex = function(l) {
            this.updateHex(l);
            return this.doFinal();
          };
        }
      };
      this.updateString = function(g) {
        throw "updateString(str) not supported for this alg/prov: " + this.algProv;
      };
      this.updateHex = function(g) {
        throw "updateHex(hex) not supported for this alg/prov: " + this.algProv;
      };
      this.doFinal = function() {
        throw "digest() not supported for this alg/prov: " + this.algProv;
      };
      this.doFinalString = function(g) {
        throw "digestString(str) not supported for this alg/prov: " + this.algProv;
      };
      this.doFinalHex = function(g) {
        throw "digestHex(hex) not supported for this alg/prov: " + this.algProv;
      };
      this.setPassword = function(h) {
        if (typeof h == "string") {
          var g = h;
          if (h.length % 2 == 1 || !h.match(/^[0-9A-Fa-f]+$/)) {
            g = rstrtohex(h);
          }
          this.pass = CryptoJS.enc.Hex.parse(g);
          return;
        }
        if (typeof h != "object") {
          throw "KJUR.crypto.Mac unsupported password type: " + h;
        }
        var g = null;
        if (h.hex !== void 0) {
          if (h.hex.length % 2 != 0 || !h.hex.match(/^[0-9A-Fa-f]+$/)) {
            throw "Mac: wrong hex password: " + h.hex;
          }
          g = h.hex;
        }
        if (h.utf8 !== void 0) {
          g = utf8tohex(h.utf8);
        }
        if (h.rstr !== void 0) {
          g = rstrtohex(h.rstr);
        }
        if (h.b64 !== void 0) {
          g = b64tohex(h.b64);
        }
        if (h.b64u !== void 0) {
          g = b64utohex(h.b64u);
        }
        if (g == null) {
          throw "KJUR.crypto.Mac unsupported password type: " + h;
        }
        this.pass = CryptoJS.enc.Hex.parse(g);
      };
      if (d !== void 0) {
        if (d.pass !== void 0) {
          this.setPassword(d.pass);
        }
        if (d.alg !== void 0) {
          this.algName = d.alg;
          if (d.prov === void 0) {
            this.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName];
          }
          this.setAlgAndProvider(this.algName, this.provName);
        }
      }
    };
    KJUR.crypto.Signature = function(o) {
      var q = null;
      var n = null;
      var r = null;
      var c = null;
      var l = null;
      var d = null;
      var k = null;
      var h = null;
      var p = null;
      var e = null;
      var b = -1;
      var g = null;
      var j = null;
      var a = null;
      var i = null;
      var f = null;
      this._setAlgNames = function() {
        var s = this.algName.match(/^(.+)with(.+)$/);
        if (s) {
          this.mdAlgName = s[1].toLowerCase();
          this.pubkeyAlgName = s[2].toLowerCase();
          if (this.pubkeyAlgName == "rsaandmgf1" && this.mdAlgName == "sha") {
            this.mdAlgName = "sha1";
          }
        }
      };
      this._zeroPaddingOfSignature = function(x, w) {
        var v = "";
        var t2 = w / 4 - x.length;
        for (var u = 0; u < t2; u++) {
          v = v + "0";
        }
        return v + x;
      };
      this.setAlgAndProvider = function(u, t2) {
        this._setAlgNames();
        if (t2 != "cryptojs/jsrsa") {
          throw new Error("provider not supported: " + t2);
        }
        if (":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(this.mdAlgName) != -1) {
          try {
            this.md = new KJUR.crypto.MessageDigest({ alg: this.mdAlgName });
          } catch (s) {
            throw new Error("setAlgAndProvider hash alg set fail alg=" + this.mdAlgName + "/" + s);
          }
          this.init = function(w, x) {
            var y = null;
            try {
              if (x === void 0) {
                y = KEYUTIL.getKey(w);
              } else {
                y = KEYUTIL.getKey(w, x);
              }
            } catch (v) {
              throw "init failed:" + v;
            }
            if (y.isPrivate === true) {
              this.prvKey = y;
              this.state = "SIGN";
            } else {
              if (y.isPublic === true) {
                this.pubKey = y;
                this.state = "VERIFY";
              } else {
                throw "init failed.:" + y;
              }
            }
          };
          this.updateString = function(v) {
            this.md.updateString(v);
          };
          this.updateHex = function(v) {
            this.md.updateHex(v);
          };
          this.sign = function() {
            this.sHashHex = this.md.digest();
            if (this.prvKey === void 0 && this.ecprvhex !== void 0 && this.eccurvename !== void 0 && KJUR.crypto.ECDSA !== void 0) {
              this.prvKey = new KJUR.crypto.ECDSA({ curve: this.eccurvename, prv: this.ecprvhex });
            }
            if (this.prvKey instanceof RSAKey && this.pubkeyAlgName === "rsaandmgf1") {
              this.hSign = this.prvKey.signWithMessageHashPSS(this.sHashHex, this.mdAlgName, this.pssSaltLen);
            } else {
              if (this.prvKey instanceof RSAKey && this.pubkeyAlgName === "rsa") {
                this.hSign = this.prvKey.signWithMessageHash(this.sHashHex, this.mdAlgName);
              } else {
                if (this.prvKey instanceof KJUR.crypto.ECDSA) {
                  this.hSign = this.prvKey.signWithMessageHash(this.sHashHex);
                } else {
                  if (this.prvKey instanceof KJUR.crypto.DSA) {
                    this.hSign = this.prvKey.signWithMessageHash(this.sHashHex);
                  } else {
                    throw "Signature: unsupported private key alg: " + this.pubkeyAlgName;
                  }
                }
              }
            }
            return this.hSign;
          };
          this.signString = function(v) {
            this.updateString(v);
            return this.sign();
          };
          this.signHex = function(v) {
            this.updateHex(v);
            return this.sign();
          };
          this.verify = function(v) {
            this.sHashHex = this.md.digest();
            if (this.pubKey === void 0 && this.ecpubhex !== void 0 && this.eccurvename !== void 0 && KJUR.crypto.ECDSA !== void 0) {
              this.pubKey = new KJUR.crypto.ECDSA({ curve: this.eccurvename, pub: this.ecpubhex });
            }
            if (this.pubKey instanceof RSAKey && this.pubkeyAlgName === "rsaandmgf1") {
              return this.pubKey.verifyWithMessageHashPSS(this.sHashHex, v, this.mdAlgName, this.pssSaltLen);
            } else {
              if (this.pubKey instanceof RSAKey && this.pubkeyAlgName === "rsa") {
                return this.pubKey.verifyWithMessageHash(this.sHashHex, v);
              } else {
                if (KJUR.crypto.ECDSA !== void 0 && this.pubKey instanceof KJUR.crypto.ECDSA) {
                  return this.pubKey.verifyWithMessageHash(this.sHashHex, v);
                } else {
                  if (KJUR.crypto.DSA !== void 0 && this.pubKey instanceof KJUR.crypto.DSA) {
                    return this.pubKey.verifyWithMessageHash(this.sHashHex, v);
                  } else {
                    throw "Signature: unsupported public key alg: " + this.pubkeyAlgName;
                  }
                }
              }
            }
          };
        }
      };
      this.init = function(s, t2) {
        throw "init(key, pass) not supported for this alg:prov=" + this.algProvName;
      };
      this.updateString = function(s) {
        throw "updateString(str) not supported for this alg:prov=" + this.algProvName;
      };
      this.updateHex = function(s) {
        throw "updateHex(hex) not supported for this alg:prov=" + this.algProvName;
      };
      this.sign = function() {
        throw "sign() not supported for this alg:prov=" + this.algProvName;
      };
      this.signString = function(s) {
        throw "digestString(str) not supported for this alg:prov=" + this.algProvName;
      };
      this.signHex = function(s) {
        throw "digestHex(hex) not supported for this alg:prov=" + this.algProvName;
      };
      this.verify = function(s) {
        throw "verify(hSigVal) not supported for this alg:prov=" + this.algProvName;
      };
      this.initParams = o;
      if (o !== void 0) {
        if (o.alg !== void 0) {
          this.algName = o.alg;
          if (o.prov === void 0) {
            this.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName];
          } else {
            this.provName = o.prov;
          }
          this.algProvName = this.algName + ":" + this.provName;
          this.setAlgAndProvider(this.algName, this.provName);
          this._setAlgNames();
        }
        if (o.psssaltlen !== void 0) {
          this.pssSaltLen = o.psssaltlen;
        }
        if (o.prvkeypem !== void 0) {
          if (o.prvkeypas !== void 0) {
            throw "both prvkeypem and prvkeypas parameters not supported";
          } else {
            try {
              var q = KEYUTIL.getKey(o.prvkeypem);
              this.init(q);
            } catch (m) {
              throw "fatal error to load pem private key: " + m;
            }
          }
        }
      }
    };
    KJUR.crypto.Cipher = function(a) {
    };
    KJUR.crypto.Cipher.encrypt = function(e, f, d) {
      if (f instanceof RSAKey && f.isPublic) {
        var c = KJUR.crypto.Cipher.getAlgByKeyAndName(f, d);
        if (c === "RSA") {
          return f.encrypt(e);
        }
        if (c === "RSAOAEP") {
          return f.encryptOAEP(e, "sha1");
        }
        var b = c.match(/^RSAOAEP(\d+)$/);
        if (b !== null) {
          return f.encryptOAEP(e, "sha" + b[1]);
        }
        throw "Cipher.encrypt: unsupported algorithm for RSAKey: " + d;
      } else {
        throw "Cipher.encrypt: unsupported key or algorithm";
      }
    };
    KJUR.crypto.Cipher.decrypt = function(e, f, d) {
      if (f instanceof RSAKey && f.isPrivate) {
        var c = KJUR.crypto.Cipher.getAlgByKeyAndName(f, d);
        if (c === "RSA") {
          return f.decrypt(e);
        }
        if (c === "RSAOAEP") {
          return f.decryptOAEP(e, "sha1");
        }
        var b = c.match(/^RSAOAEP(\d+)$/);
        if (b !== null) {
          return f.decryptOAEP(e, "sha" + b[1]);
        }
        throw "Cipher.decrypt: unsupported algorithm for RSAKey: " + d;
      } else {
        throw "Cipher.decrypt: unsupported key or algorithm";
      }
    };
    KJUR.crypto.Cipher.getAlgByKeyAndName = function(b, a) {
      if (b instanceof RSAKey) {
        if (":RSA:RSAOAEP:RSAOAEP224:RSAOAEP256:RSAOAEP384:RSAOAEP512:".indexOf(a) != -1) {
          return a;
        }
        if (a === null || a === void 0) {
          return "RSA";
        }
        throw "getAlgByKeyAndName: not supported algorithm name for RSAKey: " + a;
      }
      throw "getAlgByKeyAndName: not supported algorithm name: " + a;
    };
    KJUR.crypto.OID = new function() {
      this.oidhex2name = { "2a864886f70d010101": "rsaEncryption", "2a8648ce3d0201": "ecPublicKey", "2a8648ce380401": "dsa", "2a8648ce3d030107": "secp256r1", "2b8104001f": "secp192k1", "2b81040021": "secp224r1", "2b8104000a": "secp256k1", "2b81040023": "secp521r1", "2b81040022": "secp384r1", "2a8648ce380403": "SHA1withDSA", "608648016503040301": "SHA224withDSA", "608648016503040302": "SHA256withDSA" };
    }();
    if (typeof KJUR == "undefined" || !KJUR) {
      KJUR = {};
    }
    if (typeof KJUR.crypto == "undefined" || !KJUR.crypto) {
      KJUR.crypto = {};
    }
    KJUR.crypto.ECDSA = function(e) {
      var g = "secp256r1";
      var p = null;
      var b = null;
      var i = null;
      var j = Error, f = BigInteger, h = ECPointFp, m = KJUR.crypto.ECDSA, c = KJUR.crypto.ECParameterDB, d = m.getName, q = ASN1HEX, n = q.getVbyListEx, k = q.isASN1HEX;
      var a = new SecureRandom();
      var o = null;
      this.type = "EC";
      this.isPrivate = false;
      this.isPublic = false;
      function l(x, t2, w, s) {
        var r = Math.max(t2.bitLength(), s.bitLength());
        var y = x.add2D(w);
        var v = x.curve.getInfinity();
        for (var u = r - 1; u >= 0; --u) {
          v = v.twice2D();
          v.z = f.ONE;
          if (t2.testBit(u)) {
            if (s.testBit(u)) {
              v = v.add2D(y);
            } else {
              v = v.add2D(x);
            }
          } else {
            if (s.testBit(u)) {
              v = v.add2D(w);
            }
          }
        }
        return v;
      }
      this.getBigRandom = function(r) {
        return new f(r.bitLength(), a).mod(r.subtract(f.ONE)).add(f.ONE);
      };
      this.setNamedCurve = function(r) {
        this.ecparams = c.getByName(r);
        this.prvKeyHex = null;
        this.pubKeyHex = null;
        this.curveName = r;
      };
      this.setPrivateKeyHex = function(r) {
        this.isPrivate = true;
        this.prvKeyHex = r;
      };
      this.setPublicKeyHex = function(r) {
        this.isPublic = true;
        this.pubKeyHex = r;
      };
      this.getPublicKeyXYHex = function() {
        var t2 = this.pubKeyHex;
        if (t2.substr(0, 2) !== "04") {
          throw "this method supports uncompressed format(04) only";
        }
        var s = this.ecparams.keylen / 4;
        if (t2.length !== 2 + s * 2) {
          throw "malformed public key hex length";
        }
        var r = {};
        r.x = t2.substr(2, s);
        r.y = t2.substr(2 + s);
        return r;
      };
      this.getShortNISTPCurveName = function() {
        var r = this.curveName;
        if (r === "secp256r1" || r === "NIST P-256" || r === "P-256" || r === "prime256v1") {
          return "P-256";
        }
        if (r === "secp384r1" || r === "NIST P-384" || r === "P-384") {
          return "P-384";
        }
        return null;
      };
      this.generateKeyPairHex = function() {
        var t2 = this.ecparams.n;
        var w = this.getBigRandom(t2);
        var u = this.ecparams.G.multiply(w);
        var z2 = u.getX().toBigInteger();
        var x = u.getY().toBigInteger();
        var r = this.ecparams.keylen / 4;
        var v = ("0000000000" + w.toString(16)).slice(-r);
        var A = ("0000000000" + z2.toString(16)).slice(-r);
        var y = ("0000000000" + x.toString(16)).slice(-r);
        var s = "04" + A + y;
        this.setPrivateKeyHex(v);
        this.setPublicKeyHex(s);
        return { ecprvhex: v, ecpubhex: s };
      };
      this.signWithMessageHash = function(r) {
        return this.signHex(r, this.prvKeyHex);
      };
      this.signHex = function(x, u) {
        var A = new f(u, 16);
        var v = this.ecparams.n;
        var z2 = new f(x.substring(0, this.ecparams.keylen / 4), 16);
        do {
          var w = this.getBigRandom(v);
          var B = this.ecparams.G;
          var y = B.multiply(w);
          var t2 = y.getX().toBigInteger().mod(v);
        } while (t2.compareTo(f.ZERO) <= 0);
        var C = w.modInverse(v).multiply(z2.add(A.multiply(t2))).mod(v);
        return m.biRSSigToASN1Sig(t2, C);
      };
      this.sign = function(w, B) {
        var z2 = B;
        var u = this.ecparams.n;
        var y = f.fromByteArrayUnsigned(w);
        do {
          var v = this.getBigRandom(u);
          var A = this.ecparams.G;
          var x = A.multiply(v);
          var t2 = x.getX().toBigInteger().mod(u);
        } while (t2.compareTo(BigInteger.ZERO) <= 0);
        var C = v.modInverse(u).multiply(y.add(z2.multiply(t2))).mod(u);
        return this.serializeSig(t2, C);
      };
      this.verifyWithMessageHash = function(s, r) {
        return this.verifyHex(s, r, this.pubKeyHex);
      };
      this.verifyHex = function(v, y, u) {
        try {
          var t2, B;
          var w = m.parseSigHex(y);
          t2 = w.r;
          B = w.s;
          var x = h.decodeFromHex(this.ecparams.curve, u);
          var z2 = new f(v.substring(0, this.ecparams.keylen / 4), 16);
          return this.verifyRaw(z2, t2, B, x);
        } catch (A) {
          return false;
        }
      };
      this.verify = function(z2, A, u) {
        var w, t2;
        if (Bitcoin.Util.isArray(A)) {
          var y = this.parseSig(A);
          w = y.r;
          t2 = y.s;
        } else {
          if (typeof A === "object" && A.r && A.s) {
            w = A.r;
            t2 = A.s;
          } else {
            throw "Invalid value for signature";
          }
        }
        var v;
        if (u instanceof ECPointFp) {
          v = u;
        } else {
          if (Bitcoin.Util.isArray(u)) {
            v = h.decodeFrom(this.ecparams.curve, u);
          } else {
            throw "Invalid format for pubkey value, must be byte array or ECPointFp";
          }
        }
        var x = f.fromByteArrayUnsigned(z2);
        return this.verifyRaw(x, w, t2, v);
      };
      this.verifyRaw = function(z2, t2, E, y) {
        var x = this.ecparams.n;
        var D = this.ecparams.G;
        if (t2.compareTo(f.ONE) < 0 || t2.compareTo(x) >= 0) {
          return false;
        }
        if (E.compareTo(f.ONE) < 0 || E.compareTo(x) >= 0) {
          return false;
        }
        var A = E.modInverse(x);
        var w = z2.multiply(A).mod(x);
        var u = t2.multiply(A).mod(x);
        var B = D.multiply(w).add(y.multiply(u));
        var C = B.getX().toBigInteger().mod(x);
        return C.equals(t2);
      };
      this.serializeSig = function(v, u) {
        var w = v.toByteArraySigned();
        var t2 = u.toByteArraySigned();
        var x = [];
        x.push(2);
        x.push(w.length);
        x = x.concat(w);
        x.push(2);
        x.push(t2.length);
        x = x.concat(t2);
        x.unshift(x.length);
        x.unshift(48);
        return x;
      };
      this.parseSig = function(y) {
        var x;
        if (y[0] != 48) {
          throw new Error("Signature not a valid DERSequence");
        }
        x = 2;
        if (y[x] != 2) {
          throw new Error("First element in signature must be a DERInteger");
        }
        var w = y.slice(x + 2, x + 2 + y[x + 1]);
        x += 2 + y[x + 1];
        if (y[x] != 2) {
          throw new Error("Second element in signature must be a DERInteger");
        }
        var t2 = y.slice(x + 2, x + 2 + y[x + 1]);
        x += 2 + y[x + 1];
        var v = f.fromByteArrayUnsigned(w);
        var u = f.fromByteArrayUnsigned(t2);
        return { r: v, s: u };
      };
      this.parseSigCompact = function(w) {
        if (w.length !== 65) {
          throw "Signature has the wrong length";
        }
        var t2 = w[0] - 27;
        if (t2 < 0 || t2 > 7) {
          throw "Invalid signature type";
        }
        var x = this.ecparams.n;
        var v = f.fromByteArrayUnsigned(w.slice(1, 33)).mod(x);
        var u = f.fromByteArrayUnsigned(w.slice(33, 65)).mod(x);
        return { r: v, s: u, i: t2 };
      };
      this.readPKCS5PrvKeyHex = function(u) {
        if (k(u) === false) {
          throw new Error("not ASN.1 hex string");
        }
        var r, t2, v;
        try {
          r = n(u, 0, ["[0]", 0], "06");
          t2 = n(u, 0, [1], "04");
          try {
            v = n(u, 0, ["[1]", 0], "03");
          } catch (s) {
          }
        } catch (s) {
          throw new Error("malformed PKCS#1/5 plain ECC private key");
        }
        this.curveName = d(r);
        if (this.curveName === void 0) {
          throw "unsupported curve name";
        }
        this.setNamedCurve(this.curveName);
        this.setPublicKeyHex(v);
        this.setPrivateKeyHex(t2);
        this.isPublic = false;
      };
      this.readPKCS8PrvKeyHex = function(v) {
        if (k(v) === false) {
          throw new j("not ASN.1 hex string");
        }
        var t2, r, u, w;
        try {
          t2 = n(v, 0, [1, 0], "06");
          r = n(v, 0, [1, 1], "06");
          u = n(v, 0, [2, 0, 1], "04");
          try {
            w = n(v, 0, [2, 0, "[1]", 0], "03");
          } catch (s) {
          }
        } catch (s) {
          throw new j("malformed PKCS#8 plain ECC private key");
        }
        this.curveName = d(r);
        if (this.curveName === void 0) {
          throw new j("unsupported curve name");
        }
        this.setNamedCurve(this.curveName);
        this.setPublicKeyHex(w);
        this.setPrivateKeyHex(u);
        this.isPublic = false;
      };
      this.readPKCS8PubKeyHex = function(u) {
        if (k(u) === false) {
          throw new j("not ASN.1 hex string");
        }
        var t2, r, v;
        try {
          t2 = n(u, 0, [0, 0], "06");
          r = n(u, 0, [0, 1], "06");
          v = n(u, 0, [1], "03");
        } catch (s) {
          throw new j("malformed PKCS#8 ECC public key");
        }
        this.curveName = d(r);
        if (this.curveName === null) {
          throw new j("unsupported curve name");
        }
        this.setNamedCurve(this.curveName);
        this.setPublicKeyHex(v);
      };
      this.readCertPubKeyHex = function(t2, v) {
        if (k(t2) === false) {
          throw new j("not ASN.1 hex string");
        }
        var r, u;
        try {
          r = n(t2, 0, [0, 5, 0, 1], "06");
          u = n(t2, 0, [0, 5, 1], "03");
        } catch (s) {
          throw new j("malformed X.509 certificate ECC public key");
        }
        this.curveName = d(r);
        if (this.curveName === null) {
          throw new j("unsupported curve name");
        }
        this.setNamedCurve(this.curveName);
        this.setPublicKeyHex(u);
      };
      if (e !== void 0) {
        if (e.curve !== void 0) {
          this.curveName = e.curve;
        }
      }
      if (this.curveName === void 0) {
        this.curveName = g;
      }
      this.setNamedCurve(this.curveName);
      if (e !== void 0) {
        if (e.prv !== void 0) {
          this.setPrivateKeyHex(e.prv);
        }
        if (e.pub !== void 0) {
          this.setPublicKeyHex(e.pub);
        }
      }
    };
    KJUR.crypto.ECDSA.parseSigHex = function(a) {
      var b = KJUR.crypto.ECDSA.parseSigHexInHexRS(a);
      var d = new BigInteger(b.r, 16);
      var c = new BigInteger(b.s, 16);
      return { r: d, s: c };
    };
    KJUR.crypto.ECDSA.parseSigHexInHexRS = function(f) {
      var j = ASN1HEX, i = j.getChildIdx, g = j.getV;
      j.checkStrictDER(f, 0);
      if (f.substr(0, 2) != "30") {
        throw new Error("signature is not a ASN.1 sequence");
      }
      var h = i(f, 0);
      if (h.length != 2) {
        throw new Error("signature shall have two elements");
      }
      var e = h[0];
      var d = h[1];
      if (f.substr(e, 2) != "02") {
        throw new Error("1st item not ASN.1 integer");
      }
      if (f.substr(d, 2) != "02") {
        throw new Error("2nd item not ASN.1 integer");
      }
      var c = g(f, e);
      var b = g(f, d);
      return { r: c, s: b };
    };
    KJUR.crypto.ECDSA.asn1SigToConcatSig = function(c) {
      var d = KJUR.crypto.ECDSA.parseSigHexInHexRS(c);
      var b = d.r;
      var a = d.s;
      if (b.substr(0, 2) == "00" && b.length % 32 == 2) {
        b = b.substr(2);
      }
      if (a.substr(0, 2) == "00" && a.length % 32 == 2) {
        a = a.substr(2);
      }
      if (b.length % 32 == 30) {
        b = "00" + b;
      }
      if (a.length % 32 == 30) {
        a = "00" + a;
      }
      if (b.length % 32 != 0) {
        throw "unknown ECDSA sig r length error";
      }
      if (a.length % 32 != 0) {
        throw "unknown ECDSA sig s length error";
      }
      return b + a;
    };
    KJUR.crypto.ECDSA.concatSigToASN1Sig = function(a) {
      if (a.length / 2 * 8 % (16 * 8) != 0) {
        throw "unknown ECDSA concatinated r-s sig  length error";
      }
      var c = a.substr(0, a.length / 2);
      var b = a.substr(a.length / 2);
      return KJUR.crypto.ECDSA.hexRSSigToASN1Sig(c, b);
    };
    KJUR.crypto.ECDSA.hexRSSigToASN1Sig = function(b, a) {
      var d = new BigInteger(b, 16);
      var c = new BigInteger(a, 16);
      return KJUR.crypto.ECDSA.biRSSigToASN1Sig(d, c);
    };
    KJUR.crypto.ECDSA.biRSSigToASN1Sig = function(f, d) {
      var c = KJUR.asn1;
      var b = new c.DERInteger({ bigint: f });
      var a = new c.DERInteger({ bigint: d });
      var e = new c.DERSequence({ array: [b, a] });
      return e.getEncodedHex();
    };
    KJUR.crypto.ECDSA.getName = function(a) {
      if (a === "2b8104001f") {
        return "secp192k1";
      }
      if (a === "2a8648ce3d030107") {
        return "secp256r1";
      }
      if (a === "2b8104000a") {
        return "secp256k1";
      }
      if (a === "2b81040021") {
        return "secp224r1";
      }
      if (a === "2b81040022") {
        return "secp384r1";
      }
      if ("|secp256r1|NIST P-256|P-256|prime256v1|".indexOf(a) !== -1) {
        return "secp256r1";
      }
      if ("|secp256k1|".indexOf(a) !== -1) {
        return "secp256k1";
      }
      if ("|secp224r1|NIST P-224|P-224|".indexOf(a) !== -1) {
        return "secp224r1";
      }
      if ("|secp384r1|NIST P-384|P-384|".indexOf(a) !== -1) {
        return "secp384r1";
      }
      return null;
    };
    if (typeof KJUR == "undefined" || !KJUR) {
      KJUR = {};
    }
    if (typeof KJUR.crypto == "undefined" || !KJUR.crypto) {
      KJUR.crypto = {};
    }
    KJUR.crypto.ECParameterDB = new function() {
      var b = {};
      var c = {};
      function a(d) {
        return new BigInteger(d, 16);
      }
      this.getByName = function(e) {
        var d = e;
        if (typeof c[d] != "undefined") {
          d = c[e];
        }
        if (typeof b[d] != "undefined") {
          return b[d];
        }
        throw "unregistered EC curve name: " + d;
      };
      this.regist = function(A, l, o, g, m, e, j, f, k, u, d, x) {
        b[A] = {};
        var s = a(o);
        var z2 = a(g);
        var y = a(m);
        var t2 = a(e);
        var w = a(j);
        var r = new ECCurveFp(s, z2, y);
        var q = r.decodePointHex("04" + f + k);
        b[A]["name"] = A;
        b[A]["keylen"] = l;
        b[A]["curve"] = r;
        b[A]["G"] = q;
        b[A]["n"] = t2;
        b[A]["h"] = w;
        b[A]["oid"] = d;
        b[A]["info"] = x;
        for (var v = 0; v < u.length; v++) {
          c[u[v]] = A;
        }
      };
    }();
    KJUR.crypto.ECParameterDB.regist("secp128r1", 128, "FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF", "FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC", "E87579C11079F43DD824993C2CEE5ED3", "FFFFFFFE0000000075A30D1B9038A115", "1", "161FF7528B899B2D0C28607CA52C5B86", "CF5AC8395BAFEB13C02DA292DDED7A83", [], "", "secp128r1 : SECG curve over a 128 bit prime field");
    KJUR.crypto.ECParameterDB.regist("secp160k1", 160, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73", "0", "7", "0100000000000000000001B8FA16DFAB9ACA16B6B3", "1", "3B4C382CE37AA192A4019E763036F4F5DD4D7EBB", "938CF935318FDCED6BC28286531733C3F03C4FEE", [], "", "secp160k1 : SECG curve over a 160 bit prime field");
    KJUR.crypto.ECParameterDB.regist("secp160r1", 160, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC", "1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45", "0100000000000000000001F4C8F927AED3CA752257", "1", "4A96B5688EF573284664698968C38BB913CBFC82", "23A628553168947D59DCC912042351377AC5FB32", [], "", "secp160r1 : SECG curve over a 160 bit prime field");
    KJUR.crypto.ECParameterDB.regist("secp192k1", 192, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37", "0", "3", "FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D", "1", "DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D", "9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D", []);
    KJUR.crypto.ECParameterDB.regist("secp192r1", 192, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC", "64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1", "FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831", "1", "188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012", "07192B95FFC8DA78631011ED6B24CDD573F977A11E794811", []);
    KJUR.crypto.ECParameterDB.regist("secp224r1", 224, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE", "B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4", "FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D", "1", "B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21", "BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34", []);
    KJUR.crypto.ECParameterDB.regist("secp256k1", 256, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F", "0", "7", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", "1", "79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798", "483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8", []);
    KJUR.crypto.ECParameterDB.regist("secp256r1", 256, "FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF", "FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC", "5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B", "FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551", "1", "6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296", "4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5", ["NIST P-256", "P-256", "prime256v1"]);
    KJUR.crypto.ECParameterDB.regist("secp384r1", 384, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC", "B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973", "1", "AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7", "3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f", ["NIST P-384", "P-384"]);
    KJUR.crypto.ECParameterDB.regist("secp521r1", 521, "1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF", "1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC", "051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00", "1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409", "1", "C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66", "011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650", ["NIST P-521", "P-521"]);
    if (typeof KJUR == "undefined" || !KJUR) {
      KJUR = {};
    }
    if (typeof KJUR.crypto == "undefined" || !KJUR.crypto) {
      KJUR.crypto = {};
    }
    KJUR.crypto.DSA = function() {
      var b = ASN1HEX, e = b.getVbyList, d = b.getVbyListEx, a = b.isASN1HEX, c = BigInteger;
      this.p = null;
      this.q = null;
      this.g = null;
      this.y = null;
      this.x = null;
      this.type = "DSA";
      this.isPrivate = false;
      this.isPublic = false;
      this.setPrivate = function(j, i, h, k, f) {
        this.isPrivate = true;
        this.p = j;
        this.q = i;
        this.g = h;
        this.y = k;
        this.x = f;
      };
      this.setPrivateHex = function(i, g, k, n, o) {
        var h, f, j, l, m;
        h = new BigInteger(i, 16);
        f = new BigInteger(g, 16);
        j = new BigInteger(k, 16);
        if (typeof n === "string" && n.length > 1) {
          l = new BigInteger(n, 16);
        } else {
          l = null;
        }
        m = new BigInteger(o, 16);
        this.setPrivate(h, f, j, l, m);
      };
      this.setPublic = function(i, h, f, j) {
        this.isPublic = true;
        this.p = i;
        this.q = h;
        this.g = f;
        this.y = j;
        this.x = null;
      };
      this.setPublicHex = function(k, j, i, l) {
        var g, f, m, h;
        g = new BigInteger(k, 16);
        f = new BigInteger(j, 16);
        m = new BigInteger(i, 16);
        h = new BigInteger(l, 16);
        this.setPublic(g, f, m, h);
      };
      this.signWithMessageHash = function(j) {
        var i = this.p;
        var h = this.q;
        var m = this.g;
        var o = this.y;
        var t2 = this.x;
        var l = KJUR.crypto.Util.getRandomBigIntegerMinToMax(BigInteger.ONE.add(BigInteger.ONE), h.subtract(BigInteger.ONE));
        var u = j.substr(0, h.bitLength() / 4);
        var n = new BigInteger(u, 16);
        var f = m.modPow(l, i).mod(h);
        var w = l.modInverse(h).multiply(n.add(t2.multiply(f))).mod(h);
        var v = KJUR.asn1.ASN1Util.jsonToASN1HEX({ seq: [{ "int": { bigint: f } }, { "int": { bigint: w } }] });
        return v;
      };
      this.verifyWithMessageHash = function(m, l) {
        var j = this.p;
        var h = this.q;
        var o = this.g;
        var u = this.y;
        var n = this.parseASN1Signature(l);
        var f = n[0];
        var C = n[1];
        var B = m.substr(0, h.bitLength() / 4);
        var t2 = new BigInteger(B, 16);
        if (BigInteger.ZERO.compareTo(f) > 0 || f.compareTo(h) > 0) {
          throw "invalid DSA signature";
        }
        if (BigInteger.ZERO.compareTo(C) >= 0 || C.compareTo(h) > 0) {
          throw "invalid DSA signature";
        }
        var x = C.modInverse(h);
        var k = t2.multiply(x).mod(h);
        var i = f.multiply(x).mod(h);
        var A = o.modPow(k, j).multiply(u.modPow(i, j)).mod(j).mod(h);
        return A.compareTo(f) == 0;
      };
      this.parseASN1Signature = function(f) {
        try {
          var i = new c(d(f, 0, [0], "02"), 16);
          var h = new c(d(f, 0, [1], "02"), 16);
          return [i, h];
        } catch (g) {
          throw new Error("malformed ASN.1 DSA signature");
        }
      };
      this.readPKCS5PrvKeyHex = function(j) {
        var k, i, g, l, m;
        if (a(j) === false) {
          throw new Error("not ASN.1 hex string");
        }
        try {
          k = d(j, 0, [1], "02");
          i = d(j, 0, [2], "02");
          g = d(j, 0, [3], "02");
          l = d(j, 0, [4], "02");
          m = d(j, 0, [5], "02");
        } catch (f) {
          throw new Error("malformed PKCS#1/5 plain DSA private key");
        }
        this.setPrivateHex(k, i, g, l, m);
      };
      this.readPKCS8PrvKeyHex = function(j) {
        var k, i, g, l;
        if (a(j) === false) {
          throw new Error("not ASN.1 hex string");
        }
        try {
          k = d(j, 0, [1, 1, 0], "02");
          i = d(j, 0, [1, 1, 1], "02");
          g = d(j, 0, [1, 1, 2], "02");
          l = d(j, 0, [2, 0], "02");
        } catch (f) {
          throw new Error("malformed PKCS#8 plain DSA private key");
        }
        this.setPrivateHex(k, i, g, null, l);
      };
      this.readPKCS8PubKeyHex = function(j) {
        var k, i, g, l;
        if (a(j) === false) {
          throw new Error("not ASN.1 hex string");
        }
        try {
          k = d(j, 0, [0, 1, 0], "02");
          i = d(j, 0, [0, 1, 1], "02");
          g = d(j, 0, [0, 1, 2], "02");
          l = d(j, 0, [1, 0], "02");
        } catch (f) {
          throw new Error("malformed PKCS#8 DSA public key");
        }
        this.setPublicHex(k, i, g, l);
      };
      this.readCertPubKeyHex = function(j, m) {
        var k, i, g, l;
        if (a(j) === false) {
          throw new Error("not ASN.1 hex string");
        }
        try {
          k = d(j, 0, [0, 5, 0, 1, 0], "02");
          i = d(j, 0, [0, 5, 0, 1, 1], "02");
          g = d(j, 0, [0, 5, 0, 1, 2], "02");
          l = d(j, 0, [0, 5, 1, 0], "02");
        } catch (f) {
          throw new Error("malformed X.509 certificate DSA public key");
        }
        this.setPublicHex(k, i, g, l);
      };
    };
    var KEYUTIL = function() {
      var d = function(p, r, q) {
        return k(CryptoJS.AES, p, r, q);
      };
      var e = function(p, r, q) {
        return k(CryptoJS.TripleDES, p, r, q);
      };
      var a = function(p, r, q) {
        return k(CryptoJS.DES, p, r, q);
      };
      var k = function(s, x, u, q) {
        var r = CryptoJS.enc.Hex.parse(x);
        var w = CryptoJS.enc.Hex.parse(u);
        var p = CryptoJS.enc.Hex.parse(q);
        var t2 = {};
        t2.key = w;
        t2.iv = p;
        t2.ciphertext = r;
        var v = s.decrypt(t2, w, { iv: p });
        return CryptoJS.enc.Hex.stringify(v);
      };
      var l = function(p, r, q) {
        return g(CryptoJS.AES, p, r, q);
      };
      var o = function(p, r, q) {
        return g(CryptoJS.TripleDES, p, r, q);
      };
      var f = function(p, r, q) {
        return g(CryptoJS.DES, p, r, q);
      };
      var g = function(t2, y, v, q) {
        var s = CryptoJS.enc.Hex.parse(y);
        var x = CryptoJS.enc.Hex.parse(v);
        var p = CryptoJS.enc.Hex.parse(q);
        var w = t2.encrypt(s, x, { iv: p });
        var r = CryptoJS.enc.Hex.parse(w.toString());
        var u = CryptoJS.enc.Base64.stringify(r);
        return u;
      };
      var i = { "AES-256-CBC": { proc: d, eproc: l, keylen: 32, ivlen: 16 }, "AES-192-CBC": { proc: d, eproc: l, keylen: 24, ivlen: 16 }, "AES-128-CBC": { proc: d, eproc: l, keylen: 16, ivlen: 16 }, "DES-EDE3-CBC": { proc: e, eproc: o, keylen: 24, ivlen: 8 }, "DES-CBC": { proc: a, eproc: f, keylen: 8, ivlen: 8 } };
      var c = function(p) {
        return i[p]["proc"];
      };
      var m = function(p) {
        var r = CryptoJS.lib.WordArray.random(p);
        var q = CryptoJS.enc.Hex.stringify(r);
        return q;
      };
      var n = function(v) {
        var w = {};
        var q = v.match(new RegExp("DEK-Info: ([^,]+),([0-9A-Fa-f]+)", "m"));
        if (q) {
          w.cipher = q[1];
          w.ivsalt = q[2];
        }
        var p = v.match(new RegExp("-----BEGIN ([A-Z]+) PRIVATE KEY-----"));
        if (p) {
          w.type = p[1];
        }
        var u = -1;
        var x = 0;
        if (v.indexOf("\r\n\r\n") != -1) {
          u = v.indexOf("\r\n\r\n");
          x = 2;
        }
        if (v.indexOf("\n\n") != -1) {
          u = v.indexOf("\n\n");
          x = 1;
        }
        var t2 = v.indexOf("-----END");
        if (u != -1 && t2 != -1) {
          var r = v.substring(u + x * 2, t2 - x);
          r = r.replace(/\s+/g, "");
          w.data = r;
        }
        return w;
      };
      var j = function(q, y, p) {
        var v = p.substring(0, 16);
        var t2 = CryptoJS.enc.Hex.parse(v);
        var r = CryptoJS.enc.Utf8.parse(y);
        var u = i[q]["keylen"] + i[q]["ivlen"];
        var x = "";
        var w = null;
        for (; ; ) {
          var s = CryptoJS.algo.MD5.create();
          if (w != null) {
            s.update(w);
          }
          s.update(r);
          s.update(t2);
          w = s.finalize();
          x = x + CryptoJS.enc.Hex.stringify(w);
          if (x.length >= u * 2) {
            break;
          }
        }
        var z2 = {};
        z2.keyhex = x.substr(0, i[q]["keylen"] * 2);
        z2.ivhex = x.substr(i[q]["keylen"] * 2, i[q]["ivlen"] * 2);
        return z2;
      };
      var b = function(p, v, r, w) {
        var s = CryptoJS.enc.Base64.parse(p);
        var q = CryptoJS.enc.Hex.stringify(s);
        var u = i[v]["proc"];
        var t2 = u(q, r, w);
        return t2;
      };
      var h = function(p, s, q, u) {
        var r = i[s]["eproc"];
        var t2 = r(p, q, u);
        return t2;
      };
      return { version: "1.0.0", parsePKCS5PEM: function(p) {
        return n(p);
      }, getKeyAndUnusedIvByPasscodeAndIvsalt: function(q, p, r) {
        return j(q, p, r);
      }, decryptKeyB64: function(p, r, q, s) {
        return b(p, r, q, s);
      }, getDecryptedKeyHex: function(y, x) {
        var q = n(y);
        var t2 = q.type;
        var r = q.cipher;
        var p = q.ivsalt;
        var s = q.data;
        var w = j(r, x, p);
        var v = w.keyhex;
        var u = b(s, r, v, p);
        return u;
      }, getEncryptedPKCS5PEMFromPrvKeyHex: function(x, s, A, t2, r) {
        var p = "";
        if (typeof t2 == "undefined" || t2 == null) {
          t2 = "AES-256-CBC";
        }
        if (typeof i[t2] == "undefined") {
          throw new Error("KEYUTIL unsupported algorithm: " + t2);
        }
        if (typeof r == "undefined" || r == null) {
          var v = i[t2]["ivlen"];
          var u = m(v);
          r = u.toUpperCase();
        }
        var z2 = j(t2, A, r);
        var y = z2.keyhex;
        var w = h(s, t2, y, r);
        var q = w.replace(/(.{64})/g, "$1\r\n");
        var p = "-----BEGIN " + x + " PRIVATE KEY-----\r\n";
        p += "Proc-Type: 4,ENCRYPTED\r\n";
        p += "DEK-Info: " + t2 + "," + r + "\r\n";
        p += "\r\n";
        p += q;
        p += "\r\n-----END " + x + " PRIVATE KEY-----\r\n";
        return p;
      }, parseHexOfEncryptedPKCS8: function(y) {
        var B = ASN1HEX;
        var z2 = B.getChildIdx;
        var w = B.getV;
        var t2 = {};
        var r = z2(y, 0);
        if (r.length != 2) {
          throw new Error("malformed format: SEQUENCE(0).items != 2: " + r.length);
        }
        t2.ciphertext = w(y, r[1]);
        var A = z2(y, r[0]);
        if (A.length != 2) {
          throw new Error("malformed format: SEQUENCE(0.0).items != 2: " + A.length);
        }
        if (w(y, A[0]) != "2a864886f70d01050d") {
          throw new Error("this only supports pkcs5PBES2");
        }
        var p = z2(y, A[1]);
        if (A.length != 2) {
          throw new Error("malformed format: SEQUENCE(0.0.1).items != 2: " + p.length);
        }
        var q = z2(y, p[1]);
        if (q.length != 2) {
          throw new Error("malformed format: SEQUENCE(0.0.1.1).items != 2: " + q.length);
        }
        if (w(y, q[0]) != "2a864886f70d0307") {
          throw "this only supports TripleDES";
        }
        t2.encryptionSchemeAlg = "TripleDES";
        t2.encryptionSchemeIV = w(y, q[1]);
        var s = z2(y, p[0]);
        if (s.length != 2) {
          throw new Error("malformed format: SEQUENCE(0.0.1.0).items != 2: " + s.length);
        }
        if (w(y, s[0]) != "2a864886f70d01050c") {
          throw new Error("this only supports pkcs5PBKDF2");
        }
        var x = z2(y, s[1]);
        if (x.length < 2) {
          throw new Error("malformed format: SEQUENCE(0.0.1.0.1).items < 2: " + x.length);
        }
        t2.pbkdf2Salt = w(y, x[0]);
        var u = w(y, x[1]);
        try {
          t2.pbkdf2Iter = parseInt(u, 16);
        } catch (v) {
          throw new Error("malformed format pbkdf2Iter: " + u);
        }
        return t2;
      }, getPBKDF2KeyHexFromParam: function(u, p) {
        var t2 = CryptoJS.enc.Hex.parse(u.pbkdf2Salt);
        var q = u.pbkdf2Iter;
        var s = CryptoJS.PBKDF2(p, t2, { keySize: 192 / 32, iterations: q });
        var r = CryptoJS.enc.Hex.stringify(s);
        return r;
      }, _getPlainPKCS8HexFromEncryptedPKCS8PEM: function(x, y) {
        var r = pemtohex(x, "ENCRYPTED PRIVATE KEY");
        var p = this.parseHexOfEncryptedPKCS8(r);
        var u = KEYUTIL.getPBKDF2KeyHexFromParam(p, y);
        var v = {};
        v.ciphertext = CryptoJS.enc.Hex.parse(p.ciphertext);
        var t2 = CryptoJS.enc.Hex.parse(u);
        var s = CryptoJS.enc.Hex.parse(p.encryptionSchemeIV);
        var w = CryptoJS.TripleDES.decrypt(v, t2, { iv: s });
        var q = CryptoJS.enc.Hex.stringify(w);
        return q;
      }, getKeyFromEncryptedPKCS8PEM: function(s, q) {
        var p = this._getPlainPKCS8HexFromEncryptedPKCS8PEM(s, q);
        var r = this.getKeyFromPlainPrivatePKCS8Hex(p);
        return r;
      }, parsePlainPrivatePKCS8Hex: function(s) {
        var v = ASN1HEX;
        var u = v.getChildIdx;
        var t2 = v.getV;
        var q = {};
        q.algparam = null;
        if (s.substr(0, 2) != "30") {
          throw new Error("malformed plain PKCS8 private key(code:001)");
        }
        var r = u(s, 0);
        if (r.length < 3) {
          throw new Error("malformed plain PKCS8 private key(code:002)");
        }
        if (s.substr(r[1], 2) != "30") {
          throw new Error("malformed PKCS8 private key(code:003)");
        }
        var p = u(s, r[1]);
        if (p.length != 2) {
          throw new Error("malformed PKCS8 private key(code:004)");
        }
        if (s.substr(p[0], 2) != "06") {
          throw new Error("malformed PKCS8 private key(code:005)");
        }
        q.algoid = t2(s, p[0]);
        if (s.substr(p[1], 2) == "06") {
          q.algparam = t2(s, p[1]);
        }
        if (s.substr(r[2], 2) != "04") {
          throw new Error("malformed PKCS8 private key(code:006)");
        }
        q.keyidx = v.getVidx(s, r[2]);
        return q;
      }, getKeyFromPlainPrivatePKCS8PEM: function(q) {
        var p = pemtohex(q, "PRIVATE KEY");
        var r = this.getKeyFromPlainPrivatePKCS8Hex(p);
        return r;
      }, getKeyFromPlainPrivatePKCS8Hex: function(p) {
        var q = this.parsePlainPrivatePKCS8Hex(p);
        var r;
        if (q.algoid == "2a864886f70d010101") {
          r = new RSAKey();
        } else {
          if (q.algoid == "2a8648ce380401") {
            r = new KJUR.crypto.DSA();
          } else {
            if (q.algoid == "2a8648ce3d0201") {
              r = new KJUR.crypto.ECDSA();
            } else {
              throw new Error("unsupported private key algorithm");
            }
          }
        }
        r.readPKCS8PrvKeyHex(p);
        return r;
      }, _getKeyFromPublicPKCS8Hex: function(q) {
        var p;
        var r = ASN1HEX.getVbyList(q, 0, [0, 0], "06");
        if (r === "2a864886f70d010101") {
          p = new RSAKey();
        } else {
          if (r === "2a8648ce380401") {
            p = new KJUR.crypto.DSA();
          } else {
            if (r === "2a8648ce3d0201") {
              p = new KJUR.crypto.ECDSA();
            } else {
              throw new Error("unsupported PKCS#8 public key hex");
            }
          }
        }
        p.readPKCS8PubKeyHex(q);
        return p;
      }, parsePublicRawRSAKeyHex: function(r) {
        var u = ASN1HEX;
        var t2 = u.getChildIdx;
        var s = u.getV;
        var p = {};
        if (r.substr(0, 2) != "30") {
          throw new Error("malformed RSA key(code:001)");
        }
        var q = t2(r, 0);
        if (q.length != 2) {
          throw new Error("malformed RSA key(code:002)");
        }
        if (r.substr(q[0], 2) != "02") {
          throw new Error("malformed RSA key(code:003)");
        }
        p.n = s(r, q[0]);
        if (r.substr(q[1], 2) != "02") {
          throw new Error("malformed RSA key(code:004)");
        }
        p.e = s(r, q[1]);
        return p;
      }, parsePublicPKCS8Hex: function(t2) {
        var v = ASN1HEX;
        var u = v.getChildIdx;
        var s = v.getV;
        var q = {};
        q.algparam = null;
        var r = u(t2, 0);
        if (r.length != 2) {
          throw new Error("outer DERSequence shall have 2 elements: " + r.length);
        }
        var w = r[0];
        if (t2.substr(w, 2) != "30") {
          throw new Error("malformed PKCS8 public key(code:001)");
        }
        var p = u(t2, w);
        if (p.length != 2) {
          throw new Error("malformed PKCS8 public key(code:002)");
        }
        if (t2.substr(p[0], 2) != "06") {
          throw new Error("malformed PKCS8 public key(code:003)");
        }
        q.algoid = s(t2, p[0]);
        if (t2.substr(p[1], 2) == "06") {
          q.algparam = s(t2, p[1]);
        } else {
          if (t2.substr(p[1], 2) == "30") {
            q.algparam = {};
            q.algparam.p = v.getVbyList(t2, p[1], [0], "02");
            q.algparam.q = v.getVbyList(t2, p[1], [1], "02");
            q.algparam.g = v.getVbyList(t2, p[1], [2], "02");
          }
        }
        if (t2.substr(r[1], 2) != "03") {
          throw new Error("malformed PKCS8 public key(code:004)");
        }
        q.key = s(t2, r[1]).substr(2);
        return q;
      } };
    }();
    KEYUTIL.getKey = function(l, k, n) {
      var G = ASN1HEX, L = G.getChildIdx, v = G.getV, d = G.getVbyList, c = KJUR.crypto, i = c.ECDSA, C = c.DSA, w = RSAKey, M = pemtohex, F = KEYUTIL;
      if (typeof w != "undefined" && l instanceof w) {
        return l;
      }
      if (typeof i != "undefined" && l instanceof i) {
        return l;
      }
      if (typeof C != "undefined" && l instanceof C) {
        return l;
      }
      if (l.curve !== void 0 && l.xy !== void 0 && l.d === void 0) {
        return new i({ pub: l.xy, curve: l.curve });
      }
      if (l.curve !== void 0 && l.d !== void 0) {
        return new i({ prv: l.d, curve: l.curve });
      }
      if (l.kty === void 0 && l.n !== void 0 && l.e !== void 0 && l.d === void 0) {
        var P = new w();
        P.setPublic(l.n, l.e);
        return P;
      }
      if (l.kty === void 0 && l.n !== void 0 && l.e !== void 0 && l.d !== void 0 && l.p !== void 0 && l.q !== void 0 && l.dp !== void 0 && l.dq !== void 0 && l.co !== void 0 && l.qi === void 0) {
        var P = new w();
        P.setPrivateEx(l.n, l.e, l.d, l.p, l.q, l.dp, l.dq, l.co);
        return P;
      }
      if (l.kty === void 0 && l.n !== void 0 && l.e !== void 0 && l.d !== void 0 && l.p === void 0) {
        var P = new w();
        P.setPrivate(l.n, l.e, l.d);
        return P;
      }
      if (l.p !== void 0 && l.q !== void 0 && l.g !== void 0 && l.y !== void 0 && l.x === void 0) {
        var P = new C();
        P.setPublic(l.p, l.q, l.g, l.y);
        return P;
      }
      if (l.p !== void 0 && l.q !== void 0 && l.g !== void 0 && l.y !== void 0 && l.x !== void 0) {
        var P = new C();
        P.setPrivate(l.p, l.q, l.g, l.y, l.x);
        return P;
      }
      if (l.kty === "RSA" && l.n !== void 0 && l.e !== void 0 && l.d === void 0) {
        var P = new w();
        P.setPublic(b64utohex(l.n), b64utohex(l.e));
        return P;
      }
      if (l.kty === "RSA" && l.n !== void 0 && l.e !== void 0 && l.d !== void 0 && l.p !== void 0 && l.q !== void 0 && l.dp !== void 0 && l.dq !== void 0 && l.qi !== void 0) {
        var P = new w();
        P.setPrivateEx(b64utohex(l.n), b64utohex(l.e), b64utohex(l.d), b64utohex(l.p), b64utohex(l.q), b64utohex(l.dp), b64utohex(l.dq), b64utohex(l.qi));
        return P;
      }
      if (l.kty === "RSA" && l.n !== void 0 && l.e !== void 0 && l.d !== void 0) {
        var P = new w();
        P.setPrivate(b64utohex(l.n), b64utohex(l.e), b64utohex(l.d));
        return P;
      }
      if (l.kty === "EC" && l.crv !== void 0 && l.x !== void 0 && l.y !== void 0 && l.d === void 0) {
        var j = new i({ curve: l.crv });
        var t2 = j.ecparams.keylen / 4;
        var B = ("0000000000" + b64utohex(l.x)).slice(-t2);
        var z2 = ("0000000000" + b64utohex(l.y)).slice(-t2);
        var u = "04" + B + z2;
        j.setPublicKeyHex(u);
        return j;
      }
      if (l.kty === "EC" && l.crv !== void 0 && l.x !== void 0 && l.y !== void 0 && l.d !== void 0) {
        var j = new i({ curve: l.crv });
        var t2 = j.ecparams.keylen / 4;
        var B = ("0000000000" + b64utohex(l.x)).slice(-t2);
        var z2 = ("0000000000" + b64utohex(l.y)).slice(-t2);
        var u = "04" + B + z2;
        var b = ("0000000000" + b64utohex(l.d)).slice(-t2);
        j.setPublicKeyHex(u);
        j.setPrivateKeyHex(b);
        return j;
      }
      if (n === "pkcs5prv") {
        var J = l, G = ASN1HEX, N, P;
        N = L(J, 0);
        if (N.length === 9) {
          P = new w();
          P.readPKCS5PrvKeyHex(J);
        } else {
          if (N.length === 6) {
            P = new C();
            P.readPKCS5PrvKeyHex(J);
          } else {
            if (N.length > 2 && J.substr(N[1], 2) === "04") {
              P = new i();
              P.readPKCS5PrvKeyHex(J);
            } else {
              throw new Error("unsupported PKCS#1/5 hexadecimal key");
            }
          }
        }
        return P;
      }
      if (n === "pkcs8prv") {
        var P = F.getKeyFromPlainPrivatePKCS8Hex(l);
        return P;
      }
      if (n === "pkcs8pub") {
        return F._getKeyFromPublicPKCS8Hex(l);
      }
      if (n === "x509pub") {
        return X509.getPublicKeyFromCertHex(l);
      }
      if (l.indexOf("-END CERTIFICATE-", 0) != -1 || l.indexOf("-END X509 CERTIFICATE-", 0) != -1 || l.indexOf("-END TRUSTED CERTIFICATE-", 0) != -1) {
        return X509.getPublicKeyFromCertPEM(l);
      }
      if (l.indexOf("-END PUBLIC KEY-") != -1) {
        var O = pemtohex(l, "PUBLIC KEY");
        return F._getKeyFromPublicPKCS8Hex(O);
      }
      if (l.indexOf("-END RSA PRIVATE KEY-") != -1 && l.indexOf("4,ENCRYPTED") == -1) {
        var m = M(l, "RSA PRIVATE KEY");
        return F.getKey(m, null, "pkcs5prv");
      }
      if (l.indexOf("-END DSA PRIVATE KEY-") != -1 && l.indexOf("4,ENCRYPTED") == -1) {
        var I = M(l, "DSA PRIVATE KEY");
        var E = d(I, 0, [1], "02");
        var D = d(I, 0, [2], "02");
        var K = d(I, 0, [3], "02");
        var r = d(I, 0, [4], "02");
        var s = d(I, 0, [5], "02");
        var P = new C();
        P.setPrivate(new BigInteger(E, 16), new BigInteger(D, 16), new BigInteger(K, 16), new BigInteger(r, 16), new BigInteger(s, 16));
        return P;
      }
      if (l.indexOf("-END EC PRIVATE KEY-") != -1 && l.indexOf("4,ENCRYPTED") == -1) {
        var m = M(l, "EC PRIVATE KEY");
        return F.getKey(m, null, "pkcs5prv");
      }
      if (l.indexOf("-END PRIVATE KEY-") != -1) {
        return F.getKeyFromPlainPrivatePKCS8PEM(l);
      }
      if (l.indexOf("-END RSA PRIVATE KEY-") != -1 && l.indexOf("4,ENCRYPTED") != -1) {
        var o = F.getDecryptedKeyHex(l, k);
        var H = new RSAKey();
        H.readPKCS5PrvKeyHex(o);
        return H;
      }
      if (l.indexOf("-END EC PRIVATE KEY-") != -1 && l.indexOf("4,ENCRYPTED") != -1) {
        var I = F.getDecryptedKeyHex(l, k);
        var P = d(I, 0, [1], "04");
        var f = d(I, 0, [2, 0], "06");
        var A = d(I, 0, [3, 0], "03").substr(2);
        var e = "";
        if (KJUR.crypto.OID.oidhex2name[f] !== void 0) {
          e = KJUR.crypto.OID.oidhex2name[f];
        } else {
          throw new Error("undefined OID(hex) in KJUR.crypto.OID: " + f);
        }
        var j = new i({ curve: e });
        j.setPublicKeyHex(A);
        j.setPrivateKeyHex(P);
        j.isPublic = false;
        return j;
      }
      if (l.indexOf("-END DSA PRIVATE KEY-") != -1 && l.indexOf("4,ENCRYPTED") != -1) {
        var I = F.getDecryptedKeyHex(l, k);
        var E = d(I, 0, [1], "02");
        var D = d(I, 0, [2], "02");
        var K = d(I, 0, [3], "02");
        var r = d(I, 0, [4], "02");
        var s = d(I, 0, [5], "02");
        var P = new C();
        P.setPrivate(new BigInteger(E, 16), new BigInteger(D, 16), new BigInteger(K, 16), new BigInteger(r, 16), new BigInteger(s, 16));
        return P;
      }
      if (l.indexOf("-END ENCRYPTED PRIVATE KEY-") != -1) {
        return F.getKeyFromEncryptedPKCS8PEM(l, k);
      }
      throw new Error("not supported argument");
    };
    KEYUTIL.generateKeypair = function(a, c) {
      if (a == "RSA") {
        var b = c;
        var h = new RSAKey();
        h.generate(b, "10001");
        h.isPrivate = true;
        h.isPublic = true;
        var f = new RSAKey();
        var e = h.n.toString(16);
        var i = h.e.toString(16);
        f.setPublic(e, i);
        f.isPrivate = false;
        f.isPublic = true;
        var k = {};
        k.prvKeyObj = h;
        k.pubKeyObj = f;
        return k;
      } else {
        if (a == "EC") {
          var d = c;
          var g = new KJUR.crypto.ECDSA({ curve: d });
          var j = g.generateKeyPairHex();
          var h = new KJUR.crypto.ECDSA({ curve: d });
          h.setPublicKeyHex(j.ecpubhex);
          h.setPrivateKeyHex(j.ecprvhex);
          h.isPrivate = true;
          h.isPublic = false;
          var f = new KJUR.crypto.ECDSA({ curve: d });
          f.setPublicKeyHex(j.ecpubhex);
          f.isPrivate = false;
          f.isPublic = true;
          var k = {};
          k.prvKeyObj = h;
          k.pubKeyObj = f;
          return k;
        } else {
          throw new Error("unknown algorithm: " + a);
        }
      }
    };
    KEYUTIL.getPEM = function(b, D, y, m, q, j) {
      var F = KJUR, k = F.asn1, z2 = k.DERObjectIdentifier, f = k.DERInteger, l = k.ASN1Util.newObject, a = k.x509, C = a.SubjectPublicKeyInfo, e = F.crypto, u = e.DSA, r = e.ECDSA, n = RSAKey;
      function A(s) {
        var G = l({ seq: [{ "int": 0 }, { "int": { bigint: s.n } }, { "int": s.e }, { "int": { bigint: s.d } }, { "int": { bigint: s.p } }, { "int": { bigint: s.q } }, { "int": { bigint: s.dmp1 } }, { "int": { bigint: s.dmq1 } }, { "int": { bigint: s.coeff } }] });
        return G;
      }
      function B(G) {
        var s = l({ seq: [{ "int": 1 }, { octstr: { hex: G.prvKeyHex } }, { tag: ["a0", true, { oid: { name: G.curveName } }] }, { tag: ["a1", true, { bitstr: { hex: "00" + G.pubKeyHex } }] }] });
        return s;
      }
      function x(s) {
        var G = l({ seq: [{ "int": 0 }, { "int": { bigint: s.p } }, { "int": { bigint: s.q } }, { "int": { bigint: s.g } }, { "int": { bigint: s.y } }, { "int": { bigint: s.x } }] });
        return G;
      }
      if ((n !== void 0 && b instanceof n || u !== void 0 && b instanceof u || r !== void 0 && b instanceof r) && b.isPublic == true && (D === void 0 || D == "PKCS8PUB")) {
        var E = new C(b);
        var w = E.getEncodedHex();
        return hextopem(w, "PUBLIC KEY");
      }
      if (D == "PKCS1PRV" && n !== void 0 && b instanceof n && (y === void 0 || y == null) && b.isPrivate == true) {
        var E = A(b);
        var w = E.getEncodedHex();
        return hextopem(w, "RSA PRIVATE KEY");
      }
      if (D == "PKCS1PRV" && r !== void 0 && b instanceof r && (y === void 0 || y == null) && b.isPrivate == true) {
        var i = new z2({ name: b.curveName });
        var v = i.getEncodedHex();
        var h = B(b);
        var t2 = h.getEncodedHex();
        var p = "";
        p += hextopem(v, "EC PARAMETERS");
        p += hextopem(t2, "EC PRIVATE KEY");
        return p;
      }
      if (D == "PKCS1PRV" && u !== void 0 && b instanceof u && (y === void 0 || y == null) && b.isPrivate == true) {
        var E = x(b);
        var w = E.getEncodedHex();
        return hextopem(w, "DSA PRIVATE KEY");
      }
      if (D == "PKCS5PRV" && n !== void 0 && b instanceof n && (y !== void 0 && y != null) && b.isPrivate == true) {
        var E = A(b);
        var w = E.getEncodedHex();
        if (m === void 0) {
          m = "DES-EDE3-CBC";
        }
        return this.getEncryptedPKCS5PEMFromPrvKeyHex("RSA", w, y, m, j);
      }
      if (D == "PKCS5PRV" && r !== void 0 && b instanceof r && (y !== void 0 && y != null) && b.isPrivate == true) {
        var E = B(b);
        var w = E.getEncodedHex();
        if (m === void 0) {
          m = "DES-EDE3-CBC";
        }
        return this.getEncryptedPKCS5PEMFromPrvKeyHex("EC", w, y, m, j);
      }
      if (D == "PKCS5PRV" && u !== void 0 && b instanceof u && (y !== void 0 && y != null) && b.isPrivate == true) {
        var E = x(b);
        var w = E.getEncodedHex();
        if (m === void 0) {
          m = "DES-EDE3-CBC";
        }
        return this.getEncryptedPKCS5PEMFromPrvKeyHex("DSA", w, y, m, j);
      }
      var o = function(G, s) {
        var I = c(G, s);
        var H = new l({ seq: [{ seq: [{ oid: { name: "pkcs5PBES2" } }, { seq: [{ seq: [{ oid: { name: "pkcs5PBKDF2" } }, { seq: [{ octstr: { hex: I.pbkdf2Salt } }, { "int": I.pbkdf2Iter }] }] }, { seq: [{ oid: { name: "des-EDE3-CBC" } }, { octstr: { hex: I.encryptionSchemeIV } }] }] }] }, { octstr: { hex: I.ciphertext } }] });
        return H.getEncodedHex();
      };
      var c = function(N, O) {
        var H = 100;
        var M = CryptoJS.lib.WordArray.random(8);
        var L = "DES-EDE3-CBC";
        var s = CryptoJS.lib.WordArray.random(8);
        var I = CryptoJS.PBKDF2(O, M, { keySize: 192 / 32, iterations: H });
        var J = CryptoJS.enc.Hex.parse(N);
        var K = CryptoJS.TripleDES.encrypt(J, I, { iv: s }) + "";
        var G = {};
        G.ciphertext = K;
        G.pbkdf2Salt = CryptoJS.enc.Hex.stringify(M);
        G.pbkdf2Iter = H;
        G.encryptionSchemeAlg = L;
        G.encryptionSchemeIV = CryptoJS.enc.Hex.stringify(s);
        return G;
      };
      if (D == "PKCS8PRV" && n != void 0 && b instanceof n && b.isPrivate == true) {
        var g = A(b);
        var d = g.getEncodedHex();
        var E = l({ seq: [{ "int": 0 }, { seq: [{ oid: { name: "rsaEncryption" } }, { "null": true }] }, { octstr: { hex: d } }] });
        var w = E.getEncodedHex();
        if (y === void 0 || y == null) {
          return hextopem(w, "PRIVATE KEY");
        } else {
          var t2 = o(w, y);
          return hextopem(t2, "ENCRYPTED PRIVATE KEY");
        }
      }
      if (D == "PKCS8PRV" && r !== void 0 && b instanceof r && b.isPrivate == true) {
        var g = new l({ seq: [{ "int": 1 }, { octstr: { hex: b.prvKeyHex } }, { tag: ["a1", true, { bitstr: { hex: "00" + b.pubKeyHex } }] }] });
        var d = g.getEncodedHex();
        var E = l({ seq: [{ "int": 0 }, { seq: [{ oid: { name: "ecPublicKey" } }, { oid: { name: b.curveName } }] }, { octstr: { hex: d } }] });
        var w = E.getEncodedHex();
        if (y === void 0 || y == null) {
          return hextopem(w, "PRIVATE KEY");
        } else {
          var t2 = o(w, y);
          return hextopem(t2, "ENCRYPTED PRIVATE KEY");
        }
      }
      if (D == "PKCS8PRV" && u !== void 0 && b instanceof u && b.isPrivate == true) {
        var g = new f({ bigint: b.x });
        var d = g.getEncodedHex();
        var E = l({ seq: [{ "int": 0 }, { seq: [{ oid: { name: "dsa" } }, { seq: [{ "int": { bigint: b.p } }, { "int": { bigint: b.q } }, { "int": { bigint: b.g } }] }] }, { octstr: { hex: d } }] });
        var w = E.getEncodedHex();
        if (y === void 0 || y == null) {
          return hextopem(w, "PRIVATE KEY");
        } else {
          var t2 = o(w, y);
          return hextopem(t2, "ENCRYPTED PRIVATE KEY");
        }
      }
      throw new Error("unsupported object nor format");
    };
    KEYUTIL.getKeyFromCSRPEM = function(b) {
      var a = pemtohex(b, "CERTIFICATE REQUEST");
      var c = KEYUTIL.getKeyFromCSRHex(a);
      return c;
    };
    KEYUTIL.getKeyFromCSRHex = function(a) {
      var c = KEYUTIL.parseCSRHex(a);
      var b = KEYUTIL.getKey(c.p8pubkeyhex, null, "pkcs8pub");
      return b;
    };
    KEYUTIL.parseCSRHex = function(d) {
      var i = ASN1HEX;
      var f = i.getChildIdx;
      var c = i.getTLV;
      var b = {};
      var g = d;
      if (g.substr(0, 2) != "30") {
        throw new Error("malformed CSR(code:001)");
      }
      var e = f(g, 0);
      if (e.length < 1) {
        throw new Error("malformed CSR(code:002)");
      }
      if (g.substr(e[0], 2) != "30") {
        throw new Error("malformed CSR(code:003)");
      }
      var a = f(g, e[0]);
      if (a.length < 3) {
        throw new Error("malformed CSR(code:004)");
      }
      b.p8pubkeyhex = c(g, a[2]);
      return b;
    };
    KEYUTIL.getKeyID = function(f) {
      var c = KEYUTIL;
      var e = ASN1HEX;
      if (typeof f === "string" && f.indexOf("BEGIN ") != -1) {
        f = c.getKey(f);
      }
      var d = pemtohex(c.getPEM(f));
      var b = e.getIdxbyList(d, 0, [1]);
      var a = e.getV(d, b).substring(2);
      return KJUR.crypto.Util.hashHex(a, "sha1");
    };
    KEYUTIL.getJWKFromKey = function(d) {
      var b = {};
      if (d instanceof RSAKey && d.isPrivate) {
        b.kty = "RSA";
        b.n = hextob64u(d.n.toString(16));
        b.e = hextob64u(d.e.toString(16));
        b.d = hextob64u(d.d.toString(16));
        b.p = hextob64u(d.p.toString(16));
        b.q = hextob64u(d.q.toString(16));
        b.dp = hextob64u(d.dmp1.toString(16));
        b.dq = hextob64u(d.dmq1.toString(16));
        b.qi = hextob64u(d.coeff.toString(16));
        return b;
      } else {
        if (d instanceof RSAKey && d.isPublic) {
          b.kty = "RSA";
          b.n = hextob64u(d.n.toString(16));
          b.e = hextob64u(d.e.toString(16));
          return b;
        } else {
          if (d instanceof KJUR.crypto.ECDSA && d.isPrivate) {
            var a = d.getShortNISTPCurveName();
            if (a !== "P-256" && a !== "P-384") {
              throw new Error("unsupported curve name for JWT: " + a);
            }
            var c = d.getPublicKeyXYHex();
            b.kty = "EC";
            b.crv = a;
            b.x = hextob64u(c.x);
            b.y = hextob64u(c.y);
            b.d = hextob64u(d.prvKeyHex);
            return b;
          } else {
            if (d instanceof KJUR.crypto.ECDSA && d.isPublic) {
              var a = d.getShortNISTPCurveName();
              if (a !== "P-256" && a !== "P-384") {
                throw new Error("unsupported curve name for JWT: " + a);
              }
              var c = d.getPublicKeyXYHex();
              b.kty = "EC";
              b.crv = a;
              b.x = hextob64u(c.x);
              b.y = hextob64u(c.y);
              return b;
            }
          }
        }
      }
      throw new Error("not supported key object");
    };
    RSAKey.getPosArrayOfChildrenFromHex = function(a) {
      return ASN1HEX.getChildIdx(a, 0);
    };
    RSAKey.getHexValueArrayOfChildrenFromHex = function(f) {
      var n = ASN1HEX;
      var i = n.getV;
      var k = RSAKey.getPosArrayOfChildrenFromHex(f);
      var e = i(f, k[0]);
      var j = i(f, k[1]);
      var b = i(f, k[2]);
      var c = i(f, k[3]);
      var h = i(f, k[4]);
      var g = i(f, k[5]);
      var m = i(f, k[6]);
      var l = i(f, k[7]);
      var d = i(f, k[8]);
      var k = new Array();
      k.push(e, j, b, c, h, g, m, l, d);
      return k;
    };
    RSAKey.prototype.readPrivateKeyFromPEMString = function(d) {
      var c = pemtohex(d);
      var b = RSAKey.getHexValueArrayOfChildrenFromHex(c);
      this.setPrivateEx(b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8]);
    };
    RSAKey.prototype.readPKCS5PrvKeyHex = function(c) {
      var b = RSAKey.getHexValueArrayOfChildrenFromHex(c);
      this.setPrivateEx(b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8]);
    };
    RSAKey.prototype.readPKCS8PrvKeyHex = function(e) {
      var c, i, k, b, a, f, d, j;
      var m = ASN1HEX;
      var l = m.getVbyListEx;
      if (m.isASN1HEX(e) === false) {
        throw new Error("not ASN.1 hex string");
      }
      try {
        c = l(e, 0, [2, 0, 1], "02");
        i = l(e, 0, [2, 0, 2], "02");
        k = l(e, 0, [2, 0, 3], "02");
        b = l(e, 0, [2, 0, 4], "02");
        a = l(e, 0, [2, 0, 5], "02");
        f = l(e, 0, [2, 0, 6], "02");
        d = l(e, 0, [2, 0, 7], "02");
        j = l(e, 0, [2, 0, 8], "02");
      } catch (g) {
        throw new Error("malformed PKCS#8 plain RSA private key");
      }
      this.setPrivateEx(c, i, k, b, a, f, d, j);
    };
    RSAKey.prototype.readPKCS5PubKeyHex = function(c) {
      var e = ASN1HEX;
      var b = e.getV;
      if (e.isASN1HEX(c) === false) {
        throw new Error("keyHex is not ASN.1 hex string");
      }
      var a = e.getChildIdx(c, 0);
      if (a.length !== 2 || c.substr(a[0], 2) !== "02" || c.substr(a[1], 2) !== "02") {
        throw new Error("wrong hex for PKCS#5 public key");
      }
      var f = b(c, a[0]);
      var d = b(c, a[1]);
      this.setPublic(f, d);
    };
    RSAKey.prototype.readPKCS8PubKeyHex = function(b) {
      var c = ASN1HEX;
      if (c.isASN1HEX(b) === false) {
        throw new Error("not ASN.1 hex string");
      }
      if (c.getTLVbyListEx(b, 0, [0, 0]) !== "06092a864886f70d010101") {
        throw new Error("not PKCS8 RSA public key");
      }
      var a = c.getTLVbyListEx(b, 0, [1, 0]);
      this.readPKCS5PubKeyHex(a);
    };
    RSAKey.prototype.readCertPubKeyHex = function(b, d) {
      var a, c;
      a = new X509();
      a.readCertHex(b);
      c = a.getPublicKeyHex();
      this.readPKCS8PubKeyHex(c);
    };
    var _RE_HEXDECONLY = new RegExp("[^0-9a-f]", "gi");
    function _zeroPaddingOfSignature(e, d) {
      var c = "";
      var a = d / 4 - e.length;
      for (var b = 0; b < a; b++) {
        c = c + "0";
      }
      return c + e;
    }
    RSAKey.prototype.sign = function(d, a) {
      var b = function(e) {
        return KJUR.crypto.Util.hashString(e, a);
      };
      var c = b(d);
      return this.signWithMessageHash(c, a);
    };
    RSAKey.prototype.signWithMessageHash = function(e, c) {
      var f = KJUR.crypto.Util.getPaddedDigestInfoHex(e, c, this.n.bitLength());
      var b = parseBigInt(f, 16);
      var d = this.doPrivate(b);
      var a = d.toString(16);
      return _zeroPaddingOfSignature(a, this.n.bitLength());
    };
    function pss_mgf1_str(c, a, e) {
      var b = "", d = 0;
      while (b.length < a) {
        b += hextorstr(e(rstrtohex(c + String.fromCharCode.apply(String, [(d & 4278190080) >> 24, (d & 16711680) >> 16, (d & 65280) >> 8, d & 255]))));
        d += 1;
      }
      return b;
    }
    RSAKey.prototype.signPSS = function(e, a, d) {
      var c = function(f) {
        return KJUR.crypto.Util.hashHex(f, a);
      };
      var b = c(rstrtohex(e));
      if (d === void 0) {
        d = -1;
      }
      return this.signWithMessageHashPSS(b, a, d);
    };
    RSAKey.prototype.signWithMessageHashPSS = function(l, a, k) {
      var b = hextorstr(l);
      var g = b.length;
      var m = this.n.bitLength() - 1;
      var c = Math.ceil(m / 8);
      var d;
      var o = function(i) {
        return KJUR.crypto.Util.hashHex(i, a);
      };
      if (k === -1 || k === void 0) {
        k = g;
      } else {
        if (k === -2) {
          k = c - g - 2;
        } else {
          if (k < -2) {
            throw new Error("invalid salt length");
          }
        }
      }
      if (c < g + k + 2) {
        throw new Error("data too long");
      }
      var f = "";
      if (k > 0) {
        f = new Array(k);
        new SecureRandom().nextBytes(f);
        f = String.fromCharCode.apply(String, f);
      }
      var n = hextorstr(o(rstrtohex("\0\0\0\0\0\0\0\0" + b + f)));
      var j = [];
      for (d = 0; d < c - k - g - 2; d += 1) {
        j[d] = 0;
      }
      var e = String.fromCharCode.apply(String, j) + "" + f;
      var h = pss_mgf1_str(n, e.length, o);
      var q = [];
      for (d = 0; d < e.length; d += 1) {
        q[d] = e.charCodeAt(d) ^ h.charCodeAt(d);
      }
      var p = 65280 >> 8 * c - m & 255;
      q[0] &= ~p;
      for (d = 0; d < g; d++) {
        q.push(n.charCodeAt(d));
      }
      q.push(188);
      return _zeroPaddingOfSignature(this.doPrivate(new BigInteger(q)).toString(16), this.n.bitLength());
    };
    function _rsasign_getAlgNameAndHashFromHexDisgestInfo(f) {
      for (var e in KJUR.crypto.Util.DIGESTINFOHEAD) {
        var d = KJUR.crypto.Util.DIGESTINFOHEAD[e];
        var b = d.length;
        if (f.substring(0, b) == d) {
          var c = [e, f.substring(b)];
          return c;
        }
      }
      return [];
    }
    RSAKey.prototype.verify = function(f, l) {
      l = l.toLowerCase();
      if (l.match(/^[0-9a-f]+$/) == null) {
        return false;
      }
      var b = parseBigInt(l, 16);
      var k = this.n.bitLength();
      if (b.bitLength() > k) {
        return false;
      }
      var j = this.doPublic(b);
      var i = j.toString(16);
      if (i.length + 3 != k / 4) {
        return false;
      }
      var e = i.replace(/^1f+00/, "");
      var g = _rsasign_getAlgNameAndHashFromHexDisgestInfo(e);
      if (g.length == 0) {
        return false;
      }
      var d = g[0];
      var h = g[1];
      var a = function(m) {
        return KJUR.crypto.Util.hashString(m, d);
      };
      var c = a(f);
      return h == c;
    };
    RSAKey.prototype.verifyWithMessageHash = function(e, a) {
      if (a.length != Math.ceil(this.n.bitLength() / 4)) {
        return false;
      }
      var b = parseBigInt(a, 16);
      if (b.bitLength() > this.n.bitLength()) {
        return 0;
      }
      var h = this.doPublic(b);
      var g = h.toString(16).replace(/^1f+00/, "");
      var c = _rsasign_getAlgNameAndHashFromHexDisgestInfo(g);
      if (c.length == 0) {
        return false;
      }
      var d = c[0];
      var f = c[1];
      return f == e;
    };
    RSAKey.prototype.verifyPSS = function(c, b, a, f) {
      var e = function(g) {
        return KJUR.crypto.Util.hashHex(g, a);
      };
      var d = e(rstrtohex(c));
      if (f === void 0) {
        f = -1;
      }
      return this.verifyWithMessageHashPSS(d, b, a, f);
    };
    RSAKey.prototype.verifyWithMessageHashPSS = function(f, s, l, c) {
      if (s.length != Math.ceil(this.n.bitLength() / 4)) {
        return false;
      }
      var k = new BigInteger(s, 16);
      var r = function(i) {
        return KJUR.crypto.Util.hashHex(i, l);
      };
      var j = hextorstr(f);
      var h = j.length;
      var g = this.n.bitLength() - 1;
      var m = Math.ceil(g / 8);
      var q;
      if (c === -1 || c === void 0) {
        c = h;
      } else {
        if (c === -2) {
          c = m - h - 2;
        } else {
          if (c < -2) {
            throw new Error("invalid salt length");
          }
        }
      }
      if (m < h + c + 2) {
        throw new Error("data too long");
      }
      var a = this.doPublic(k).toByteArray();
      for (q = 0; q < a.length; q += 1) {
        a[q] &= 255;
      }
      while (a.length < m) {
        a.unshift(0);
      }
      if (a[m - 1] !== 188) {
        throw new Error("encoded message does not end in 0xbc");
      }
      a = String.fromCharCode.apply(String, a);
      var d = a.substr(0, m - h - 1);
      var e = a.substr(d.length, h);
      var p = 65280 >> 8 * m - g & 255;
      if ((d.charCodeAt(0) & p) !== 0) {
        throw new Error("bits beyond keysize not zero");
      }
      var n = pss_mgf1_str(e, d.length, r);
      var o = [];
      for (q = 0; q < d.length; q += 1) {
        o[q] = d.charCodeAt(q) ^ n.charCodeAt(q);
      }
      o[0] &= ~p;
      var b = m - h - c - 2;
      for (q = 0; q < b; q += 1) {
        if (o[q] !== 0) {
          throw new Error("leftmost octets not zero");
        }
      }
      if (o[b] !== 1) {
        throw new Error("0x01 marker not found");
      }
      return e === hextorstr(r(rstrtohex("\0\0\0\0\0\0\0\0" + j + String.fromCharCode.apply(String, o.slice(-c)))));
    };
    RSAKey.SALT_LEN_HLEN = -1;
    RSAKey.SALT_LEN_MAX = -2;
    RSAKey.SALT_LEN_RECOVER = -2;
    function X509(q) {
      var j = ASN1HEX, n = j.getChildIdx, g = j.getV, b = j.getTLV, c = j.getVbyList, k = j.getVbyListEx, a = j.getTLVbyList, l = j.getTLVbyListEx, h = j.getIdxbyList, e = j.getIdxbyListEx, i = j.getVidx, s = j.getInt, p = j.oidname, m = j.hextooidstr, d = X509, r = pemtohex, f;
      try {
        f = KJUR.asn1.x509.AlgorithmIdentifier.PSSNAME2ASN1TLV;
      } catch (o) {
      }
      this.HEX2STAG = { "0c": "utf8", "13": "prn", "16": "ia5", "1a": "vis", "1e": "bmp" };
      this.hex = null;
      this.version = 0;
      this.foffset = 0;
      this.aExtInfo = null;
      this.getVersion = function() {
        if (this.hex === null || this.version !== 0) {
          return this.version;
        }
        var u = a(this.hex, 0, [0, 0]);
        if (u.substr(0, 2) == "a0") {
          var v = a(u, 0, [0]);
          var t2 = s(v, 0);
          if (t2 < 0 || 2 < t2) {
            throw new Error("malformed version field");
          }
          this.version = t2 + 1;
          return this.version;
        } else {
          this.version = 1;
          this.foffset = -1;
          return 1;
        }
      };
      this.getSerialNumberHex = function() {
        return k(this.hex, 0, [0, 0], "02");
      };
      this.getSignatureAlgorithmField = function() {
        var t2 = l(this.hex, 0, [0, 1]);
        return this.getAlgorithmIdentifierName(t2);
      };
      this.getAlgorithmIdentifierName = function(t2) {
        for (var u in f) {
          if (t2 === f[u]) {
            return u;
          }
        }
        return p(k(t2, 0, [0], "06"));
      };
      this.getIssuer = function() {
        return this.getX500Name(this.getIssuerHex());
      };
      this.getIssuerHex = function() {
        return a(this.hex, 0, [0, 3 + this.foffset], "30");
      };
      this.getIssuerString = function() {
        var t2 = this.getIssuer();
        return t2.str;
      };
      this.getSubject = function() {
        return this.getX500Name(this.getSubjectHex());
      };
      this.getSubjectHex = function() {
        return a(this.hex, 0, [0, 5 + this.foffset], "30");
      };
      this.getSubjectString = function() {
        var t2 = this.getSubject();
        return t2.str;
      };
      this.getNotBefore = function() {
        var t2 = c(this.hex, 0, [0, 4 + this.foffset, 0]);
        t2 = t2.replace(/(..)/g, "%$1");
        t2 = decodeURIComponent(t2);
        return t2;
      };
      this.getNotAfter = function() {
        var t2 = c(this.hex, 0, [0, 4 + this.foffset, 1]);
        t2 = t2.replace(/(..)/g, "%$1");
        t2 = decodeURIComponent(t2);
        return t2;
      };
      this.getPublicKeyHex = function() {
        return j.getTLVbyList(this.hex, 0, [0, 6 + this.foffset], "30");
      };
      this.getPublicKeyIdx = function() {
        return h(this.hex, 0, [0, 6 + this.foffset], "30");
      };
      this.getPublicKeyContentIdx = function() {
        var t2 = this.getPublicKeyIdx();
        return h(this.hex, t2, [1, 0], "30");
      };
      this.getPublicKey = function() {
        return KEYUTIL.getKey(this.getPublicKeyHex(), null, "pkcs8pub");
      };
      this.getSignatureAlgorithmName = function() {
        var t2 = a(this.hex, 0, [1], "30");
        return this.getAlgorithmIdentifierName(t2);
      };
      this.getSignatureValueHex = function() {
        return c(this.hex, 0, [2], "03", true);
      };
      this.verifySignature = function(v) {
        var w = this.getSignatureAlgorithmField();
        var t2 = this.getSignatureValueHex();
        var u = a(this.hex, 0, [0], "30");
        var x = new KJUR.crypto.Signature({ alg: w });
        x.init(v);
        x.updateHex(u);
        return x.verify(t2);
      };
      this.parseExt = function(C) {
        var v, t2, x;
        if (C === void 0) {
          x = this.hex;
          if (this.version !== 3) {
            return -1;
          }
          v = h(x, 0, [0, 7, 0], "30");
          t2 = n(x, v);
        } else {
          x = pemtohex(C);
          var y = h(x, 0, [0, 3, 0, 0], "06");
          if (g(x, y) != "2a864886f70d01090e") {
            this.aExtInfo = new Array();
            return;
          }
          v = h(x, 0, [0, 3, 0, 1, 0], "30");
          t2 = n(x, v);
          this.hex = x;
        }
        this.aExtInfo = new Array();
        for (var w = 0; w < t2.length; w++) {
          var A = {};
          A.critical = false;
          var z2 = n(x, t2[w]);
          var u = 0;
          if (z2.length === 3) {
            A.critical = true;
            u = 1;
          }
          A.oid = j.hextooidstr(c(x, t2[w], [0], "06"));
          var B = h(x, t2[w], [1 + u]);
          A.vidx = i(x, B);
          this.aExtInfo.push(A);
        }
      };
      this.getExtInfo = function(v) {
        var t2 = this.aExtInfo;
        var w = v;
        if (!v.match(/^[0-9.]+$/)) {
          w = KJUR.asn1.x509.OID.name2oid(v);
        }
        if (w === "") {
          return void 0;
        }
        for (var u = 0; u < t2.length; u++) {
          if (t2[u].oid === w) {
            return t2[u];
          }
        }
        return void 0;
      };
      this.getExtBasicConstraints = function(u, y) {
        if (u === void 0 && y === void 0) {
          var w = this.getExtInfo("basicConstraints");
          if (w === void 0) {
            return void 0;
          }
          u = b(this.hex, w.vidx);
          y = w.critical;
        }
        var t2 = { extname: "basicConstraints" };
        if (y) {
          t2.critical = true;
        }
        if (u === "3000") {
          return t2;
        }
        if (u === "30030101ff") {
          t2.cA = true;
          return t2;
        }
        if (u.substr(0, 12) === "30060101ff02") {
          var x = g(u, 10);
          var v = parseInt(x, 16);
          t2.cA = true;
          t2.pathLen = v;
          return t2;
        }
        throw new Error("hExtV parse error: " + u);
      };
      this.getExtKeyUsage = function(u, w) {
        if (u === void 0 && w === void 0) {
          var v = this.getExtInfo("keyUsage");
          if (v === void 0) {
            return void 0;
          }
          u = b(this.hex, v.vidx);
          w = v.critical;
        }
        var t2 = { extname: "keyUsage" };
        if (w) {
          t2.critical = true;
        }
        t2.names = this.getExtKeyUsageString(u).split(",");
        return t2;
      };
      this.getExtKeyUsageBin = function(u) {
        if (u === void 0) {
          var v = this.getExtInfo("keyUsage");
          if (v === void 0) {
            return "";
          }
          u = b(this.hex, v.vidx);
        }
        if (u.length != 8 && u.length != 10) {
          throw new Error("malformed key usage value: " + u);
        }
        var t2 = "000000000000000" + parseInt(u.substr(6), 16).toString(2);
        if (u.length == 8) {
          t2 = t2.slice(-8);
        }
        if (u.length == 10) {
          t2 = t2.slice(-16);
        }
        t2 = t2.replace(/0+$/, "");
        if (t2 == "") {
          t2 = "0";
        }
        return t2;
      };
      this.getExtKeyUsageString = function(v) {
        var w = this.getExtKeyUsageBin(v);
        var t2 = new Array();
        for (var u = 0; u < w.length; u++) {
          if (w.substr(u, 1) == "1") {
            t2.push(X509.KEYUSAGE_NAME[u]);
          }
        }
        return t2.join(",");
      };
      this.getExtSubjectKeyIdentifier = function(v, x) {
        if (v === void 0 && x === void 0) {
          var w = this.getExtInfo("subjectKeyIdentifier");
          if (w === void 0) {
            return void 0;
          }
          v = b(this.hex, w.vidx);
          x = w.critical;
        }
        var t2 = { extname: "subjectKeyIdentifier" };
        if (x) {
          t2.critical = true;
        }
        var u = g(v, 0);
        t2.kid = { hex: u };
        return t2;
      };
      this.getExtAuthorityKeyIdentifier = function(z2, x) {
        if (z2 === void 0 && x === void 0) {
          var t2 = this.getExtInfo("authorityKeyIdentifier");
          if (t2 === void 0) {
            return void 0;
          }
          z2 = b(this.hex, t2.vidx);
          x = t2.critical;
        }
        var A = { extname: "authorityKeyIdentifier" };
        if (x) {
          A.critical = true;
        }
        var y = n(z2, 0);
        for (var u = 0; u < y.length; u++) {
          var B = z2.substr(y[u], 2);
          if (B === "80") {
            A.kid = { hex: g(z2, y[u]) };
          }
          if (B === "a1") {
            var w = b(z2, y[u]);
            var v = this.getGeneralNames(w);
            A.issuer = v[0]["dn"];
          }
          if (B === "82") {
            A.sn = { hex: g(z2, y[u]) };
          }
        }
        return A;
      };
      this.getExtExtKeyUsage = function(w, y) {
        if (w === void 0 && y === void 0) {
          var x = this.getExtInfo("extKeyUsage");
          if (x === void 0) {
            return void 0;
          }
          w = b(this.hex, x.vidx);
          y = x.critical;
        }
        var t2 = { extname: "extKeyUsage", array: [] };
        if (y) {
          t2.critical = true;
        }
        var u = n(w, 0);
        for (var v = 0; v < u.length; v++) {
          t2.array.push(p(g(w, u[v])));
        }
        return t2;
      };
      this.getExtExtKeyUsageName = function() {
        var x = this.getExtInfo("extKeyUsage");
        if (x === void 0) {
          return x;
        }
        var t2 = new Array();
        var w = b(this.hex, x.vidx);
        if (w === "") {
          return t2;
        }
        var u = n(w, 0);
        for (var v = 0; v < u.length; v++) {
          t2.push(p(g(w, u[v])));
        }
        return t2;
      };
      this.getExtSubjectAltName = function(u, w) {
        if (u === void 0 && w === void 0) {
          var v = this.getExtInfo("subjectAltName");
          if (v === void 0) {
            return void 0;
          }
          u = b(this.hex, v.vidx);
          w = v.critical;
        }
        var t2 = { extname: "subjectAltName", array: [] };
        if (w) {
          t2.critical = true;
        }
        t2.array = this.getGeneralNames(u);
        return t2;
      };
      this.getExtIssuerAltName = function(u, w) {
        if (u === void 0 && w === void 0) {
          var v = this.getExtInfo("issuerAltName");
          if (v === void 0) {
            return void 0;
          }
          u = b(this.hex, v.vidx);
          w = v.critical;
        }
        var t2 = { extname: "issuerAltName", array: [] };
        if (w) {
          t2.critical = true;
        }
        t2.array = this.getGeneralNames(u);
        return t2;
      };
      this.getGeneralNames = function(x) {
        var v = n(x, 0);
        var t2 = [];
        for (var w = 0; w < v.length; w++) {
          var u = this.getGeneralName(b(x, v[w]));
          if (u !== void 0) {
            t2.push(u);
          }
        }
        return t2;
      };
      this.getGeneralName = function(u) {
        var t2 = u.substr(0, 2);
        var w = g(u, 0);
        var v = hextorstr(w);
        if (t2 == "81") {
          return { rfc822: v };
        }
        if (t2 == "82") {
          return { dns: v };
        }
        if (t2 == "86") {
          return { uri: v };
        }
        if (t2 == "87") {
          return { ip: hextoip(w) };
        }
        if (t2 == "a4") {
          return { dn: this.getX500Name(w) };
        }
        return void 0;
      };
      this.getExtSubjectAltName2 = function() {
        var x, A, z2;
        var y = this.getExtInfo("subjectAltName");
        if (y === void 0) {
          return y;
        }
        var t2 = new Array();
        var w = b(this.hex, y.vidx);
        var u = n(w, 0);
        for (var v = 0; v < u.length; v++) {
          z2 = w.substr(u[v], 2);
          x = g(w, u[v]);
          if (z2 === "81") {
            A = hextoutf8(x);
            t2.push(["MAIL", A]);
          }
          if (z2 === "82") {
            A = hextoutf8(x);
            t2.push(["DNS", A]);
          }
          if (z2 === "84") {
            A = X509.hex2dn(x, 0);
            t2.push(["DN", A]);
          }
          if (z2 === "86") {
            A = hextoutf8(x);
            t2.push(["URI", A]);
          }
          if (z2 === "87") {
            A = hextoip(x);
            t2.push(["IP", A]);
          }
        }
        return t2;
      };
      this.getExtCRLDistributionPoints = function(x, z2) {
        if (x === void 0 && z2 === void 0) {
          var y = this.getExtInfo("cRLDistributionPoints");
          if (y === void 0) {
            return void 0;
          }
          x = b(this.hex, y.vidx);
          z2 = y.critical;
        }
        var u = { extname: "cRLDistributionPoints", array: [] };
        if (z2) {
          u.critical = true;
        }
        var v = n(x, 0);
        for (var w = 0; w < v.length; w++) {
          var t2 = b(x, v[w]);
          u.array.push(this.getDistributionPoint(t2));
        }
        return u;
      };
      this.getDistributionPoint = function(y) {
        var v = {};
        var w = n(y, 0);
        for (var x = 0; x < w.length; x++) {
          var u = y.substr(w[x], 2);
          var t2 = b(y, w[x]);
          if (u == "a0") {
            v.dpname = this.getDistributionPointName(t2);
          }
        }
        return v;
      };
      this.getDistributionPointName = function(y) {
        var v = {};
        var w = n(y, 0);
        for (var x = 0; x < w.length; x++) {
          var u = y.substr(w[x], 2);
          var t2 = b(y, w[x]);
          if (u == "a0") {
            v.full = this.getGeneralNames(t2);
          }
        }
        return v;
      };
      this.getExtCRLDistributionPointsURI = function() {
        var y = this.getExtInfo("cRLDistributionPoints");
        if (y === void 0) {
          return y;
        }
        var t2 = new Array();
        var u = n(this.hex, y.vidx);
        for (var w = 0; w < u.length; w++) {
          try {
            var z2 = c(this.hex, u[w], [0, 0, 0], "86");
            var x = hextoutf8(z2);
            t2.push(x);
          } catch (v) {
          }
        }
        return t2;
      };
      this.getExtAIAInfo = function() {
        var x = this.getExtInfo("authorityInfoAccess");
        if (x === void 0) {
          return x;
        }
        var t2 = { ocsp: [], caissuer: [] };
        var u = n(this.hex, x.vidx);
        for (var v = 0; v < u.length; v++) {
          var y = c(this.hex, u[v], [0], "06");
          var w = c(this.hex, u[v], [1], "86");
          if (y === "2b06010505073001") {
            t2.ocsp.push(hextoutf8(w));
          }
          if (y === "2b06010505073002") {
            t2.caissuer.push(hextoutf8(w));
          }
        }
        return t2;
      };
      this.getExtAuthorityInfoAccess = function(A, y) {
        if (A === void 0 && y === void 0) {
          var t2 = this.getExtInfo("authorityInfoAccess");
          if (t2 === void 0) {
            return void 0;
          }
          A = b(this.hex, t2.vidx);
          y = t2.critical;
        }
        var B = { extname: "authorityInfoAccess", array: [] };
        if (y) {
          B.critical = true;
        }
        var z2 = n(A, 0);
        for (var u = 0; u < z2.length; u++) {
          var x = k(A, z2[u], [0], "06");
          var v = c(A, z2[u], [1], "86");
          var w = hextoutf8(v);
          if (x == "2b06010505073001") {
            B.array.push({ ocsp: w });
          } else {
            if (x == "2b06010505073002") {
              B.array.push({ caissuer: w });
            } else {
              throw new Error("unknown method: " + x);
            }
          }
        }
        return B;
      };
      this.getExtCertificatePolicies = function(x, A) {
        if (x === void 0 && A === void 0) {
          var z2 = this.getExtInfo("certificatePolicies");
          if (z2 === void 0) {
            return void 0;
          }
          x = b(this.hex, z2.vidx);
          A = z2.critical;
        }
        var t2 = { extname: "certificatePolicies", array: [] };
        if (A) {
          t2.critical = true;
        }
        var u = n(x, 0);
        for (var v = 0; v < u.length; v++) {
          var y = b(x, u[v]);
          var w = this.getPolicyInformation(y);
          t2.array.push(w);
        }
        return t2;
      };
      this.getPolicyInformation = function(x) {
        var t2 = {};
        var z2 = c(x, 0, [0], "06");
        t2.policyoid = p(z2);
        var A = e(x, 0, [1], "30");
        if (A != -1) {
          t2.array = [];
          var u = n(x, A);
          for (var v = 0; v < u.length; v++) {
            var y = b(x, u[v]);
            var w = this.getPolicyQualifierInfo(y);
            t2.array.push(w);
          }
        }
        return t2;
      };
      this.getPolicyQualifierInfo = function(u) {
        var t2 = {};
        var v = c(u, 0, [0], "06");
        if (v === "2b06010505070201") {
          var x = k(u, 0, [1], "16");
          t2.cps = hextorstr(x);
        } else {
          if (v === "2b06010505070202") {
            var w = a(u, 0, [1], "30");
            t2.unotice = this.getUserNotice(w);
          }
        }
        return t2;
      };
      this.getUserNotice = function(x) {
        var u = {};
        var v = n(x, 0);
        for (var w = 0; w < v.length; w++) {
          var t2 = b(x, v[w]);
          if (t2.substr(0, 2) != "30") {
            u.exptext = this.getDisplayText(t2);
          }
        }
        return u;
      };
      this.getDisplayText = function(u) {
        var v = { "0c": "utf8", "16": "ia5", "1a": "vis", "1e": "bmp" };
        var t2 = {};
        t2.type = v[u.substr(0, 2)];
        t2.str = hextorstr(g(u, 0));
        return t2;
      };
      this.getExtCRLNumber = function(u, v) {
        var t2 = { extname: "cRLNumber" };
        if (v) {
          t2.critical = true;
        }
        if (u.substr(0, 2) == "02") {
          t2.num = { hex: g(u, 0) };
          return t2;
        }
        throw new Error("hExtV parse error: " + u);
      };
      this.getExtCRLReason = function(u, v) {
        var t2 = { extname: "cRLReason" };
        if (v) {
          t2.critical = true;
        }
        if (u.substr(0, 2) == "0a") {
          t2.code = parseInt(g(u, 0), 16);
          return t2;
        }
        throw new Error("hExtV parse error: " + u);
      };
      this.getExtOcspNonce = function(u, w) {
        var t2 = { extname: "ocspNonce" };
        if (w) {
          t2.critical = true;
        }
        var v = g(u, 0);
        t2.hex = v;
        return t2;
      };
      this.getExtOcspNoCheck = function(u, v) {
        var t2 = { extname: "ocspNoCheck" };
        if (v) {
          t2.critical = true;
        }
        return t2;
      };
      this.getExtAdobeTimeStamp = function(w, z2) {
        if (w === void 0 && z2 === void 0) {
          var y = this.getExtInfo("adobeTimeStamp");
          if (y === void 0) {
            return void 0;
          }
          w = b(this.hex, y.vidx);
          z2 = y.critical;
        }
        var t2 = { extname: "adobeTimeStamp" };
        if (z2) {
          t2.critical = true;
        }
        var v = n(w, 0);
        if (v.length > 1) {
          var A = b(w, v[1]);
          var u = this.getGeneralName(A);
          if (u.uri != void 0) {
            t2.uri = u.uri;
          }
        }
        if (v.length > 2) {
          var x = b(w, v[2]);
          if (x == "0101ff") {
            t2.reqauth = true;
          }
          if (x == "010100") {
            t2.reqauth = false;
          }
        }
        return t2;
      };
      this.getX500NameRule = function(t2) {
        var A = true;
        var E = true;
        var D = false;
        var u = "";
        var x = "";
        var G = null;
        var B = [];
        for (var w = 0; w < t2.length; w++) {
          var y = t2[w];
          for (var v = 0; v < y.length; v++) {
            B.push(y[v]);
          }
        }
        for (var w = 0; w < B.length; w++) {
          var F = B[w];
          var H = F.ds;
          var C = F.value;
          var z2 = F.type;
          u += ":" + H;
          if (H != "prn" && H != "utf8" && H != "ia5") {
            return "mixed";
          }
          if (H == "ia5") {
            if (z2 != "CN") {
              return "mixed";
            } else {
              if (!KJUR.lang.String.isMail(C)) {
                return "mixed";
              } else {
                continue;
              }
            }
          }
          if (z2 == "C") {
            if (H == "prn") {
              continue;
            } else {
              return "mixed";
            }
          }
          x += ":" + H;
          if (G == null) {
            G = H;
          } else {
            if (G !== H) {
              return "mixed";
            }
          }
        }
        if (G == null) {
          return "prn";
        } else {
          return G;
        }
      };
      this.getX500Name = function(v) {
        var t2 = this.getX500NameArray(v);
        var u = this.dnarraytostr(t2);
        return { array: t2, str: u };
      };
      this.getX500NameArray = function(w) {
        var t2 = [];
        var u = n(w, 0);
        for (var v = 0; v < u.length; v++) {
          t2.push(this.getRDN(b(w, u[v])));
        }
        return t2;
      };
      this.getRDN = function(w) {
        var t2 = [];
        var u = n(w, 0);
        for (var v = 0; v < u.length; v++) {
          t2.push(this.getAttrTypeAndValue(b(w, u[v])));
        }
        return t2;
      };
      this.getAttrTypeAndValue = function(v) {
        var t2 = { type: null, value: null, ds: null };
        var u = n(v, 0);
        var y = c(v, u[0], [], "06");
        var x = c(v, u[1], []);
        var w = KJUR.asn1.ASN1Util.oidHexToInt(y);
        t2.type = KJUR.asn1.x509.OID.oid2atype(w);
        t2.ds = this.HEX2STAG[v.substr(u[1], 2)];
        if (t2.ds != "bmp") {
          t2.value = hextoutf8(x);
        } else {
          t2.value = ucs2hextoutf8(x);
        }
        return t2;
      };
      this.readCertPEM = function(t2) {
        this.readCertHex(r(t2));
      };
      this.readCertHex = function(t2) {
        this.hex = t2;
        this.getVersion();
        try {
          h(this.hex, 0, [0, 7], "a3");
          this.parseExt();
        } catch (u) {
        }
      };
      this.getParam = function() {
        var t2 = {};
        t2.version = this.getVersion();
        t2.serial = { hex: this.getSerialNumberHex() };
        t2.sigalg = this.getSignatureAlgorithmField();
        t2.issuer = this.getIssuer();
        t2.notbefore = this.getNotBefore();
        t2.notafter = this.getNotAfter();
        t2.subject = this.getSubject();
        t2.sbjpubkey = hextopem(this.getPublicKeyHex(), "PUBLIC KEY");
        if (this.aExtInfo.length > 0) {
          t2.ext = this.getExtParamArray();
        }
        t2.sighex = this.getSignatureValueHex();
        return t2;
      };
      this.getExtParamArray = function(u) {
        if (u == void 0) {
          var w = e(this.hex, 0, [0, "[3]"]);
          if (w != -1) {
            u = l(this.hex, 0, [0, "[3]", 0], "30");
          }
        }
        var t2 = [];
        var v = n(u, 0);
        for (var x = 0; x < v.length; x++) {
          var z2 = b(u, v[x]);
          var y = this.getExtParam(z2);
          if (y != null) {
            t2.push(y);
          }
        }
        return t2;
      };
      this.getExtParam = function(u) {
        var B = {};
        var w = n(u, 0);
        var x = w.length;
        if (x != 2 && x != 3) {
          throw new Error("wrong number elements in Extension: " + x + " " + u);
        }
        var v = m(c(u, 0, [0], "06"));
        var z2 = false;
        if (x == 3 && a(u, 0, [1]) == "0101ff") {
          z2 = true;
        }
        var A = a(u, 0, [x - 1, 0]);
        var y = void 0;
        if (v == "2.5.29.14") {
          y = this.getExtSubjectKeyIdentifier(A, z2);
        } else {
          if (v == "2.5.29.15") {
            y = this.getExtKeyUsage(A, z2);
          } else {
            if (v == "2.5.29.17") {
              y = this.getExtSubjectAltName(A, z2);
            } else {
              if (v == "2.5.29.18") {
                y = this.getExtIssuerAltName(A, z2);
              } else {
                if (v == "2.5.29.19") {
                  y = this.getExtBasicConstraints(A, z2);
                } else {
                  if (v == "2.5.29.31") {
                    y = this.getExtCRLDistributionPoints(A, z2);
                  } else {
                    if (v == "2.5.29.32") {
                      y = this.getExtCertificatePolicies(A, z2);
                    } else {
                      if (v == "2.5.29.35") {
                        y = this.getExtAuthorityKeyIdentifier(A, z2);
                      } else {
                        if (v == "2.5.29.37") {
                          y = this.getExtExtKeyUsage(A, z2);
                        } else {
                          if (v == "1.3.6.1.5.5.7.1.1") {
                            y = this.getExtAuthorityInfoAccess(A, z2);
                          } else {
                            if (v == "2.5.29.20") {
                              y = this.getExtCRLNumber(A, z2);
                            } else {
                              if (v == "2.5.29.21") {
                                y = this.getExtCRLReason(A, z2);
                              } else {
                                if (v == "1.3.6.1.5.5.7.48.1.2") {
                                  y = this.getExtOcspNonce(A, z2);
                                } else {
                                  if (v == "1.3.6.1.5.5.7.48.1.5") {
                                    y = this.getExtOcspNoCheck(A, z2);
                                  } else {
                                    if (v == "1.2.840.113583.1.1.9.1") {
                                      y = this.getExtAdobeTimeStamp(A, z2);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (y != void 0) {
          return y;
        }
        var t2 = { extname: v, extn: A };
        if (z2) {
          t2.critical = true;
        }
        return t2;
      };
      this.findExt = function(u, v) {
        for (var t2 = 0; t2 < u.length; t2++) {
          if (u[t2].extname == v) {
            return u[t2];
          }
        }
        return null;
      };
      this.updateExtCDPFullURI = function(x, t2) {
        var w = this.findExt(x, "cRLDistributionPoints");
        if (w == null) {
          return;
        }
        if (w.array == void 0) {
          return;
        }
        var z2 = w.array;
        for (var v = 0; v < z2.length; v++) {
          if (z2[v].dpname == void 0) {
            continue;
          }
          if (z2[v].dpname.full == void 0) {
            continue;
          }
          var A = z2[v].dpname.full;
          for (var u = 0; u < A.length; u++) {
            var y = A[v];
            if (y.uri == void 0) {
              continue;
            }
            y.uri = t2;
          }
        }
      };
      this.updateExtAIAOCSP = function(x, u) {
        var w = this.findExt(x, "authorityInfoAccess");
        if (w == null) {
          return;
        }
        if (w.array == void 0) {
          return;
        }
        var t2 = w.array;
        for (var v = 0; v < t2.length; v++) {
          if (t2[v].ocsp != void 0) {
            t2[v].ocsp = u;
          }
        }
      };
      this.updateExtAIACAIssuer = function(x, u) {
        var w = this.findExt(x, "authorityInfoAccess");
        if (w == null) {
          return;
        }
        if (w.array == void 0) {
          return;
        }
        var t2 = w.array;
        for (var v = 0; v < t2.length; v++) {
          if (t2[v].caissuer != void 0) {
            t2[v].caissuer = u;
          }
        }
      };
      this.dnarraytostr = function(v) {
        function t2(w) {
          return w.map(function(y) {
            return u(y).replace(/\+/, "\\+");
          }).join("+");
        }
        function u(w) {
          return w.type + "=" + w.value;
        }
        return "/" + v.map(function(w) {
          return t2(w).replace(/\//, "\\/");
        }).join("/");
      };
      this.getInfo = function() {
        var u = function(M) {
          var L = JSON.stringify(M.array).replace(/[\[\]\{\}\"]/g, "");
          return L;
        };
        var A = function(R) {
          var P = "";
          var L = R.array;
          for (var O = 0; O < L.length; O++) {
            var Q = L[O];
            P += "    policy oid: " + Q.policyoid + "\n";
            if (Q.array === void 0) {
              continue;
            }
            for (var N = 0; N < Q.array.length; N++) {
              var M = Q.array[N];
              if (M.cps !== void 0) {
                P += "    cps: " + M.cps + "\n";
              }
            }
          }
          return P;
        };
        var D = function(P) {
          var O = "";
          var L = P.array;
          for (var N = 0; N < L.length; N++) {
            var Q = L[N];
            try {
              if (Q.dpname.full[0].uri !== void 0) {
                O += "    " + Q.dpname.full[0].uri + "\n";
              }
            } catch (M) {
            }
            try {
              if (Q.dname.full[0].dn.hex !== void 0) {
                O += "    " + X509.hex2dn(Q.dpname.full[0].dn.hex) + "\n";
              }
            } catch (M) {
            }
          }
          return O;
        };
        var B = function(P) {
          var O = "";
          var L = P.array;
          for (var M = 0; M < L.length; M++) {
            var N = L[M];
            if (N.caissuer !== void 0) {
              O += "    caissuer: " + N.caissuer + "\n";
            }
            if (N.ocsp !== void 0) {
              O += "    ocsp: " + N.ocsp + "\n";
            }
          }
          return O;
        };
        var v = X509;
        var F, E, K;
        F = "Basic Fields\n";
        F += "  serial number: " + this.getSerialNumberHex() + "\n";
        F += "  signature algorithm: " + this.getSignatureAlgorithmField() + "\n";
        F += "  issuer: " + this.getIssuerString() + "\n";
        F += "  notBefore: " + this.getNotBefore() + "\n";
        F += "  notAfter: " + this.getNotAfter() + "\n";
        F += "  subject: " + this.getSubjectString() + "\n";
        F += "  subject public key info: \n";
        E = this.getPublicKey();
        F += "    key algorithm: " + E.type + "\n";
        if (E.type === "RSA") {
          F += "    n=" + hextoposhex(E.n.toString(16)).substr(0, 16) + "...\n";
          F += "    e=" + hextoposhex(E.e.toString(16)) + "\n";
        }
        K = this.aExtInfo;
        if (K !== void 0 && K !== null) {
          F += "X509v3 Extensions:\n";
          for (var H = 0; H < K.length; H++) {
            var J = K[H];
            var t2 = KJUR.asn1.x509.OID.oid2name(J.oid);
            if (t2 === "") {
              t2 = J.oid;
            }
            var G = "";
            if (J.critical === true) {
              G = "CRITICAL";
            }
            F += "  " + t2 + " " + G + ":\n";
            if (t2 === "basicConstraints") {
              var w = this.getExtBasicConstraints();
              if (w.cA === void 0) {
                F += "    {}\n";
              } else {
                F += "    cA=true";
                if (w.pathLen !== void 0) {
                  F += ", pathLen=" + w.pathLen;
                }
                F += "\n";
              }
            } else {
              if (t2 === "keyUsage") {
                F += "    " + this.getExtKeyUsageString() + "\n";
              } else {
                if (t2 === "subjectKeyIdentifier") {
                  F += "    " + this.getExtSubjectKeyIdentifier().kid.hex + "\n";
                } else {
                  if (t2 === "authorityKeyIdentifier") {
                    var x = this.getExtAuthorityKeyIdentifier();
                    if (x.kid !== void 0) {
                      F += "    kid=" + x.kid.hex + "\n";
                    }
                  } else {
                    if (t2 === "extKeyUsage") {
                      var I = this.getExtExtKeyUsage().array;
                      F += "    " + I.join(", ") + "\n";
                    } else {
                      if (t2 === "subjectAltName") {
                        var y = u(this.getExtSubjectAltName());
                        F += "    " + y + "\n";
                      } else {
                        if (t2 === "cRLDistributionPoints") {
                          var C = this.getExtCRLDistributionPoints();
                          F += D(C);
                        } else {
                          if (t2 === "authorityInfoAccess") {
                            var z2 = this.getExtAuthorityInfoAccess();
                            F += B(z2);
                          } else {
                            if (t2 === "certificatePolicies") {
                              F += A(this.getExtCertificatePolicies());
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        F += "signature algorithm: " + this.getSignatureAlgorithmName() + "\n";
        F += "signature: " + this.getSignatureValueHex().substr(0, 16) + "...\n";
        return F;
      };
      if (typeof q == "string") {
        if (q.indexOf("-----BEGIN") != -1) {
          this.readCertPEM(q);
        } else {
          if (KJUR.lang.String.isHex(q)) {
            this.readCertHex(q);
          }
        }
      }
    }
    X509.hex2dn = function(e, b) {
      if (b === void 0) {
        b = 0;
      }
      var a = new X509();
      var c = ASN1HEX.getTLV(e, b);
      var d = a.getX500Name(e);
      return d.str;
    };
    X509.hex2rdn = function(f, b) {
      if (b === void 0) {
        b = 0;
      }
      if (f.substr(b, 2) !== "31") {
        throw new Error("malformed RDN");
      }
      var c = new Array();
      var d = ASN1HEX.getChildIdx(f, b);
      for (var e = 0; e < d.length; e++) {
        c.push(X509.hex2attrTypeValue(f, d[e]));
      }
      c = c.map(function(a) {
        return a.replace("+", "\\+");
      });
      return c.join("+");
    };
    X509.hex2attrTypeValue = function(d, i) {
      var j = ASN1HEX;
      var h = j.getV;
      if (i === void 0) {
        i = 0;
      }
      if (d.substr(i, 2) !== "30") {
        throw new Error("malformed attribute type and value");
      }
      var g = j.getChildIdx(d, i);
      if (g.length !== 2 || d.substr(g[0], 2) !== "06") {
        "malformed attribute type and value";
      }
      var b = h(d, g[0]);
      var f = KJUR.asn1.ASN1Util.oidHexToInt(b);
      var e = KJUR.asn1.x509.OID.oid2atype(f);
      var a = h(d, g[1]);
      var c = hextorstr(a);
      return e + "=" + c;
    };
    X509.getPublicKeyFromCertHex = function(b) {
      var a = new X509();
      a.readCertHex(b);
      return a.getPublicKey();
    };
    X509.getPublicKeyFromCertPEM = function(b) {
      var a = new X509();
      a.readCertPEM(b);
      return a.getPublicKey();
    };
    X509.getPublicKeyInfoPropOfCertPEM = function(c) {
      var e = ASN1HEX;
      var g = e.getVbyList;
      var b = {};
      var a, f, d;
      b.algparam = null;
      a = new X509();
      a.readCertPEM(c);
      f = a.getPublicKeyHex();
      b.keyhex = g(f, 0, [1], "03").substr(2);
      b.algoid = g(f, 0, [0, 0], "06");
      if (b.algoid === "2a8648ce3d0201") {
        b.algparam = g(f, 0, [0, 1], "06");
      }
      return b;
    };
    X509.KEYUSAGE_NAME = ["digitalSignature", "nonRepudiation", "keyEncipherment", "dataEncipherment", "keyAgreement", "keyCertSign", "cRLSign", "encipherOnly", "decipherOnly"];
    var X509CRL = function(e) {
      var a = KJUR, f = a.lang.String.isHex, m = ASN1HEX, k = m.getV, b = m.getTLV, h = m.getVbyList, c = m.getTLVbyList, d = m.getTLVbyListEx, i = m.getIdxbyList, g = m.getIdxbyListEx, l = m.getChildIdx, j = new X509();
      this.hex = null;
      this.posSigAlg = null;
      this.posRevCert = null;
      this._setPos = function() {
        var o = i(this.hex, 0, [0, 0]);
        var n = this.hex.substr(o, 2);
        if (n == "02") {
          this.posSigAlg = 1;
        } else {
          if (n == "30") {
            this.posSigAlg = 0;
          } else {
            throw new Error("malformed 1st item of TBSCertList: " + n);
          }
        }
        var s = i(this.hex, 0, [0, this.posSigAlg + 3]);
        var r = this.hex.substr(s, 2);
        if (r == "17" || r == "18") {
          var q, p;
          q = i(this.hex, 0, [0, this.posSigAlg + 4]);
          this.posRevCert = null;
          if (q != -1) {
            p = this.hex.substr(q, 2);
            if (p == "30") {
              this.posRevCert = this.posSigAlg + 4;
            }
          }
        } else {
          if (r == "30") {
            this.posRevCert = this.posSigAlg + 3;
          } else {
            if (r == "a0") {
              this.posRevCert = null;
            } else {
              throw new Error("malformed nextUpdate or revCert tag: " + r);
            }
          }
        }
      };
      this.getVersion = function() {
        if (this.posSigAlg == 0) {
          return null;
        }
        return parseInt(h(this.hex, 0, [0, 0], "02"), 16) + 1;
      };
      this.getSignatureAlgorithmField = function() {
        var n = c(this.hex, 0, [0, this.posSigAlg], "30");
        return j.getAlgorithmIdentifierName(n);
      };
      this.getIssuer = function() {
        var n = c(this.hex, 0, [0, this.posSigAlg + 1], "30");
        return j.getX500Name(n);
      };
      this.getThisUpdate = function() {
        var n = h(this.hex, 0, [0, this.posSigAlg + 2]);
        return result = hextorstr(n);
      };
      this.getNextUpdate = function() {
        var o = i(this.hex, 0, [0, this.posSigAlg + 3]);
        var n = this.hex.substr(o, 2);
        if (n != "17" && n != "18") {
          return null;
        }
        return hextorstr(k(this.hex, o));
      };
      this.getRevCertArray = function() {
        if (this.posRevCert == null) {
          return null;
        }
        var o = [];
        var n = i(this.hex, 0, [0, this.posRevCert]);
        var p = l(this.hex, n);
        for (var q = 0; q < p.length; q++) {
          var r = b(this.hex, p[q]);
          o.push(this.getRevCert(r));
        }
        return o;
      };
      this.getRevCert = function(p) {
        var o = {};
        var n = l(p, 0);
        o.sn = { hex: h(p, 0, [0], "02") };
        o.date = hextorstr(h(p, 0, [1]));
        if (n.length == 3) {
          o.ext = j.getExtParamArray(c(p, 0, [2]));
        }
        return o;
      };
      this.getSignatureValueHex = function() {
        return h(this.hex, 0, [2], "03", true);
      };
      this.verifySignature = function(o) {
        var p = this.getSignatureAlgorithmField();
        var n = this.getSignatureValueHex();
        var q = c(this.hex, 0, [0], "30");
        var r = new KJUR.crypto.Signature({ alg: p });
        r.init(o);
        r.updateHex(q);
        return r.verify(n);
      };
      this.getParam = function() {
        var n = {};
        var p = this.getVersion();
        if (p != null) {
          n.version = p;
        }
        n.sigalg = this.getSignatureAlgorithmField();
        n.issuer = this.getIssuer();
        n.thisupdate = this.getThisUpdate();
        var q = this.getNextUpdate();
        if (q != null) {
          n.nextupdate = q;
        }
        var s = this.getRevCertArray();
        if (s != null) {
          n.revcert = s;
        }
        var r = g(this.hex, 0, [0, "[0]"]);
        if (r != -1) {
          var o = d(this.hex, 0, [0, "[0]", 0]);
          n.ext = j.getExtParamArray(o);
        }
        n.sighex = this.getSignatureValueHex();
        return n;
      };
      if (typeof e == "string") {
        if (f(e)) {
          this.hex = e;
        } else {
          if (e.match(/-----BEGIN X509 CRL/)) {
            this.hex = pemtohex(e);
          }
        }
        this._setPos();
      }
    };
    if (typeof KJUR == "undefined" || !KJUR) {
      KJUR = {};
    }
    if (typeof KJUR.jws == "undefined" || !KJUR.jws) {
      KJUR.jws = {};
    }
    KJUR.jws.JWS = function() {
      var b = KJUR, a = b.jws.JWS, c = a.isSafeJSONString;
      this.parseJWS = function(g, j) {
        if (this.parsedJWS !== void 0 && (j || this.parsedJWS.sigvalH !== void 0)) {
          return;
        }
        var i = g.match(/^([^.]+)\.([^.]+)\.([^.]+)$/);
        if (i == null) {
          throw "JWS signature is not a form of 'Head.Payload.SigValue'.";
        }
        var k = i[1];
        var e = i[2];
        var l = i[3];
        var n = k + "." + e;
        this.parsedJWS = {};
        this.parsedJWS.headB64U = k;
        this.parsedJWS.payloadB64U = e;
        this.parsedJWS.sigvalB64U = l;
        this.parsedJWS.si = n;
        if (!j) {
          var h = b64utohex(l);
          var f = parseBigInt(h, 16);
          this.parsedJWS.sigvalH = h;
          this.parsedJWS.sigvalBI = f;
        }
        var d = b64utoutf8(k);
        var m = b64utoutf8(e);
        this.parsedJWS.headS = d;
        this.parsedJWS.payloadS = m;
        if (!c(d, this.parsedJWS, "headP")) {
          throw "malformed JSON string for JWS Head: " + d;
        }
      };
    };
    KJUR.jws.JWS.sign = function(j, w, z2, A, a) {
      var x = KJUR, n = x.jws, r = n.JWS, h = r.readSafeJSONString, q = r.isSafeJSONString, d = x.crypto, l = d.ECDSA, p = d.Mac, c = d.Signature, u = JSON;
      var t2, k, o;
      if (typeof w != "string" && typeof w != "object") {
        throw "spHeader must be JSON string or object: " + w;
      }
      if (typeof w == "object") {
        k = w;
        t2 = u.stringify(k);
      }
      if (typeof w == "string") {
        t2 = w;
        if (!q(t2)) {
          throw "JWS Head is not safe JSON string: " + t2;
        }
        k = h(t2);
      }
      o = z2;
      if (typeof z2 == "object") {
        o = u.stringify(z2);
      }
      if ((j == "" || j == null) && k.alg !== void 0) {
        j = k.alg;
      }
      if (j != "" && j != null && k.alg === void 0) {
        k.alg = j;
        t2 = u.stringify(k);
      }
      if (j !== k.alg) {
        throw "alg and sHeader.alg doesn't match: " + j + "!=" + k.alg;
      }
      var s = null;
      if (r.jwsalg2sigalg[j] === void 0) {
        throw "unsupported alg name: " + j;
      } else {
        s = r.jwsalg2sigalg[j];
      }
      var e = utf8tob64u(t2);
      var m = utf8tob64u(o);
      var b = e + "." + m;
      var y = "";
      if (s.substr(0, 4) == "Hmac") {
        if (A === void 0) {
          throw "mac key shall be specified for HS* alg";
        }
        var i = new p({ alg: s, prov: "cryptojs", pass: A });
        i.updateString(b);
        y = i.doFinal();
      } else {
        if (s.indexOf("withECDSA") != -1) {
          var f = new c({ alg: s });
          f.init(A, a);
          f.updateString(b);
          var g = f.sign();
          y = KJUR.crypto.ECDSA.asn1SigToConcatSig(g);
        } else {
          if (s != "none") {
            var f = new c({ alg: s });
            f.init(A, a);
            f.updateString(b);
            y = f.sign();
          }
        }
      }
      var v = hextob64u(y);
      return b + "." + v;
    };
    KJUR.jws.JWS.verify = function(w, B, n) {
      var x = KJUR, q = x.jws, t2 = q.JWS, i = t2.readSafeJSONString, e = x.crypto, p = e.ECDSA, s = e.Mac, d = e.Signature, m;
      if (typeof RSAKey !== void 0) {
        m = RSAKey;
      }
      var y = w.split(".");
      if (y.length !== 3) {
        return false;
      }
      var f = y[0];
      var r = y[1];
      var c = f + "." + r;
      var A = b64utohex(y[2]);
      var l = i(b64utoutf8(y[0]));
      var k = null;
      var z2 = null;
      if (l.alg === void 0) {
        throw "algorithm not specified in header";
      } else {
        k = l.alg;
        z2 = k.substr(0, 2);
      }
      if (n != null && Object.prototype.toString.call(n) === "[object Array]" && n.length > 0) {
        var b = ":" + n.join(":") + ":";
        if (b.indexOf(":" + k + ":") == -1) {
          throw "algorithm '" + k + "' not accepted in the list";
        }
      }
      if (k != "none" && B === null) {
        throw "key shall be specified to verify.";
      }
      if (typeof B == "string" && B.indexOf("-----BEGIN ") != -1) {
        B = KEYUTIL.getKey(B);
      }
      if (z2 == "RS" || z2 == "PS") {
        if (!(B instanceof m)) {
          throw "key shall be a RSAKey obj for RS* and PS* algs";
        }
      }
      if (z2 == "ES") {
        if (!(B instanceof p)) {
          throw "key shall be a ECDSA obj for ES* algs";
        }
      }
      if (k == "none") {
      }
      var u = null;
      if (t2.jwsalg2sigalg[l.alg] === void 0) {
        throw "unsupported alg name: " + k;
      } else {
        u = t2.jwsalg2sigalg[k];
      }
      if (u == "none") {
        throw "not supported";
      } else {
        if (u.substr(0, 4) == "Hmac") {
          var o = null;
          if (B === void 0) {
            throw "hexadecimal key shall be specified for HMAC";
          }
          var j = new s({ alg: u, pass: B });
          j.updateString(c);
          o = j.doFinal();
          return A == o;
        } else {
          if (u.indexOf("withECDSA") != -1) {
            var h = null;
            try {
              h = p.concatSigToASN1Sig(A);
            } catch (v) {
              return false;
            }
            var g = new d({ alg: u });
            g.init(B);
            g.updateString(c);
            return g.verify(h);
          } else {
            var g = new d({ alg: u });
            g.init(B);
            g.updateString(c);
            return g.verify(A);
          }
        }
      }
    };
    KJUR.jws.JWS.parse = function(g) {
      var c = g.split(".");
      var b = {};
      var f, e, d;
      if (c.length != 2 && c.length != 3) {
        throw "malformed sJWS: wrong number of '.' splitted elements";
      }
      f = c[0];
      e = c[1];
      if (c.length == 3) {
        d = c[2];
      }
      b.headerObj = KJUR.jws.JWS.readSafeJSONString(b64utoutf8(f));
      b.payloadObj = KJUR.jws.JWS.readSafeJSONString(b64utoutf8(e));
      b.headerPP = JSON.stringify(b.headerObj, null, "  ");
      if (b.payloadObj == null) {
        b.payloadPP = b64utoutf8(e);
      } else {
        b.payloadPP = JSON.stringify(b.payloadObj, null, "  ");
      }
      if (d !== void 0) {
        b.sigHex = b64utohex(d);
      }
      return b;
    };
    KJUR.jws.JWS.verifyJWT = function(e, l, r) {
      var d = KJUR, j = d.jws, o = j.JWS, n = o.readSafeJSONString, p = o.inArray, f = o.includedArray;
      var k = e.split(".");
      var c = k[0];
      var i = k[1];
      var q = c + "." + i;
      var m = b64utohex(k[2]);
      var h = n(b64utoutf8(c));
      var g = n(b64utoutf8(i));
      if (h.alg === void 0) {
        return false;
      }
      if (r.alg === void 0) {
        throw "acceptField.alg shall be specified";
      }
      if (!p(h.alg, r.alg)) {
        return false;
      }
      if (g.iss !== void 0 && typeof r.iss === "object") {
        if (!p(g.iss, r.iss)) {
          return false;
        }
      }
      if (g.sub !== void 0 && typeof r.sub === "object") {
        if (!p(g.sub, r.sub)) {
          return false;
        }
      }
      if (g.aud !== void 0 && typeof r.aud === "object") {
        if (typeof g.aud == "string") {
          if (!p(g.aud, r.aud)) {
            return false;
          }
        } else {
          if (typeof g.aud == "object") {
            if (!f(g.aud, r.aud)) {
              return false;
            }
          }
        }
      }
      var b = j.IntDate.getNow();
      if (r.verifyAt !== void 0 && typeof r.verifyAt === "number") {
        b = r.verifyAt;
      }
      if (r.gracePeriod === void 0 || typeof r.gracePeriod !== "number") {
        r.gracePeriod = 0;
      }
      if (g.exp !== void 0 && typeof g.exp == "number") {
        if (g.exp + r.gracePeriod < b) {
          return false;
        }
      }
      if (g.nbf !== void 0 && typeof g.nbf == "number") {
        if (b < g.nbf - r.gracePeriod) {
          return false;
        }
      }
      if (g.iat !== void 0 && typeof g.iat == "number") {
        if (b < g.iat - r.gracePeriod) {
          return false;
        }
      }
      if (g.jti !== void 0 && r.jti !== void 0) {
        if (g.jti !== r.jti) {
          return false;
        }
      }
      if (!o.verify(e, l, r.alg)) {
        return false;
      }
      return true;
    };
    KJUR.jws.JWS.includedArray = function(b, a) {
      var c = KJUR.jws.JWS.inArray;
      if (b === null) {
        return false;
      }
      if (typeof b !== "object") {
        return false;
      }
      if (typeof b.length !== "number") {
        return false;
      }
      for (var d = 0; d < b.length; d++) {
        if (!c(b[d], a)) {
          return false;
        }
      }
      return true;
    };
    KJUR.jws.JWS.inArray = function(d, b) {
      if (b === null) {
        return false;
      }
      if (typeof b !== "object") {
        return false;
      }
      if (typeof b.length !== "number") {
        return false;
      }
      for (var c = 0; c < b.length; c++) {
        if (b[c] == d) {
          return true;
        }
      }
      return false;
    };
    KJUR.jws.JWS.jwsalg2sigalg = { HS256: "HmacSHA256", HS384: "HmacSHA384", HS512: "HmacSHA512", RS256: "SHA256withRSA", RS384: "SHA384withRSA", RS512: "SHA512withRSA", ES256: "SHA256withECDSA", ES384: "SHA384withECDSA", PS256: "SHA256withRSAandMGF1", PS384: "SHA384withRSAandMGF1", PS512: "SHA512withRSAandMGF1", none: "none" };
    KJUR.jws.JWS.isSafeJSONString = function(c, b, d) {
      var e = null;
      try {
        e = jsonParse(c);
        if (typeof e != "object") {
          return 0;
        }
        if (e.constructor === Array) {
          return 0;
        }
        if (b) {
          b[d] = e;
        }
        return 1;
      } catch (a) {
        return 0;
      }
    };
    KJUR.jws.JWS.readSafeJSONString = function(b) {
      var c = null;
      try {
        c = jsonParse(b);
        if (typeof c != "object") {
          return null;
        }
        if (c.constructor === Array) {
          return null;
        }
        return c;
      } catch (a) {
        return null;
      }
    };
    KJUR.jws.JWS.getEncodedSignatureValueFromJWS = function(b) {
      var a = b.match(/^[^.]+\.[^.]+\.([^.]+)$/);
      if (a == null) {
        throw "JWS signature is not a form of 'Head.Payload.SigValue'.";
      }
      return a[1];
    };
    KJUR.jws.JWS.getJWKthumbprint = function(d) {
      if (d.kty !== "RSA" && d.kty !== "EC" && d.kty !== "oct") {
        throw "unsupported algorithm for JWK Thumprint";
      }
      var a = "{";
      if (d.kty === "RSA") {
        if (typeof d.n != "string" || typeof d.e != "string") {
          throw "wrong n and e value for RSA key";
        }
        a += '"e":"' + d.e + '",';
        a += '"kty":"' + d.kty + '",';
        a += '"n":"' + d.n + '"}';
      } else {
        if (d.kty === "EC") {
          if (typeof d.crv != "string" || typeof d.x != "string" || typeof d.y != "string") {
            throw "wrong crv, x and y value for EC key";
          }
          a += '"crv":"' + d.crv + '",';
          a += '"kty":"' + d.kty + '",';
          a += '"x":"' + d.x + '",';
          a += '"y":"' + d.y + '"}';
        } else {
          if (d.kty === "oct") {
            if (typeof d.k != "string") {
              throw "wrong k value for oct(symmetric) key";
            }
            a += '"kty":"' + d.kty + '",';
            a += '"k":"' + d.k + '"}';
          }
        }
      }
      var b = rstrtohex(a);
      var c = KJUR.crypto.Util.hashHex(b, "sha256");
      var e = hextob64u(c);
      return e;
    };
    KJUR.jws.IntDate = {};
    KJUR.jws.IntDate.get = function(c) {
      var b = KJUR.jws.IntDate, d = b.getNow, a = b.getZulu;
      if (c == "now") {
        return d();
      } else {
        if (c == "now + 1hour") {
          return d() + 60 * 60;
        } else {
          if (c == "now + 1day") {
            return d() + 60 * 60 * 24;
          } else {
            if (c == "now + 1month") {
              return d() + 60 * 60 * 24 * 30;
            } else {
              if (c == "now + 1year") {
                return d() + 60 * 60 * 24 * 365;
              } else {
                if (c.match(/Z$/)) {
                  return a(c);
                } else {
                  if (c.match(/^[0-9]+$/)) {
                    return parseInt(c);
                  }
                }
              }
            }
          }
        }
      }
      throw "unsupported format: " + c;
    };
    KJUR.jws.IntDate.getZulu = function(a) {
      return zulutosec(a);
    };
    KJUR.jws.IntDate.getNow = function() {
      var a = ~~(new Date() / 1e3);
      return a;
    };
    KJUR.jws.IntDate.intDate2UTCString = function(a) {
      var b = new Date(a * 1e3);
      return b.toUTCString();
    };
    KJUR.jws.IntDate.intDate2Zulu = function(e) {
      var i = new Date(e * 1e3), h = ("0000" + i.getUTCFullYear()).slice(-4), g = ("00" + (i.getUTCMonth() + 1)).slice(-2), b = ("00" + i.getUTCDate()).slice(-2), a = ("00" + i.getUTCHours()).slice(-2), c = ("00" + i.getUTCMinutes()).slice(-2), f = ("00" + i.getUTCSeconds()).slice(-2);
      return h + g + b + a + c + f + "Z";
    };
    if (typeof KJUR == "undefined" || !KJUR) {
      KJUR = {};
    }
    if (typeof KJUR.jws == "undefined" || !KJUR.jws) {
      KJUR.jws = {};
    }
    KJUR.jws.JWSJS = function() {
      var c = KJUR, b = c.jws, a = b.JWS, d = a.readSafeJSONString;
      this.aHeader = [];
      this.sPayload = "";
      this.aSignature = [];
      this.init = function() {
        this.aHeader = [];
        this.sPayload = void 0;
        this.aSignature = [];
      };
      this.initWithJWS = function(f) {
        this.init();
        var e = f.split(".");
        if (e.length != 3) {
          throw "malformed input JWS";
        }
        this.aHeader.push(e[0]);
        this.sPayload = e[1];
        this.aSignature.push(e[2]);
      };
      this.addSignature = function(e, h, m, k) {
        if (this.sPayload === void 0 || this.sPayload === null) {
          throw "there's no JSON-JS signature to add.";
        }
        var l = this.aHeader.length;
        if (this.aHeader.length != this.aSignature.length) {
          throw "aHeader.length != aSignature.length";
        }
        try {
          var f = KJUR.jws.JWS.sign(e, h, this.sPayload, m, k);
          var j = f.split(".");
          var n = j[0];
          var g = j[2];
          this.aHeader.push(j[0]);
          this.aSignature.push(j[2]);
        } catch (i) {
          if (this.aHeader.length > l) {
            this.aHeader.pop();
          }
          if (this.aSignature.length > l) {
            this.aSignature.pop();
          }
          throw "addSignature failed: " + i;
        }
      };
      this.verifyAll = function(h) {
        if (this.aHeader.length !== h.length || this.aSignature.length !== h.length) {
          return false;
        }
        for (var g = 0; g < h.length; g++) {
          var f = h[g];
          if (f.length !== 2) {
            return false;
          }
          var e = this.verifyNth(g, f[0], f[1]);
          if (e === false) {
            return false;
          }
        }
        return true;
      };
      this.verifyNth = function(f, j, g) {
        if (this.aHeader.length <= f || this.aSignature.length <= f) {
          return false;
        }
        var h = this.aHeader[f];
        var k = this.aSignature[f];
        var l = h + "." + this.sPayload + "." + k;
        var e = false;
        try {
          e = a.verify(l, j, g);
        } catch (i) {
          return false;
        }
        return e;
      };
      this.readJWSJS = function(g) {
        if (typeof g === "string") {
          var f = d(g);
          if (f == null) {
            throw "argument is not safe JSON object string";
          }
          this.aHeader = f.headers;
          this.sPayload = f.payload;
          this.aSignature = f.signatures;
        } else {
          try {
            if (g.headers.length > 0) {
              this.aHeader = g.headers;
            } else {
              throw "malformed header";
            }
            if (typeof g.payload === "string") {
              this.sPayload = g.payload;
            } else {
              throw "malformed signatures";
            }
            if (g.signatures.length > 0) {
              this.aSignature = g.signatures;
            } else {
              throw "malformed signatures";
            }
          } catch (e) {
            throw "malformed JWS-JS JSON object: " + e;
          }
        }
      };
      this.getJSON = function() {
        return { headers: this.aHeader, payload: this.sPayload, signatures: this.aSignature };
      };
      this.isEmpty = function() {
        if (this.aHeader.length == 0) {
          return 1;
        }
        return 0;
      };
    };
    exports.SecureRandom = SecureRandom;
    exports.rng_seed_time = rng_seed_time;
    exports.BigInteger = BigInteger;
    exports.RSAKey = RSAKey;
    exports.ECDSA = KJUR.crypto.ECDSA;
    exports.DSA = KJUR.crypto.DSA;
    exports.Signature = KJUR.crypto.Signature;
    exports.MessageDigest = KJUR.crypto.MessageDigest;
    exports.Mac = KJUR.crypto.Mac;
    exports.Cipher = KJUR.crypto.Cipher;
    exports.KEYUTIL = KEYUTIL;
    exports.ASN1HEX = ASN1HEX;
    exports.X509 = X509;
    exports.X509CRL = X509CRL;
    exports.CryptoJS = CryptoJS;
    exports.b64tohex = b64tohex;
    exports.b64toBA = b64toBA;
    exports.ECFieldElementFp = ECFieldElementFp;
    exports.ECPointFp = ECPointFp;
    exports.ECCurveFp = ECCurveFp;
    exports.stoBA = stoBA;
    exports.BAtos = BAtos;
    exports.BAtohex = BAtohex;
    exports.stohex = stohex;
    exports.stob64 = stob64;
    exports.stob64u = stob64u;
    exports.b64utos = b64utos;
    exports.b64tob64u = b64tob64u;
    exports.b64utob64 = b64utob64;
    exports.hex2b64 = hex2b64;
    exports.hextob64u = hextob64u;
    exports.b64utohex = b64utohex;
    exports.utf8tob64u = utf8tob64u;
    exports.b64utoutf8 = b64utoutf8;
    exports.utf8tob64 = utf8tob64;
    exports.b64toutf8 = b64toutf8;
    exports.utf8tohex = utf8tohex;
    exports.hextoutf8 = hextoutf8;
    exports.hextorstr = hextorstr;
    exports.rstrtohex = rstrtohex;
    exports.hextob64 = hextob64;
    exports.hextob64nl = hextob64nl;
    exports.b64nltohex = b64nltohex;
    exports.hextopem = hextopem;
    exports.pemtohex = pemtohex;
    exports.hextoArrayBuffer = hextoArrayBuffer;
    exports.ArrayBuffertohex = ArrayBuffertohex;
    exports.zulutomsec = zulutomsec;
    exports.zulutosec = zulutosec;
    exports.zulutodate = zulutodate;
    exports.datetozulu = datetozulu;
    exports.uricmptohex = uricmptohex;
    exports.hextouricmp = hextouricmp;
    exports.ipv6tohex = ipv6tohex;
    exports.hextoipv6 = hextoipv6;
    exports.hextoip = hextoip;
    exports.iptohex = iptohex;
    exports.ucs2hextoutf8 = ucs2hextoutf8;
    exports.encodeURIComponentAll = encodeURIComponentAll;
    exports.newline_toUnix = newline_toUnix;
    exports.newline_toDos = newline_toDos;
    exports.hextoposhex = hextoposhex;
    exports.intarystrtohex = intarystrtohex;
    exports.strdiffidx = strdiffidx;
    exports.oidtohex = oidtohex;
    exports.hextooid = hextooid;
    exports.strpad = strpad;
    exports.bitstrtoint = bitstrtoint;
    exports.inttobitstr = inttobitstr;
    exports.KJUR = KJUR;
    exports.crypto = KJUR.crypto;
    exports.asn1 = KJUR.asn1;
    exports.jws = KJUR.jws;
    exports.lang = KJUR.lang;
  }
});

// src/index.ts
__export(exports, {
  ApiError: () => ApiError,
  BackendClient: () => BackendClient,
  Capabilities: () => Capabilities,
  ClientType: () => ClientType,
  FrontendClient: () => FrontendClient,
  JobPhase: () => JobPhase,
  PARCEL_RUNTIME_AUD: () => PARCEL_RUNTIME_AUD,
  Parcel: () => Parcel,
  ServiceClient: () => ServiceClient,
  default: () => src_default
});

// src/model.ts
function makePage(ModelTy, podPage, client) {
  return {
    results: podPage.results.map((podModel) => new ModelTy(client, podModel)),
    nextPageToken: podPage.nextPageToken
  };
}

// src/grant.ts
var GRANTS_EP = "grants";
var endpointForId = (id) => `${GRANTS_EP}/${id}`;
var _client;
var Grant2 = class {
  constructor(client, pod) {
    __privateAdd(this, _client, void 0);
    var _a13;
    __privateSet(this, _client, client);
    this.id = pod.id;
    this.createdAt = new Date(pod.createdAt);
    this.granter = pod.granter;
    this.grantee = (_a13 = pod.grantee) != null ? _a13 : "everyone";
    this.condition = pod.condition;
    this.permission = pod.permission;
    this.capabilities = pod.capabilities ? parseCaps(pod.capabilities) : void 0;
    this.delegating = pod.delegating;
  }
  async delete() {
    return __privateGet(this, _client).delete(endpointForId(this.id));
  }
};
_client = new WeakMap();
var GrantImpl;
(function(GrantImpl2) {
  async function create(client, params) {
    const podGrant = await client.create(GRANTS_EP, params);
    return new Grant2(client, podGrant);
  }
  GrantImpl2.create = create;
  async function get(client, id) {
    const podGrant = await client.get(endpointForId(id));
    return new Grant2(client, podGrant);
  }
  GrantImpl2.get = get;
  async function list(client, filter) {
    const podPage = await client.get(GRANTS_EP, filter);
    return makePage(Grant2, podPage, client);
  }
  GrantImpl2.list = list;
  async function delete_(client, id) {
    return client.delete(endpointForId(id));
  }
  GrantImpl2.delete_ = delete_;
})(GrantImpl || (GrantImpl = {}));
var Capabilities;
(function(Capabilities2) {
  Capabilities2[Capabilities2["None"] = 0] = "None";
  Capabilities2[Capabilities2["Read"] = 1] = "Read";
  Capabilities2[Capabilities2["Extend"] = 4] = "Extend";
})(Capabilities || (Capabilities = {}));
function parseCaps(strCaps) {
  if (strCaps === void 0)
    return 0;
  let caps = 0;
  for (const strCap of strCaps.trim().split(/\s+/)) {
    switch (strCap) {
      case "read":
        caps |= 1;
        break;
      case "extend":
        caps |= 4;
        break;
      case "":
        break;
      default:
        throw new Error(`unknown capability "${strCap}"`);
    }
  }
  return caps;
}

// src/permission.ts
var _client2;
var Permission2 = class {
  constructor(client, pod) {
    __privateAdd(this, _client2, void 0);
    __privateSet(this, _client2, client);
    this.id = pod.id;
    this.appId = pod.appId;
    this.createdAt = new Date(pod.createdAt);
    this.grants = pod.grants;
    this.name = pod.name;
    this.description = pod.description;
    this.allowText = pod.allowText;
    this.denyText = pod.denyText;
  }
};
_client2 = new WeakMap();
var PermissionImpl;
(function(PermissionImpl2) {
  async function create(client, appId, params) {
    const podPermission = await client.create(endpointForCollection(appId), params);
    return new Permission2(client, podPermission);
  }
  PermissionImpl2.create = create;
  async function list(client, appId, filter) {
    const podPage = await client.get(endpointForCollection(appId), filter);
    return makePage(Permission2, podPage, client);
  }
  PermissionImpl2.list = list;
  async function get(client, appId, permissionId) {
    const podPermission = await client.get(endpointForId3(appId, permissionId));
    return new Permission2(client, podPermission);
  }
  PermissionImpl2.get = get;
  async function delete_(client, appId, permissionId) {
    return client.delete(endpointForId3(appId, permissionId));
  }
  PermissionImpl2.delete_ = delete_;
})(PermissionImpl || (PermissionImpl = {}));
var endpointForCollection = (appId) => `${endpointForId2(appId)}/permissions`;
var endpointForId3 = (appId, permissionId) => `${endpointForCollection(appId)}/${permissionId}`;

// src/identity.ts
var IDENTITIES_EP = "identities";
var IDENTITIES_ME = `${IDENTITIES_EP}/me`;
var endpointForId4 = (id) => `${IDENTITIES_EP}/${id}`;
var endpointForPermissions = (id) => `${endpointForId4(id)}/permissions`;
var endpointForPermission = (identityId, permissionId) => `${endpointForPermissions(identityId)}/${permissionId}`;
var endpointForLinkedEthAddrs = (id) => `${endpointForId4(id)}/links/ethereum`;
var endpointForLinkedEthAddr = (id, ethAddr) => `${endpointForLinkedEthAddrs(id)}/links/ethereum/${ethAddr}`;
var endpointForTokens = (id) => `${endpointForId4(id)}/tokens`;
var endpointForToken = (id, token) => `${endpointForTokens(id)}/tokens/${token}`;
var _client3;
var Identity2 = class {
  constructor(client, pod) {
    __privateAdd(this, _client3, void 0);
    __privateSet(this, _client3, client);
    this.id = pod.id;
    this.createdAt = new Date(pod.createdAt);
    this.tokenVerifiers = pod.tokenVerifiers;
  }
  async update(params) {
    Object.assign(this, await IdentityImpl.update(__privateGet(this, _client3), this.id, params));
    return this;
  }
  async delete() {
    return IdentityImpl.delete_(__privateGet(this, _client3), this.id);
  }
  async linkEthereumAddress(ethAddr, proof) {
    return IdentityImpl.linkEthereumAddress(__privateGet(this, _client3), this.id, ethAddr, proof);
  }
  async unlinkEthereumAddress(ethAddr) {
    return IdentityImpl.unlinkEthereumAddress(__privateGet(this, _client3), this.id, ethAddr);
  }
  async listLinkedEthereumAddresses(filter) {
    return IdentityImpl.listLinkedEthereumAddresses(__privateGet(this, _client3), this.id, filter);
  }
  async listGrantedPermissions(filter) {
    return IdentityImpl.listGrantedPermissions(__privateGet(this, _client3), this.id, filter);
  }
  async grantPermission(id) {
    return IdentityImpl.grantPermission(__privateGet(this, _client3), this.id, id);
  }
  async getGrantedPermission(id) {
    return IdentityImpl.getGrantedPermission(__privateGet(this, _client3), this.id, id);
  }
  async revokePermission(id) {
    return IdentityImpl.revokePermission(__privateGet(this, _client3), this.id, id);
  }
  async listTokens(filter) {
    return IdentityImpl.listHeldTokens(__privateGet(this, _client3), this.id, filter);
  }
  async getTokenBalance(token) {
    return IdentityImpl.getTokenBalance(__privateGet(this, _client3), this.id, token);
  }
};
_client3 = new WeakMap();
var IdentityImpl;
(function(IdentityImpl2) {
  async function create(client, params) {
    const podIdentity = await client.create(IDENTITIES_EP, params);
    return new Identity2(client, podIdentity);
  }
  IdentityImpl2.create = create;
  async function current(client) {
    const podIdentity = await client.get(IDENTITIES_ME);
    return new Identity2(client, podIdentity);
  }
  IdentityImpl2.current = current;
  async function get(client, id) {
    const podIdentity = await client.get(endpointForId4(id));
    return new Identity2(client, podIdentity);
  }
  IdentityImpl2.get = get;
  async function update(client, id, params) {
    const podIdentity = await client.update(endpointForId4(id), params);
    return new Identity2(client, podIdentity);
  }
  IdentityImpl2.update = update;
  async function delete_(client, id) {
    return client.delete(endpointForId4(id));
  }
  IdentityImpl2.delete_ = delete_;
  async function linkEthereumAddress(client, identity, ethAddr, proof) {
    if (!proof) {
      const { web3 } = globalThis;
      if (!web3) {
        throw new Error("`linkEthereumAddress` must be provided a `proof` when a web3 provider is not present");
      }
      proof = await new Promise((resolve, reject) => {
        const req = {
          method: "personal_sign",
          params: [`parcel identity = ${identity}`, ethAddr],
          from: ethAddr
        };
        web3.currentProvider.sendAsync(req, (err, { result: result2 }) => {
          if (err) {
            reject(err);
            return;
          }
          resolve(result2);
        });
      });
    }
    return client.create(endpointForLinkedEthAddrs(identity), { proof });
  }
  IdentityImpl2.linkEthereumAddress = linkEthereumAddress;
  async function listLinkedEthereumAddresses(client, identityId, filter) {
    const podPage = await client.get(endpointForLinkedEthAddrs(identityId), filter);
    const results = podPage.results.map(({ address, linkedAt }) => ({
      address,
      linkedAt: new Date(linkedAt)
    }));
    return {
      results,
      nextPageToken: podPage.nextPageToken
    };
  }
  IdentityImpl2.listLinkedEthereumAddresses = listLinkedEthereumAddresses;
  async function unlinkEthereumAddress(client, identity, ethAddr) {
    await client.delete(endpointForLinkedEthAddr(identity, ethAddr));
  }
  IdentityImpl2.unlinkEthereumAddress = unlinkEthereumAddress;
  async function grantPermission(client, identityId, permissionId) {
    const { grants } = await client.create(endpointForPermission(identityId, permissionId), {});
    return {
      grants: grants.map((g) => new Grant2(client, g))
    };
  }
  IdentityImpl2.grantPermission = grantPermission;
  async function listGrantedPermissions(client, identityId, filter) {
    const podPage = await client.get(endpointForPermissions(identityId), filter);
    const results = podPage.results.map((podPermission) => new Permission2(client, podPermission));
    return {
      results,
      nextPageToken: podPage.nextPageToken
    };
  }
  IdentityImpl2.listGrantedPermissions = listGrantedPermissions;
  async function getGrantedPermission(client, identityId, permissionId) {
    const podPermission = await client.get(endpointForPermission(identityId, permissionId));
    return new Permission2(client, podPermission);
  }
  IdentityImpl2.getGrantedPermission = getGrantedPermission;
  async function revokePermission(client, identityId, permissionId) {
    await client.delete(endpointForPermission(identityId, permissionId));
  }
  IdentityImpl2.revokePermission = revokePermission;
  async function listHeldTokens(client, identityId, filter) {
    return client.get(endpointForTokens(identityId), filter);
  }
  IdentityImpl2.listHeldTokens = listHeldTokens;
  async function getTokenBalance(client, identityId, tokenId) {
    return client.get(endpointForToken(identityId, tokenId));
  }
  IdentityImpl2.getTokenBalance = getTokenBalance;
})(IdentityImpl || (IdentityImpl = {}));

// src/app.ts
var _client4;
var App2 = class {
  constructor(client, pod) {
    __privateAdd(this, _client4, void 0);
    __privateSet(this, _client4, client);
    this.acceptanceText = pod.acceptanceText;
    this.admins = pod.admins;
    this.allowUserUploads = pod.allowUserUploads;
    this.brandingColor = pod.brandingColor;
    this.category = pod.category;
    this.collaborators = pod.collaborators;
    this.createdAt = new Date(pod.createdAt);
    this.owner = pod.owner;
    this.extendedDescription = pod.extendedDescription;
    this.homepageUrl = pod.homepageUrl;
    this.id = pod.id;
    this.invites = pod.invites;
    this.invitationText = pod.invitationText;
    this.inviteOnly = pod.inviteOnly;
    this.name = pod.name;
    this.organization = pod.organization;
    this.participants = pod.participants;
    this.privacyPolicy = pod.privacyPolicy;
    this.published = pod.published;
    this.rejectionText = pod.rejectionText;
    this.shortDescription = pod.shortDescription;
    this.termsAndConditions = pod.termsAndConditions;
    this.logoUrl = pod.logoUrl;
  }
  async getIdentity() {
    return IdentityImpl.get(__privateGet(this, _client4), this.id);
  }
  async update(params) {
    Object.assign(this, await AppImpl.update(__privateGet(this, _client4), this.id, params));
    return this;
  }
  async updateIdentity(params) {
    return IdentityImpl.update(__privateGet(this, _client4), this.id, params);
  }
  async delete() {
    return AppImpl.delete_(__privateGet(this, _client4), this.id);
  }
  async createPermission(params) {
    return PermissionImpl.create(__privateGet(this, _client4), this.id, params);
  }
  async listPermissions(filter) {
    return PermissionImpl.list(__privateGet(this, _client4), this.id, filter);
  }
  async deletePermission(permissionId) {
    return PermissionImpl.delete_(__privateGet(this, _client4), this.id, permissionId);
  }
};
_client4 = new WeakMap();
var AppImpl;
(function(AppImpl2) {
  async function create(client, params) {
    const podApp = await client.create(APPS_EP, params);
    return new App2(client, podApp);
  }
  AppImpl2.create = create;
  async function get(client, id) {
    const podApp = await client.get(endpointForId2(id));
    return new App2(client, podApp);
  }
  AppImpl2.get = get;
  async function list(client, filter) {
    const podPage = await client.get(APPS_EP, filter);
    return makePage(App2, podPage, client);
  }
  AppImpl2.list = list;
  async function update(client, id, params) {
    const podApp = await client.update(endpointForId2(id), params);
    return new App2(client, podApp);
  }
  AppImpl2.update = update;
  async function delete_(client, id) {
    return client.delete(endpointForId2(id));
  }
  AppImpl2.delete_ = delete_;
})(AppImpl || (AppImpl = {}));
var APPS_EP = "apps";
var endpointForId2 = (id) => `${APPS_EP}/${id}`;

// src/asset.ts
var ASSETS_EP = "escrow/assets";
var endpointForId5 = (id) => `${ASSETS_EP}/${id}`;
var AssetImpl;
(function(AssetImpl2) {
  async function search(client, params) {
    return client.search(`${ASSETS_EP}/search`, params);
  }
  AssetImpl2.search = search;
  async function get(client, assetId) {
    return client.get(endpointForId5(assetId));
  }
  AssetImpl2.get = get;
})(AssetImpl || (AssetImpl = {}));

// src/client.ts
var ClientType;
(function(ClientType2) {
  ClientType2["Frontend"] = "frontend";
  ClientType2["Backend"] = "backend";
  ClientType2["Service"] = "service";
})(ClientType || (ClientType = {}));
var _client5;
var BaseClient = class {
  constructor(client, pod) {
    __privateAdd(this, _client5, void 0);
    __privateSet(this, _client5, client);
    this.id = pod.id;
    this.createdAt = new Date(pod.createdAt);
    this.creator = pod.creator;
    this.appId = pod.appId;
    this.name = pod.name;
    this.type = pod.type;
  }
  async delete() {
    return __privateGet(this, _client5).delete(endpointForId6(this.appId, this.id));
  }
  isFrontend() {
    return this.type === ClientType.Frontend;
  }
  isBackend() {
    return this.type === ClientType.Backend;
  }
  isService() {
    return this.type === ClientType.Service;
  }
};
_client5 = new WeakMap();
function makeClient(client, pod) {
  if (pod.type === ClientType.Frontend)
    return new FrontendClient(client, pod);
  if (pod.type === ClientType.Backend)
    return new BackendClient(client, pod);
  if (pod.type === ClientType.Service)
    return new ServiceClient(client, pod);
  throw new Error(`unrecognized client type`);
}
var FrontendClient = class extends BaseClient {
  constructor(client, pod) {
    super(client, pod);
    this.type = ClientType.Frontend;
    this.redirectUris = pod.redirectUris;
    this.postLogoutRedirectUris = pod.postLogoutRedirectUris;
  }
};
var BackendClient = class extends BaseClient {
  constructor(client, pod) {
    super(client, pod);
    this.type = ClientType.Backend;
    this.redirectUris = pod.redirectUris;
    this.postLogoutRedirectUris = pod.postLogoutRedirectUris;
    this.publicKeys = pod.publicKeys;
  }
};
var ServiceClient = class extends BaseClient {
  constructor(client, pod) {
    super(client, pod);
    this.type = ClientType.Service;
    this.publicKeys = pod.publicKeys;
  }
};
var ClientImpl;
(function(ClientImpl2) {
  async function create(client, appId, params) {
    const podClient = await client.create(endpointForCollection2(appId), params);
    return makeClient(client, podClient);
  }
  ClientImpl2.create = create;
  async function get(client, appId, clientId) {
    const podClient = await client.get(endpointForId6(appId, clientId));
    return makeClient(client, podClient);
  }
  ClientImpl2.get = get;
  async function list(client, appId, filter) {
    const podPage = await client.get(endpointForCollection2(appId), filter);
    const results = podPage.results.map((podClient) => makeClient(client, podClient));
    return {
      results,
      nextPageToken: podPage.nextPageToken
    };
  }
  ClientImpl2.list = list;
  async function update(client, appId, clientId, params) {
    const podClient = await client.update(endpointForId6(appId, clientId), params);
    return makeClient(client, podClient);
  }
  ClientImpl2.update = update;
  async function delete_(client, appId, clientId) {
    return client.delete(endpointForId6(appId, clientId));
  }
  ClientImpl2.delete_ = delete_;
})(ClientImpl || (ClientImpl = {}));
var endpointForCollection2 = (appId) => `${endpointForId2(appId)}/clients`;
var endpointForId6 = (appId, clientId) => `${endpointForCollection2(appId)}/${clientId}`;

// src/compute.ts
var JobPhase;
(function(JobPhase2) {
  JobPhase2["PENDING"] = "Pending";
  JobPhase2["RUNNING"] = "Running";
  JobPhase2["SUCCEEDED"] = "Succeeded";
  JobPhase2["FAILED"] = "Failed";
})(JobPhase || (JobPhase = {}));
var _client6;
var Job2 = class {
  constructor(client, pod) {
    __privateAdd(this, _client6, void 0);
    __privateSet(this, _client6, client);
    this.id = pod.id;
    this.createdAt = new Date(pod.createdAt);
    this.spec = pod.spec;
    this.status = pod.status;
  }
};
_client6 = new WeakMap();
var _client7;
var JobStatusReport2 = class {
  constructor(client, pod) {
    __privateAdd(this, _client7, void 0);
    __privateSet(this, _client7, client);
    this.id = pod.id;
    this.status = pod.status;
  }
};
_client7 = new WeakMap();
var COMPUTE_EP = "compute";
var JOBS_EP = `${COMPUTE_EP}/jobs`;
var endpointForId7 = (id) => `${JOBS_EP}/${id}`;
var statusEndpointForId = (id) => `${JOBS_EP}/${id}/status`;
var ComputeImpl;
(function(ComputeImpl2) {
  async function submitJob(client, spec) {
    const pod = await client.create(JOBS_EP, spec);
    return new Job2(client, pod);
  }
  ComputeImpl2.submitJob = submitJob;
  async function listJobs(client, filter = {}) {
    const podPage = await client.get(JOBS_EP, filter);
    return makePage(Job2, podPage, client);
  }
  ComputeImpl2.listJobs = listJobs;
  async function getJob(client, jobId) {
    const pod = await client.get(endpointForId7(jobId));
    return new Job2(client, pod);
  }
  ComputeImpl2.getJob = getJob;
  async function getJobStatus(client, jobId) {
    const pod = await client.get(statusEndpointForId(jobId));
    return new JobStatusReport2(client, pod);
  }
  ComputeImpl2.getJobStatus = getJobStatus;
  async function terminateJob(client, jobId) {
    return client.delete(endpointForId7(jobId));
  }
  ComputeImpl2.terminateJob = terminateJob;
})(ComputeImpl || (ComputeImpl = {}));

// src/database.ts
var _client8;
var Database2 = class {
  constructor(client, pod) {
    __privateAdd(this, _client8, void 0);
    __privateSet(this, _client8, client);
    this.id = pod.id;
    this.createdAt = new Date(pod.createdAt);
    this.creator = pod.creator;
    this.owner = pod.owner;
    this.name = pod.name;
  }
  async update(params) {
    Object.assign(this, await DatabaseImpl.update(__privateGet(this, _client8), this.id, params));
    return this;
  }
  async delete() {
    return DatabaseImpl.delete_(__privateGet(this, _client8), this.id);
  }
};
_client8 = new WeakMap();
var DatabaseImpl;
(function(DatabaseImpl2) {
  async function get(client, id) {
    const podDatabase = await client.get(endpointForId8(id));
    return new Database2(client, podDatabase);
  }
  DatabaseImpl2.get = get;
  async function create(client, params) {
    const podDatabase = await client.create(DATABASES_EP, params);
    return new Database2(client, podDatabase);
  }
  DatabaseImpl2.create = create;
  async function list(client, filter) {
    const podPage = await client.get(DATABASES_EP, filter);
    return makePage(Database2, podPage, client);
  }
  DatabaseImpl2.list = list;
  async function query(client, id, params) {
    return client.post(endpointForId8(id), params);
  }
  DatabaseImpl2.query = query;
  async function update(client, id, params) {
    const PODDatabase = await client.update(endpointForId8(id), params);
    return new Database2(client, PODDatabase);
  }
  DatabaseImpl2.update = update;
  async function delete_(client, id) {
    return client.delete(endpointForId8(id));
  }
  DatabaseImpl2.delete_ = delete_;
})(DatabaseImpl || (DatabaseImpl = {}));
var DATABASES_EP = "databases";
var endpointForId8 = (id) => `${DATABASES_EP}/${id}`;

// src/document.ts
var import_eventemitter3 = __toModule(require_eventemitter3());
var import_form_data = __toModule(require_form_data());
var _client9;
var Document2 = class {
  constructor(client, pod) {
    __privateAdd(this, _client9, void 0);
    __privateSet(this, _client9, client);
    this.id = pod.id;
    this.createdAt = new Date(pod.createdAt);
    this.creator = pod.creator;
    this.owner = pod.owner;
    this.size = pod.size;
    this.details = pod.details;
    this.originatingJob = pod.originatingJob;
  }
  download() {
    return DocumentImpl.download(__privateGet(this, _client9), this.id);
  }
  async update(params) {
    Object.assign(this, await DocumentImpl.update(__privateGet(this, _client9), this.id, params));
    return this;
  }
  async delete() {
    return DocumentImpl.delete_(__privateGet(this, _client9), this.id);
  }
  async history(filter) {
    return DocumentImpl.history(__privateGet(this, _client9), this.id, filter);
  }
};
_client9 = new WeakMap();
var DocumentImpl;
(function(DocumentImpl2) {
  async function get(client, id) {
    const podDocument = await client.get(endpointForId9(id));
    return new Document2(client, podDocument);
  }
  DocumentImpl2.get = get;
  async function search(client, params) {
    const podPage = await client.search(DOCUMENTS_EP, params);
    return makePage(Document2, podPage, client);
  }
  DocumentImpl2.search = search;
  function upload(client, data, params) {
    return new Upload(client, data, params != null ? params : void 0);
  }
  DocumentImpl2.upload = upload;
  function download(client, id) {
    return client.download(endpointForId9(id) + "/download");
  }
  DocumentImpl2.download = download;
  async function history(client, id, filter) {
    const podPage = await client.get(endpointForId9(id) + "/history", filter);
    const results = podPage.results.map((podAccessEvent) => ({
      createdAt: new Date(podAccessEvent.createdAt),
      document: podAccessEvent.document,
      accessor: podAccessEvent.accessor
    }));
    return {
      results,
      nextPageToken: podPage.nextPageToken
    };
  }
  DocumentImpl2.history = history;
  async function update(client, id, params) {
    const podDocument = await client.update(endpointForId9(id), params);
    return new Document2(client, podDocument);
  }
  DocumentImpl2.update = update;
  async function delete_(client, id) {
    return client.delete(endpointForId9(id));
  }
  DocumentImpl2.delete_ = delete_;
})(DocumentImpl || (DocumentImpl = {}));
var DOCUMENTS_EP = "documents";
var endpointForId9 = (id) => `${DOCUMENTS_EP}/${id}`;
var Upload = class extends import_eventemitter3.default {
  constructor(client, data, sdkParams) {
    super();
    var _b4, _c3;
    this.abortController = new AbortController();
    const form = new import_form_data.default();
    const appendPart = (name, data2, contentType, length) => {
      if (typeof Blob === "undefined") {
        form.append(name, data2, {
          contentType,
          knownLength: length
        });
      } else {
        if (typeof data2 === "string" || data2 instanceof Uint8Array) {
          data2 = new Blob([data2], { type: contentType });
        } else if ("pipe" in data2) {
          throw new TypeError("uploaded data must of type `Storable`");
        }
        form.append(name, data2);
      }
    };
    if (sdkParams) {
      const _a13 = sdkParams, { toApp } = _a13, parcelParams = __objRest(_a13, ["toApp"]);
      if (toApp) {
        parcelParams.details = __spreadProps(__spreadValues({}, parcelParams.details), {
          tags: [...(_c3 = (_b4 = parcelParams == null ? void 0 : parcelParams.details) == null ? void 0 : _b4.tags) != null ? _c3 : [], `to-app-${toApp}`]
        });
      }
      const paramsString = JSON.stringify(parcelParams);
      appendPart("metadata", paramsString, "application/json", paramsString.length);
    }
    appendPart("data", data, "application/octet-stream", data.length);
    client.upload(form, {
      headers: "getHeaders" in form ? form.getHeaders() : void 0,
      signal: this.abortController.signal,
      timeout: false
    }).then((podDocument) => {
      this.emit("finish", new Document2(client, podDocument));
    }).catch((error) => {
      this.emit("error", error);
    });
  }
  abort() {
    this.abortController.abort();
    this.emit("abort");
  }
  get aborted() {
    return this.abortController.signal.aborted;
  }
  get finished() {
    return new Promise((resolve, reject) => {
      this.on("finish", resolve);
      this.on("error", reject);
    });
  }
};

// src/http.ts
var import_abort_controller2 = __toModule(require_abort_controller());
var import_form_data4 = __toModule(require_form_data());

// node_modules/ky/distribution/errors/HTTPError.js
var HTTPError = class extends Error {
  constructor(response, request, options) {
    const code = response.status || response.status === 0 ? response.status : "";
    const title = response.statusText || "";
    const status = `${code} ${title}`.trim();
    const reason = status ? `status code ${status}` : "an unknown error";
    super(`Request failed with ${reason}`);
    this.name = "HTTPError";
    this.response = response;
    this.request = request;
    this.options = options;
  }
};

// node_modules/ky/distribution/errors/TimeoutError.js
var TimeoutError = class extends Error {
  constructor(request) {
    super("Request timed out");
    this.name = "TimeoutError";
    this.request = request;
  }
};

// node_modules/ky/distribution/utils/is.js
var isObject = (value) => value !== null && typeof value === "object";

// node_modules/ky/distribution/utils/merge.js
var validateAndMerge = (...sources) => {
  for (const source of sources) {
    if ((!isObject(source) || Array.isArray(source)) && typeof source !== "undefined") {
      throw new TypeError("The `options` argument must be an object");
    }
  }
  return deepMerge({}, ...sources);
};
var mergeHeaders = (source1 = {}, source2 = {}) => {
  const result2 = new globalThis.Headers(source1);
  const isHeadersInstance = source2 instanceof globalThis.Headers;
  const source = new globalThis.Headers(source2);
  for (const [key, value] of source.entries()) {
    if (isHeadersInstance && value === "undefined" || value === void 0) {
      result2.delete(key);
    } else {
      result2.set(key, value);
    }
  }
  return result2;
};
var deepMerge = (...sources) => {
  let returnValue = {};
  let headers = {};
  for (const source of sources) {
    if (Array.isArray(source)) {
      if (!Array.isArray(returnValue)) {
        returnValue = [];
      }
      returnValue = [...returnValue, ...source];
    } else if (isObject(source)) {
      for (let [key, value] of Object.entries(source)) {
        if (isObject(value) && key in returnValue) {
          value = deepMerge(returnValue[key], value);
        }
        returnValue = __spreadProps(__spreadValues({}, returnValue), { [key]: value });
      }
      if (isObject(source.headers)) {
        headers = mergeHeaders(headers, source.headers);
        returnValue.headers = headers;
      }
    }
  }
  return returnValue;
};

// node_modules/ky/distribution/core/constants.js
var supportsAbortController = typeof globalThis.AbortController === "function";
var supportsStreams = typeof globalThis.ReadableStream === "function";
var supportsFormData = typeof globalThis.FormData === "function";
var requestMethods = ["get", "post", "put", "patch", "head", "delete"];
var responseTypes = {
  json: "application/json",
  text: "text/*",
  formData: "multipart/form-data",
  arrayBuffer: "*/*",
  blob: "*/*"
};
var maxSafeTimeout = 2147483647;
var stop = Symbol("stop");

// node_modules/ky/distribution/utils/normalize.js
var normalizeRequestMethod = (input) => requestMethods.includes(input) ? input.toUpperCase() : input;
var retryMethods = ["get", "put", "head", "delete", "options", "trace"];
var retryStatusCodes = [408, 413, 429, 500, 502, 503, 504];
var retryAfterStatusCodes = [413, 429, 503];
var defaultRetryOptions = {
  limit: 2,
  methods: retryMethods,
  statusCodes: retryStatusCodes,
  afterStatusCodes: retryAfterStatusCodes,
  maxRetryAfter: Number.POSITIVE_INFINITY
};
var normalizeRetryOptions = (retry = {}) => {
  if (typeof retry === "number") {
    return __spreadProps(__spreadValues({}, defaultRetryOptions), {
      limit: retry
    });
  }
  if (retry.methods && !Array.isArray(retry.methods)) {
    throw new Error("retry.methods must be an array");
  }
  if (retry.statusCodes && !Array.isArray(retry.statusCodes)) {
    throw new Error("retry.statusCodes must be an array");
  }
  return __spreadProps(__spreadValues(__spreadValues({}, defaultRetryOptions), retry), {
    afterStatusCodes: retryAfterStatusCodes
  });
};

// node_modules/ky/distribution/utils/time.js
var timeout = async (request, abortController, options) => new Promise((resolve, reject) => {
  const timeoutID = setTimeout(() => {
    if (abortController) {
      abortController.abort();
    }
    reject(new TimeoutError(request));
  }, options.timeout);
  void options.fetch(request).then(resolve).catch(reject).then(() => {
    clearTimeout(timeoutID);
  });
});
var delay = async (ms) => new Promise((resolve) => {
  setTimeout(resolve, ms);
});

// node_modules/ky/distribution/core/Ky.js
var Ky = class {
  constructor(input, options = {}) {
    var _a13, _b4;
    this._retryCount = 0;
    this._input = input;
    this._options = __spreadProps(__spreadValues({
      credentials: this._input.credentials || "same-origin"
    }, options), {
      headers: mergeHeaders(this._input.headers, options.headers),
      hooks: deepMerge({
        beforeRequest: [],
        beforeRetry: [],
        afterResponse: []
      }, options.hooks),
      method: normalizeRequestMethod((_a13 = options.method) !== null && _a13 !== void 0 ? _a13 : this._input.method),
      prefixUrl: String(options.prefixUrl || ""),
      retry: normalizeRetryOptions(options.retry),
      throwHttpErrors: options.throwHttpErrors !== false,
      timeout: typeof options.timeout === "undefined" ? 1e4 : options.timeout,
      fetch: (_b4 = options.fetch) !== null && _b4 !== void 0 ? _b4 : globalThis.fetch.bind(globalThis)
    });
    if (typeof this._input !== "string" && !(this._input instanceof URL || this._input instanceof globalThis.Request)) {
      throw new TypeError("`input` must be a string, URL, or Request");
    }
    if (this._options.prefixUrl && typeof this._input === "string") {
      if (this._input.startsWith("/")) {
        throw new Error("`input` must not begin with a slash when using `prefixUrl`");
      }
      if (!this._options.prefixUrl.endsWith("/")) {
        this._options.prefixUrl += "/";
      }
      this._input = this._options.prefixUrl + this._input;
    }
    if (supportsAbortController) {
      this.abortController = new globalThis.AbortController();
      if (this._options.signal) {
        this._options.signal.addEventListener("abort", () => {
          this.abortController.abort();
        });
      }
      this._options.signal = this.abortController.signal;
    }
    this.request = new globalThis.Request(this._input, this._options);
    if (this._options.searchParams) {
      const textSearchParams = typeof this._options.searchParams === "string" ? this._options.searchParams.replace(/^\?/, "") : new URLSearchParams(this._options.searchParams).toString();
      const searchParams = "?" + textSearchParams;
      const url = this.request.url.replace(/(?:\?.*?)?(?=#|$)/, searchParams);
      if ((supportsFormData && this._options.body instanceof globalThis.FormData || this._options.body instanceof URLSearchParams) && !(this._options.headers && this._options.headers["content-type"])) {
        this.request.headers.delete("content-type");
      }
      this.request = new globalThis.Request(new globalThis.Request(url, this.request), this._options);
    }
    if (this._options.json !== void 0) {
      this._options.body = JSON.stringify(this._options.json);
      this.request.headers.set("content-type", "application/json");
      this.request = new globalThis.Request(this.request, { body: this._options.body });
    }
  }
  static create(input, options) {
    const ky2 = new Ky(input, options);
    const fn = async () => {
      if (ky2._options.timeout > maxSafeTimeout) {
        throw new RangeError(`The \`timeout\` option cannot be greater than ${maxSafeTimeout}`);
      }
      await Promise.resolve();
      let response = await ky2._fetch();
      for (const hook of ky2._options.hooks.afterResponse) {
        const modifiedResponse = await hook(ky2.request, ky2._options, ky2._decorateResponse(response.clone()));
        if (modifiedResponse instanceof globalThis.Response) {
          response = modifiedResponse;
        }
      }
      ky2._decorateResponse(response);
      if (!response.ok && ky2._options.throwHttpErrors) {
        throw new HTTPError(response, ky2.request, ky2._options);
      }
      if (ky2._options.onDownloadProgress) {
        if (typeof ky2._options.onDownloadProgress !== "function") {
          throw new TypeError("The `onDownloadProgress` option must be a function");
        }
        if (!supportsStreams) {
          throw new Error("Streams are not supported in your environment. `ReadableStream` is missing.");
        }
        return ky2._stream(response.clone(), ky2._options.onDownloadProgress);
      }
      return response;
    };
    const isRetriableMethod = ky2._options.retry.methods.includes(ky2.request.method.toLowerCase());
    const result2 = isRetriableMethod ? ky2._retry(fn) : fn();
    for (const [type, mimeType] of Object.entries(responseTypes)) {
      result2[type] = async () => {
        ky2.request.headers.set("accept", ky2.request.headers.get("accept") || mimeType);
        const response = (await result2).clone();
        if (type === "json") {
          if (response.status === 204) {
            return "";
          }
          if (options.parseJson) {
            return options.parseJson(await response.text());
          }
        }
        return response[type]();
      };
    }
    return result2;
  }
  _calculateRetryDelay(error) {
    this._retryCount++;
    if (this._retryCount < this._options.retry.limit && !(error instanceof TimeoutError)) {
      if (error instanceof HTTPError) {
        if (!this._options.retry.statusCodes.includes(error.response.status)) {
          return 0;
        }
        const retryAfter = error.response.headers.get("Retry-After");
        if (retryAfter && this._options.retry.afterStatusCodes.includes(error.response.status)) {
          let after = Number(retryAfter);
          if (Number.isNaN(after)) {
            after = Date.parse(retryAfter) - Date.now();
          } else {
            after *= 1e3;
          }
          if (typeof this._options.retry.maxRetryAfter !== "undefined" && after > this._options.retry.maxRetryAfter) {
            return 0;
          }
          return after;
        }
        if (error.response.status === 413) {
          return 0;
        }
      }
      const BACKOFF_FACTOR = 0.3;
      return BACKOFF_FACTOR * 2 ** (this._retryCount - 1) * 1e3;
    }
    return 0;
  }
  _decorateResponse(response) {
    if (this._options.parseJson) {
      response.json = async () => {
        return this._options.parseJson(await response.text());
      };
    }
    return response;
  }
  async _retry(fn) {
    try {
      return await fn();
    } catch (error) {
      const ms = Math.min(this._calculateRetryDelay(error), maxSafeTimeout);
      if (ms !== 0 && this._retryCount > 0) {
        await delay(ms);
        for (const hook of this._options.hooks.beforeRetry) {
          const hookResult = await hook({
            request: this.request,
            options: this._options,
            error,
            retryCount: this._retryCount
          });
          if (hookResult === stop) {
            return;
          }
        }
        return this._retry(fn);
      }
      throw error;
    }
  }
  async _fetch() {
    for (const hook of this._options.hooks.beforeRequest) {
      const result2 = await hook(this.request, this._options);
      if (result2 instanceof Request) {
        this.request = result2;
        break;
      }
      if (result2 instanceof Response) {
        return result2;
      }
    }
    if (this._options.timeout === false) {
      return this._options.fetch(this.request.clone());
    }
    return timeout(this.request.clone(), this.abortController, this._options);
  }
  _stream(response, onDownloadProgress) {
    const totalBytes = Number(response.headers.get("content-length")) || 0;
    let transferredBytes = 0;
    return new globalThis.Response(new globalThis.ReadableStream({
      async start(controller) {
        const reader = response.body.getReader();
        if (onDownloadProgress) {
          onDownloadProgress({ percent: 0, transferredBytes: 0, totalBytes }, new Uint8Array());
        }
        async function read() {
          const { done, value } = await reader.read();
          if (done) {
            controller.close();
            return;
          }
          if (onDownloadProgress) {
            transferredBytes += value.byteLength;
            const percent = totalBytes === 0 ? 0 : transferredBytes / totalBytes;
            onDownloadProgress({ percent, transferredBytes, totalBytes }, value);
          }
          controller.enqueue(value);
          await read();
        }
        await read();
      }
    }));
  }
};

// node_modules/ky/distribution/index.js
var createInstance = (defaults) => {
  const ky2 = (input, options) => Ky.create(input, validateAndMerge(defaults, options));
  for (const method of requestMethods) {
    ky2[method] = (input, options) => Ky.create(input, validateAndMerge(defaults, options, { method }));
  }
  ky2.create = (newDefaults) => createInstance(validateAndMerge(newDefaults));
  ky2.extend = (newDefaults) => createInstance(validateAndMerge(defaults, newDefaults));
  ky2.stop = stop;
  return ky2;
};
var ky = createInstance();
var distribution_default = ky;

// src/http.ts
var import_param_case = __toModule(require_dist4());

// src/polyfill.ts
var import_web_streams_adapter = __toModule(require_web_streams_adapter());
var import_abort_controller = __toModule(require_abort_controller());
var import_form_data3 = __toModule(require_form_data());

// node_modules/node-fetch/src/index.js
var import_http2 = __toModule(require("http"));
var import_https = __toModule(require("https"));
var import_zlib = __toModule(require("zlib"));
var import_stream2 = __toModule(require("stream"));
var import_data_uri_to_buffer = __toModule(require_src());

// node_modules/node-fetch/src/body.js
var import_stream = __toModule(require("stream"));
var import_util = __toModule(require("util"));
var import_fetch_blob = __toModule(require_fetch_blob());

// node_modules/node-fetch/src/errors/base.js
"use strict";
var FetchBaseError = class extends Error {
  constructor(message, type) {
    super(message);
    Error.captureStackTrace(this, this.constructor);
    this.type = type;
  }
  get name() {
    return this.constructor.name;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
};

// node_modules/node-fetch/src/errors/fetch-error.js
var FetchError = class extends FetchBaseError {
  constructor(message, type, systemError) {
    super(message, type);
    if (systemError) {
      this.code = this.errno = systemError.code;
      this.erroredSysCall = systemError.syscall;
    }
  }
};

// node_modules/node-fetch/src/utils/form-data.js
var import_crypto = __toModule(require("crypto"));

// node_modules/node-fetch/src/utils/is.js
var NAME = Symbol.toStringTag;
var isURLSearchParameters = (object) => {
  return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
};
var isBlob = (object) => {
  return typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
};
function isFormData(object) {
  return typeof object === "object" && typeof object.append === "function" && typeof object.set === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.delete === "function" && typeof object.keys === "function" && typeof object.values === "function" && typeof object.entries === "function" && typeof object.constructor === "function" && object[NAME] === "FormData";
}
var isAbortSignal = (object) => {
  return typeof object === "object" && object[NAME] === "AbortSignal";
};

// node_modules/node-fetch/src/utils/form-data.js
var carriage = "\r\n";
var dashes = "-".repeat(2);
var carriageLength = Buffer.byteLength(carriage);
var getFooter = (boundary) => `${dashes}${boundary}${dashes}${carriage.repeat(2)}`;
function getHeader(boundary, name, field) {
  let header = "";
  header += `${dashes}${boundary}${carriage}`;
  header += `Content-Disposition: form-data; name="${name}"`;
  if (isBlob(field)) {
    header += `; filename="${field.name}"${carriage}`;
    header += `Content-Type: ${field.type || "application/octet-stream"}`;
  }
  return `${header}${carriage.repeat(2)}`;
}
var getBoundary = () => (0, import_crypto.randomBytes)(8).toString("hex");
async function* formDataIterator(form, boundary) {
  for (const [name, value] of form) {
    yield getHeader(boundary, name, value);
    if (isBlob(value)) {
      yield* value.stream();
    } else {
      yield value;
    }
    yield carriage;
  }
  yield getFooter(boundary);
}
function getFormDataLength(form, boundary) {
  let length = 0;
  for (const [name, value] of form) {
    length += Buffer.byteLength(getHeader(boundary, name, value));
    if (isBlob(value)) {
      length += value.size;
    } else {
      length += Buffer.byteLength(String(value));
    }
    length += carriageLength;
  }
  length += Buffer.byteLength(getFooter(boundary));
  return length;
}

// node_modules/node-fetch/src/body.js
var INTERNALS = Symbol("Body internals");
var Body = class {
  constructor(body, {
    size = 0
  } = {}) {
    let boundary = null;
    if (body === null) {
      body = null;
    } else if (isURLSearchParameters(body)) {
      body = Buffer.from(body.toString());
    } else if (isBlob(body)) {
    } else if (Buffer.isBuffer(body)) {
    } else if (import_util.types.isAnyArrayBuffer(body)) {
      body = Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof import_stream.default) {
    } else if (isFormData(body)) {
      boundary = `NodeFetchFormDataBoundary${getBoundary()}`;
      body = import_stream.default.Readable.from(formDataIterator(body, boundary));
    } else {
      body = Buffer.from(String(body));
    }
    this[INTERNALS] = {
      body,
      boundary,
      disturbed: false,
      error: null
    };
    this.size = size;
    if (body instanceof import_stream.default) {
      body.on("error", (err) => {
        const error = err instanceof FetchBaseError ? err : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${err.message}`, "system", err);
        this[INTERNALS].error = error;
      });
    }
  }
  get body() {
    return this[INTERNALS].body;
  }
  get bodyUsed() {
    return this[INTERNALS].disturbed;
  }
  async arrayBuffer() {
    const { buffer, byteOffset, byteLength } = await consumeBody(this);
    return buffer.slice(byteOffset, byteOffset + byteLength);
  }
  async blob() {
    const ct = this.headers && this.headers.get("content-type") || this[INTERNALS].body && this[INTERNALS].body.type || "";
    const buf = await this.buffer();
    return new import_fetch_blob.default([buf], {
      type: ct
    });
  }
  async json() {
    const buffer = await consumeBody(this);
    return JSON.parse(buffer.toString());
  }
  async text() {
    const buffer = await consumeBody(this);
    return buffer.toString();
  }
  buffer() {
    return consumeBody(this);
  }
};
Object.defineProperties(Body.prototype, {
  body: { enumerable: true },
  bodyUsed: { enumerable: true },
  arrayBuffer: { enumerable: true },
  blob: { enumerable: true },
  json: { enumerable: true },
  text: { enumerable: true }
});
async function consumeBody(data) {
  if (data[INTERNALS].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS].disturbed = true;
  if (data[INTERNALS].error) {
    throw data[INTERNALS].error;
  }
  let { body } = data;
  if (body === null) {
    return Buffer.alloc(0);
  }
  if (isBlob(body)) {
    body = body.stream();
  }
  if (Buffer.isBuffer(body)) {
    return body;
  }
  if (!(body instanceof import_stream.default)) {
    return Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const err = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(err);
        throw err;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error) {
    if (error instanceof FetchBaseError) {
      throw error;
    } else {
      throw new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, "system", error);
    }
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer.from(accum.join(""));
      }
      return Buffer.concat(accum, accumBytes);
    } catch (error) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, "system", error);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
var clone = (instance, highWaterMark) => {
  let p1;
  let p2;
  let { body } = instance;
  if (instance.bodyUsed) {
    throw new Error("cannot clone body after it is used");
  }
  if (body instanceof import_stream.default && typeof body.getBoundary !== "function") {
    p1 = new import_stream.PassThrough({ highWaterMark });
    p2 = new import_stream.PassThrough({ highWaterMark });
    body.pipe(p1);
    body.pipe(p2);
    instance[INTERNALS].body = p1;
    body = p2;
  }
  return body;
};
var extractContentType = (body, request) => {
  if (body === null) {
    return null;
  }
  if (typeof body === "string") {
    return "text/plain;charset=UTF-8";
  }
  if (isURLSearchParameters(body)) {
    return "application/x-www-form-urlencoded;charset=UTF-8";
  }
  if (isBlob(body)) {
    return body.type || null;
  }
  if (Buffer.isBuffer(body) || import_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
    return null;
  }
  if (body && typeof body.getBoundary === "function") {
    return `multipart/form-data;boundary=${body.getBoundary()}`;
  }
  if (isFormData(body)) {
    return `multipart/form-data; boundary=${request[INTERNALS].boundary}`;
  }
  if (body instanceof import_stream.default) {
    return null;
  }
  return "text/plain;charset=UTF-8";
};
var getTotalBytes = (request) => {
  const { body } = request;
  if (body === null) {
    return 0;
  }
  if (isBlob(body)) {
    return body.size;
  }
  if (Buffer.isBuffer(body)) {
    return body.length;
  }
  if (body && typeof body.getLengthSync === "function") {
    return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
  }
  if (isFormData(body)) {
    return getFormDataLength(request[INTERNALS].boundary);
  }
  return null;
};
var writeToStream = (dest, { body }) => {
  if (body === null) {
    dest.end();
  } else if (isBlob(body)) {
    body.stream().pipe(dest);
  } else if (Buffer.isBuffer(body)) {
    dest.write(body);
    dest.end();
  } else {
    body.pipe(dest);
  }
};

// node_modules/node-fetch/src/headers.js
var import_util2 = __toModule(require("util"));
var import_http = __toModule(require("http"));
var validateHeaderName = typeof import_http.default.validateHeaderName === "function" ? import_http.default.validateHeaderName : (name) => {
  if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
    const err = new TypeError(`Header name must be a valid HTTP token [${name}]`);
    Object.defineProperty(err, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
    throw err;
  }
};
var validateHeaderValue = typeof import_http.default.validateHeaderValue === "function" ? import_http.default.validateHeaderValue : (name, value) => {
  if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
    const err = new TypeError(`Invalid character in header content ["${name}"]`);
    Object.defineProperty(err, "code", { value: "ERR_INVALID_CHAR" });
    throw err;
  }
};
var Headers = class extends URLSearchParams {
  constructor(init) {
    let result2 = [];
    if (init instanceof Headers) {
      const raw = init.raw();
      for (const [name, values] of Object.entries(raw)) {
        result2.push(...values.map((value) => [name, value]));
      }
    } else if (init == null) {
    } else if (typeof init === "object" && !import_util2.types.isBoxedPrimitive(init)) {
      const method = init[Symbol.iterator];
      if (method == null) {
        result2.push(...Object.entries(init));
      } else {
        if (typeof method !== "function") {
          throw new TypeError("Header pairs must be iterable");
        }
        result2 = [...init].map((pair) => {
          if (typeof pair !== "object" || import_util2.types.isBoxedPrimitive(pair)) {
            throw new TypeError("Each header pair must be an iterable object");
          }
          return [...pair];
        }).map((pair) => {
          if (pair.length !== 2) {
            throw new TypeError("Each header pair must be a name/value tuple");
          }
          return [...pair];
        });
      }
    } else {
      throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
    }
    result2 = result2.length > 0 ? result2.map(([name, value]) => {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return [String(name).toLowerCase(), String(value)];
    }) : void 0;
    super(result2);
    return new Proxy(this, {
      get(target, p, receiver) {
        switch (p) {
          case "append":
          case "set":
            return (name, value) => {
              validateHeaderName(name);
              validateHeaderValue(name, String(value));
              return URLSearchParams.prototype[p].call(receiver, String(name).toLowerCase(), String(value));
            };
          case "delete":
          case "has":
          case "getAll":
            return (name) => {
              validateHeaderName(name);
              return URLSearchParams.prototype[p].call(receiver, String(name).toLowerCase());
            };
          case "keys":
            return () => {
              target.sort();
              return new Set(URLSearchParams.prototype.keys.call(target)).keys();
            };
          default:
            return Reflect.get(target, p, receiver);
        }
      }
    });
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  toString() {
    return Object.prototype.toString.call(this);
  }
  get(name) {
    const values = this.getAll(name);
    if (values.length === 0) {
      return null;
    }
    let value = values.join(", ");
    if (/^content-encoding$/i.test(name)) {
      value = value.toLowerCase();
    }
    return value;
  }
  forEach(callback) {
    for (const name of this.keys()) {
      callback(this.get(name), name);
    }
  }
  *values() {
    for (const name of this.keys()) {
      yield this.get(name);
    }
  }
  *entries() {
    for (const name of this.keys()) {
      yield [name, this.get(name)];
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  raw() {
    return [...this.keys()].reduce((result2, key) => {
      result2[key] = this.getAll(key);
      return result2;
    }, {});
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return [...this.keys()].reduce((result2, key) => {
      const values = this.getAll(key);
      if (key === "host") {
        result2[key] = values[0];
      } else {
        result2[key] = values.length > 1 ? values : values[0];
      }
      return result2;
    }, {});
  }
};
Object.defineProperties(Headers.prototype, ["get", "entries", "forEach", "values"].reduce((result2, property) => {
  result2[property] = { enumerable: true };
  return result2;
}, {}));
function fromRawHeaders(headers = []) {
  return new Headers(headers.reduce((result2, value, index, array) => {
    if (index % 2 === 0) {
      result2.push(array.slice(index, index + 2));
    }
    return result2;
  }, []).filter(([name, value]) => {
    try {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}

// node_modules/node-fetch/src/utils/is-redirect.js
var redirectStatus = new Set([301, 302, 303, 307, 308]);
var isRedirect = (code) => {
  return redirectStatus.has(code);
};

// node_modules/node-fetch/src/response.js
var INTERNALS2 = Symbol("Response internals");
var Response2 = class extends Body {
  constructor(body = null, options = {}) {
    super(body, options);
    const status = options.status || 200;
    const headers = new Headers(options.headers);
    if (body !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(body);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    this[INTERNALS2] = {
      url: options.url,
      status,
      statusText: options.statusText || "",
      headers,
      counter: options.counter,
      highWaterMark: options.highWaterMark
    };
  }
  get url() {
    return this[INTERNALS2].url || "";
  }
  get status() {
    return this[INTERNALS2].status;
  }
  get ok() {
    return this[INTERNALS2].status >= 200 && this[INTERNALS2].status < 300;
  }
  get redirected() {
    return this[INTERNALS2].counter > 0;
  }
  get statusText() {
    return this[INTERNALS2].statusText;
  }
  get headers() {
    return this[INTERNALS2].headers;
  }
  get highWaterMark() {
    return this[INTERNALS2].highWaterMark;
  }
  clone() {
    return new Response2(clone(this, this.highWaterMark), {
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      ok: this.ok,
      redirected: this.redirected,
      size: this.size
    });
  }
  static redirect(url, status = 302) {
    if (!isRedirect(status)) {
      throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
    }
    return new Response2(null, {
      headers: {
        location: new URL(url).toString()
      },
      status
    });
  }
  get [Symbol.toStringTag]() {
    return "Response";
  }
};
Object.defineProperties(Response2.prototype, {
  url: { enumerable: true },
  status: { enumerable: true },
  ok: { enumerable: true },
  redirected: { enumerable: true },
  statusText: { enumerable: true },
  headers: { enumerable: true },
  clone: { enumerable: true }
});

// node_modules/node-fetch/src/request.js
var import_url = __toModule(require("url"));

// node_modules/node-fetch/src/utils/get-search.js
var getSearch = (parsedURL) => {
  if (parsedURL.search) {
    return parsedURL.search;
  }
  const lastOffset = parsedURL.href.length - 1;
  const hash = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
  return parsedURL.href[lastOffset - hash.length] === "?" ? "?" : "";
};

// node_modules/node-fetch/src/request.js
var INTERNALS3 = Symbol("Request internals");
var isRequest = (object) => {
  return typeof object === "object" && typeof object[INTERNALS3] === "object";
};
var Request2 = class extends Body {
  constructor(input, init = {}) {
    let parsedURL;
    if (isRequest(input)) {
      parsedURL = new URL(input.url);
    } else {
      parsedURL = new URL(input);
      input = {};
    }
    let method = init.method || input.method || "GET";
    method = method.toUpperCase();
    if ((init.body != null || isRequest(input)) && input.body !== null && (method === "GET" || method === "HEAD")) {
      throw new TypeError("Request with GET/HEAD method cannot have body");
    }
    const inputBody = init.body ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
    super(inputBody, {
      size: init.size || input.size || 0
    });
    const headers = new Headers(init.headers || input.headers || {});
    if (inputBody !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(inputBody, this);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    let signal = isRequest(input) ? input.signal : null;
    if ("signal" in init) {
      signal = init.signal;
    }
    if (signal !== null && !isAbortSignal(signal)) {
      throw new TypeError("Expected signal to be an instanceof AbortSignal");
    }
    this[INTERNALS3] = {
      method,
      redirect: init.redirect || input.redirect || "follow",
      headers,
      parsedURL,
      signal
    };
    this.follow = init.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init.follow;
    this.compress = init.compress === void 0 ? input.compress === void 0 ? true : input.compress : init.compress;
    this.counter = init.counter || input.counter || 0;
    this.agent = init.agent || input.agent;
    this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;
    this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;
  }
  get method() {
    return this[INTERNALS3].method;
  }
  get url() {
    return (0, import_url.format)(this[INTERNALS3].parsedURL);
  }
  get headers() {
    return this[INTERNALS3].headers;
  }
  get redirect() {
    return this[INTERNALS3].redirect;
  }
  get signal() {
    return this[INTERNALS3].signal;
  }
  clone() {
    return new Request2(this);
  }
  get [Symbol.toStringTag]() {
    return "Request";
  }
};
Object.defineProperties(Request2.prototype, {
  method: { enumerable: true },
  url: { enumerable: true },
  headers: { enumerable: true },
  redirect: { enumerable: true },
  clone: { enumerable: true },
  signal: { enumerable: true }
});
var getNodeRequestOptions = (request) => {
  const { parsedURL } = request[INTERNALS3];
  const headers = new Headers(request[INTERNALS3].headers);
  if (!headers.has("Accept")) {
    headers.set("Accept", "*/*");
  }
  let contentLengthValue = null;
  if (request.body === null && /^(post|put)$/i.test(request.method)) {
    contentLengthValue = "0";
  }
  if (request.body !== null) {
    const totalBytes = getTotalBytes(request);
    if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set("Content-Length", contentLengthValue);
  }
  if (!headers.has("User-Agent")) {
    headers.set("User-Agent", "node-fetch");
  }
  if (request.compress && !headers.has("Accept-Encoding")) {
    headers.set("Accept-Encoding", "gzip,deflate,br");
  }
  let { agent } = request;
  if (typeof agent === "function") {
    agent = agent(parsedURL);
  }
  if (!headers.has("Connection") && !agent) {
    headers.set("Connection", "close");
  }
  const search = getSearch(parsedURL);
  const requestOptions = {
    path: parsedURL.pathname + search,
    pathname: parsedURL.pathname,
    hostname: parsedURL.hostname,
    protocol: parsedURL.protocol,
    port: parsedURL.port,
    hash: parsedURL.hash,
    search: parsedURL.search,
    query: parsedURL.query,
    href: parsedURL.href,
    method: request.method,
    headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
    insecureHTTPParser: request.insecureHTTPParser,
    agent
  };
  return requestOptions;
};

// node_modules/node-fetch/src/errors/abort-error.js
var AbortError = class extends FetchBaseError {
  constructor(message, type = "aborted") {
    super(message, type);
  }
};

// node_modules/node-fetch/src/index.js
var supportedSchemas = new Set(["data:", "http:", "https:"]);
async function fetch(url, options_) {
  return new Promise((resolve, reject) => {
    const request = new Request2(url, options_);
    const options = getNodeRequestOptions(request);
    if (!supportedSchemas.has(options.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${options.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (options.protocol === "data:") {
      const data = (0, import_data_uri_to_buffer.default)(request.url);
      const response2 = new Response2(data, { headers: { "Content-Type": data.typeFull } });
      resolve(response2);
      return;
    }
    const send = (options.protocol === "https:" ? import_https.default : import_http2.default).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error = new AbortError("The operation was aborted.");
      reject(error);
      if (request.body && request.body instanceof import_stream2.default.Readable) {
        request.body.destroy(error);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(options);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (err) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
      finalize();
    });
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location = headers.get("Location");
        const locationURL = location === null ? null : new URL(location, request.url);
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              try {
                headers.set("Location", locationURL);
              } catch (error) {
                reject(error);
              }
            }
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal,
              size: request.size
            };
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_stream2.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            resolve(fetch(new Request2(locationURL, requestOptions)));
            finalize();
            return;
          }
          default:
        }
      }
      response_.once("end", () => {
        if (signal) {
          signal.removeEventListener("abort", abortAndFinalize);
        }
      });
      let body = (0, import_stream2.pipeline)(response_, new import_stream2.PassThrough(), (error) => {
        reject(error);
      });
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response2(body, responseOptions);
        resolve(response);
        return;
      }
      const zlibOptions = {
        flush: import_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_zlib.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_stream2.pipeline)(body, import_zlib.default.createGunzip(zlibOptions), (error) => {
          reject(error);
        });
        response = new Response2(body, responseOptions);
        resolve(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_stream2.pipeline)(response_, new import_stream2.PassThrough(), (error) => {
          reject(error);
        });
        raw.once("data", (chunk) => {
          if ((chunk[0] & 15) === 8) {
            body = (0, import_stream2.pipeline)(body, import_zlib.default.createInflate(), (error) => {
              reject(error);
            });
          } else {
            body = (0, import_stream2.pipeline)(body, import_zlib.default.createInflateRaw(), (error) => {
              reject(error);
            });
          }
          response = new Response2(body, responseOptions);
          resolve(response);
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_stream2.pipeline)(body, import_zlib.default.createBrotliDecompress(), (error) => {
          reject(error);
        });
        response = new Response2(body, responseOptions);
        resolve(response);
        return;
      }
      response = new Response2(body, responseOptions);
      resolve(response);
    });
    writeToStream(request_, request);
  });
}

// src/polyfill.ts
var webStreams = __toModule(require_ponyfill_es2018());
var _a;
globalThis.fetch = (_a = globalThis.fetch) != null ? _a : async (url, options) => fetch(url, __spreadValues({ highWaterMark: 1e7 }, options));
var _a2;
globalThis.Headers = (_a2 = globalThis.Headers) != null ? _a2 : Headers;
var _a3;
globalThis.Request = (_a3 = globalThis.Request) != null ? _a3 : Request2;
var _a4;
globalThis.Response = (_a4 = globalThis.Response) != null ? _a4 : Response2;
var _a5;
globalThis.AbortController = (_a5 = globalThis.AbortController) != null ? _a5 : import_abort_controller.default;
var _a6;
globalThis.FormData = (_a6 = globalThis.FormData) != null ? _a6 : import_form_data3.default;
var _a7;
globalThis.ReadableStream = (_a7 = globalThis.ReadableStream) != null ? _a7 : webStreams.ReadableStream;
var _a8;
globalThis.WritableStream = (_a8 = globalThis.WritableStream) != null ? _a8 : webStreams.WritableStream;
var toReadableStreamPF = (0, import_web_streams_adapter.createReadableStreamWrapper)(webStreams.ReadableStream);
var toWritableStreamPF = (0, import_web_streams_adapter.createWritableStreamWrapper)(webStreams.WritableStream);
async function pipeToPolyfill(body, sink) {
  const readablePF = toReadableStreamPF(body);
  const writablePF = toWritableStreamPF(sink);
  return readablePF.pipeTo(writablePF);
}

// src/http.ts
var _a9, _b, _c;
var DEFAULT_API_URL = (_c = (_b = (_a9 = globalThis == null ? void 0 : globalThis.process) == null ? void 0 : _a9.env) == null ? void 0 : _b.PARCEL_API_URL) != null ? _c : "https://api.oasislabs.com/parcel/v1";
var _a10, _b2, _c2;
var DEFAULT_STORAGE_URL = (_c2 = (_b2 = (_a10 = globalThis == null ? void 0 : globalThis.process) == null ? void 0 : _a10.env) == null ? void 0 : _b2.PARCEL_STORAGE_URL) != null ? _c2 : "https://storage.oasislabs.com/v1/parcel";
var DEFAULT_RESPONSE_CODES = new Map([
  ["POST", 200],
  ["PUT", 200],
  ["PATCH", 200],
  ["DELETE", 204]
]);
var HttpClient = class {
  constructor(tokenProvider, config) {
    this.tokenProvider = tokenProvider;
    var _a13, _b4;
    this.apiUrl = (_b4 = (_a13 = config == null ? void 0 : config.apiUrl) == null ? void 0 : _a13.replace(/\/$/, "")) != null ? _b4 : DEFAULT_API_URL;
    if (config == null ? void 0 : config.storageUrl) {
      this.storageUrl = config.storageUrl;
    } else if (config == null ? void 0 : config.apiUrl) {
      const apiUrl = new URL(this.apiUrl);
      if (/local/g.test(apiUrl.host) || /^parcel-(run|gate)way/g.test(apiUrl.host)) {
        this.storageUrl = `${this.apiUrl}/documents`;
      } else {
        const storageHost = apiUrl.host.replace(/^\w+\./, "storage.");
        this.storageUrl = `${apiUrl.protocol}//${storageHost}/v1/parcel`;
      }
    } else {
      this.storageUrl = DEFAULT_STORAGE_URL;
    }
    this.apiKy = distribution_default.create(__spreadProps(__spreadValues({}, config == null ? void 0 : config.httpClientConfig), {
      timeout: 3e4,
      prefixUrl: this.apiUrl,
      headers: {
        "x-requested-with": "@oasislabs/parcel"
      },
      hooks: {
        beforeRequest: [
          appendAsLastBeforeRequest(dontCloneForAfterResponses()),
          async (req) => {
            req.headers.set("authorization", `Bearer ${await this.tokenProvider.getToken()}`);
          }
        ],
        afterResponse: [
          async (req, opts, res) => {
            var _a14, _b5;
            if (res.redirected && (res.status === 401 || res.status === 403) && (res.url.startsWith(this.apiUrl) || res.url.startsWith(this.storageUrl))) {
              return this.apiKy(res.url, {
                method: req.method,
                prefixUrl: ""
              });
            }
            if (isApiErrorResponse(res)) {
              throw new ApiError(req, opts, res, `Error from ${req.url}: ${(await res.json()).error}`);
            }
            const allowedStatusCodes = (_a14 = req.allowedStatusCodes) != null ? _a14 : [];
            allowedStatusCodes.push((_b5 = DEFAULT_RESPONSE_CODES.get(req.method)) != null ? _b5 : 200);
            if (res.ok && !allowedStatusCodes.includes(res.status)) {
              const endpoint = res.url.replace(this.apiUrl, "");
              throw new ApiError(req, opts, res, `${req.method} ${endpoint} returned unexpected status ${res.status}. expected: ${allowedStatusCodes.join(" | ")}.`);
            }
          }
        ]
      }
    }));
  }
  async get(endpoint, params = {}, requestOptions) {
    let hasParams = false;
    const kebabCaseParams = {};
    for (const [k, v] of Object.entries(params)) {
      if (v !== void 0) {
        hasParams = true;
        kebabCaseParams[(0, import_param_case.paramCase)(k)] = v instanceof Date ? v.getTime() : v;
      }
    }
    const response = await this.apiKy.get(endpoint, __spreadValues({
      searchParams: hasParams ? kebabCaseParams : void 0
    }, requestOptions));
    return response.json();
  }
  async upload(data, requestOptions) {
    return this.create(this.storageUrl, data, __spreadValues({
      prefixUrl: ""
    }, requestOptions));
  }
  async create(endpoint, data, requestOptions) {
    var _a13, _b4;
    return this.post(endpoint, data, __spreadProps(__spreadValues({}, requestOptions), {
      hooks: {
        beforeRequest: [...(_b4 = (_a13 = requestOptions == null ? void 0 : requestOptions.hooks) == null ? void 0 : _a13.beforeRequest) != null ? _b4 : [], addAllowedStatusCode(201)]
      }
    }));
  }
  async search(baseEndpoint, params, requestOptions) {
    return this.post(`${baseEndpoint}/search`, params, requestOptions);
  }
  async post(endpoint, data, requestOptions) {
    const opts = requestOptions != null ? requestOptions : {};
    if (data !== void 0) {
      if ("getBuffer" in data && typeof data.getBuffer === "function" || data instanceof import_form_data4.default) {
        opts.body = data;
      } else {
        opts.json = data;
      }
    }
    return (await this.apiKy.post(endpoint, opts)).json();
  }
  async update(endpoint, params) {
    return this.put(endpoint, params);
  }
  async put(endpoint, params) {
    return (await this.apiKy.put(endpoint, { json: params })).json();
  }
  async delete(endpoint) {
    await this.apiKy.delete(endpoint);
  }
  download(endpoint) {
    return new Download2(this.apiKy, endpoint);
  }
};
function dontCloneForAfterResponses() {
  return async (req, opts) => {
    var _a13, _b4;
    if (!((_b4 = (_a13 = opts.hooks) == null ? void 0 : _a13.afterResponse) == null ? void 0 : _b4.length))
      return;
    const { afterResponse } = opts.hooks;
    opts.hooks.afterResponse = [];
    let response = await opts.fetch(req.clone());
    for (const hook of afterResponse) {
      const modifiedResponse = await hook(req, opts, response);
      if (modifiedResponse instanceof globalThis.Response) {
        response = modifiedResponse;
      }
    }
    return response;
  };
}
function appendAsLastBeforeRequest(hookToSchedule) {
  return (req, opts) => {
    if (!opts.hooks)
      opts.hooks = {};
    if (!opts.hooks.beforeRequest)
      opts.hooks.beforeRequest = [];
    opts.hooks.beforeRequest.push(hookToSchedule);
  };
}
function attachContext(context) {
  return (req) => {
    req.context = context;
  };
}
function addAllowedStatusCode(status) {
  return (req) => {
    var _a13;
    req.allowedStatusCodes = (_a13 = req.allowedStatusCodes) != null ? _a13 : [];
    req.allowedStatusCodes.push(status);
  };
}
var Download2 = class {
  constructor(client, endpoint) {
    this.client = client;
    this.endpoint = endpoint;
    this.abortController = new import_abort_controller2.default();
  }
  async *[Symbol.asyncIterator]() {
    var _a13;
    const body = (_a13 = await this.makeRequest()) == null ? void 0 : _a13.body;
    if (!body)
      return;
    if (body.getReader === void 0) {
      const bodyReadable = body;
      yield* bodyReadable;
    } else {
      const rdr = body.getReader();
      let chunk;
      do {
        chunk = await rdr.read();
        if (chunk.value)
          yield chunk.value;
      } while (!chunk.done);
    }
  }
  abort() {
    this.abortController.abort();
  }
  get aborted() {
    return this.abortController.signal.aborted;
  }
  async pipeTo(sink) {
    if ("getWriter" in sink) {
      const { body } = await this.makeRequest();
      if (!body)
        return;
      if (body.pipeTo) {
        return body.pipeTo(sink);
      }
      return pipeToPolyfill(body, sink);
    }
    const { Readable } = (await import("stream")).default;
    return new Promise((resolve, reject) => {
      Readable.from(this, { objectMode: false }).on("error", reject).pipe(sink).on("error", reject).on("finish", resolve);
    });
  }
  async makeRequest() {
    if (!this.res) {
      this.res = this.client.get(this.endpoint, {
        signal: this.abortController.signal,
        hooks: {
          beforeRequest: [attachContext("document download")]
        }
      });
    }
    return this.res;
  }
};
var ApiError = class extends HTTPError {
  constructor(request, options, response, message) {
    super(response, request, options);
    this.name = "ApiError";
    this.message = request.context ? `error in ${request.context}: ${message}` : message;
  }
  static async fromHTTPError(error) {
    const res = error.response;
    return new ApiError(error.request, error.options, res, (await res.json()).error);
  }
};
function isApiErrorResponse(response) {
  var _a13, _b4;
  const isJson = (_b4 = (_a13 = response.headers.get("content-type")) == null ? void 0 : _a13.startsWith("application/json")) != null ? _b4 : false;
  return !response.ok && isJson;
}

// src/meter.ts
var _client10;
var MeteringReport2 = class {
  constructor(client, pod) {
    __privateAdd(this, _client10, void 0);
    __privateSet(this, _client10, client);
    this.createCount = pod.createCount;
    this.readCount = pod.readCount;
    this.writeCount = pod.writeCount;
    this.deleteCount = pod.deleteCount;
    this.uploadCount = pod.uploadCount;
    this.downloadCount = pod.downloadCount;
    this.uploadSizeBytes = pod.uploadSizeBytes;
    this.downloadSizeBytes = pod.downloadSizeBytes;
    this.computeMsec = pod.computeMsec;
  }
};
_client10 = new WeakMap();
var _client11;
var MeteringQuota2 = class {
  constructor(client, pod) {
    __privateAdd(this, _client11, void 0);
    __privateSet(this, _client11, client);
    this.apiCallsLimit = pod.apiCallsLimit;
    this.accessedBytesLimit = pod.accessedBytesLimit;
    this.computeMsecLimit = pod.computeMsecLimit;
  }
};
_client11 = new WeakMap();
var USAGE_EP = "usage";
var QUOTA_EP = "quota";
var MeterImpl;
(function(MeterImpl2) {
  async function getUsage(client, filter) {
    const pod = await client.get(USAGE_EP, filter);
    return new MeteringReport2(client, pod);
  }
  MeterImpl2.getUsage = getUsage;
  async function getQuota(client) {
    const pod = await client.get(QUOTA_EP);
    return new MeteringQuota2(client, pod);
  }
  MeterImpl2.getQuota = getQuota;
  async function setQuota(client, params) {
    const pod = await client.put(QUOTA_EP, params);
    return new MeteringQuota2(client, pod);
  }
  MeterImpl2.setQuota = setQuota;
})(MeterImpl || (MeterImpl = {}));

// src/token.ts
var import_jsrsasign = __toModule(require_jsrsasign());
var _a11;
var TokenError = class extends HTTPError {
  constructor(request, options, response, responseJson) {
    super(response, request, options);
    this.responseJson = responseJson;
    this.name = "TokenError";
    this.message = (_a11 = this.responseJson.error_description) != null ? _a11 : this.responseJson.error;
  }
};
var tokenKy = distribution_default.create({
  hooks: {
    beforeRequest: [appendAsLastBeforeRequest(dontCloneForAfterResponses())],
    afterResponse: [
      async (req, opts, res) => {
        var _a13, _b4;
        const isJson = (_b4 = (_a13 = res.headers.get("content-type")) == null ? void 0 : _a13.startsWith("application/json")) != null ? _b4 : false;
        if (!res.ok && isJson) {
          throw new TokenError(req, opts, res, await res.json());
        }
      }
    ]
  }
});
var _a12, _b3;
var DEFAULT_TOKEN_ENDPOINT = ((_b3 = (_a12 = globalThis == null ? void 0 : globalThis.process) == null ? void 0 : _a12.env) == null ? void 0 : _b3.PARCEL_AUTH_URL) ? `${globalThis.process.env.PARCEL_AUTH_URL}/oauth/token` : "https://auth.oasislabs.com/oauth/token";
var PARCEL_RUNTIME_AUD = "https://api.oasislabs.com/parcel";
var DEFAULT_SCOPES = ["parcel.full"];
var TokenProvider = class {
  static fromSource(source) {
    if (typeof source === "string")
      return new StaticTokenProvider(source);
    if ("principal" in source)
      return new SelfIssuedTokenProvider(source);
    if ("refreshToken" in source)
      return new RefreshingTokenProvider(source);
    if ("clientId" in source)
      return new RenewingTokenProvider(source);
    throw new Error(`unrecognized \`tokenSource\`: ${JSON.stringify(source)}`);
  }
};
var ExpiringTokenProvider = class {
  static isTokenProvider(thing) {
    return thing && typeof thing.getToken === "function";
  }
  async getToken() {
    if (this.token === void 0 || this.token.isExpired())
      this.token = await this.renewToken();
    return this.token.toString();
  }
};
var StaticTokenProvider = class {
  constructor(token) {
    this.token = token;
  }
  async getToken() {
    return this.token;
  }
};
var RenewingTokenProvider = class extends ExpiringTokenProvider {
  constructor({
    clientId,
    privateKey,
    scopes,
    tokenEndpoint,
    audience
  }) {
    super();
    this.clientAssertionLifetime = 1 * 60 * 60;
    if (privateKey.kty !== "EC") {
      throw new Error("Private key should be an ECDSA key.");
    }
    this.privateKey = privateKey;
    const privateKeyPEM = jwkToPem(privateKey);
    this.privateKeyPEM = privateKeyPEM;
    this.clientId = clientId;
    this.tokenEndpoint = tokenEndpoint != null ? tokenEndpoint : DEFAULT_TOKEN_ENDPOINT;
    this.audience = audience != null ? audience : PARCEL_RUNTIME_AUD;
    this.scopes = scopes != null ? scopes : DEFAULT_SCOPES;
  }
  async renewToken() {
    const clientAssertion = makeJWT({
      privateKey: this.privateKeyPEM,
      keyId: this.privateKey.kid,
      payload: {
        sub: this.clientId,
        iss: this.clientId,
        aud: this.tokenEndpoint,
        jti: import_jsrsasign.default.KJUR.crypto.Util.getRandomHexOfNbytes(8)
      },
      lifetime: this.clientAssertionLifetime
    });
    const authParams = new URLSearchParams();
    authParams.append("grant_type", "client_credentials");
    authParams.append("client_assertion", clientAssertion);
    authParams.append("client_assertion_type", "urn:ietf:params:oauth:client-assertion-type:jwt-bearer");
    authParams.append("scope", this.scopes.join(" "));
    authParams.append("audience", this.audience);
    return Token2.fromResponse(tokenKy.post(this.tokenEndpoint, { body: authParams }));
  }
};
var RefreshingTokenProvider = class extends ExpiringTokenProvider {
  constructor({ refreshToken, tokenEndpoint, audience }) {
    super();
    this.refreshToken = refreshToken;
    this.tokenEndpoint = tokenEndpoint;
    this.audience = audience;
  }
  async renewToken() {
    const refreshParams = new URLSearchParams();
    refreshParams.append("grant_type", "refresh_token");
    refreshParams.append("refresh_token", this.refreshToken);
    refreshParams.append("audience", this.audience);
    const res = tokenKy.post(this.tokenEndpoint, { body: refreshParams });
    res.then(async (refreshResponse) => {
      this.refreshToken = (await refreshResponse.clone().json()).refresh_token;
    }).catch(() => {
    });
    return Token2.fromResponse(res);
  }
};
var SelfIssuedTokenProvider = class extends ExpiringTokenProvider {
  constructor({
    principal,
    privateKey,
    scopes,
    tokenLifetime
  }) {
    super();
    this.privateKey = privateKey;
    const privateKeyPEM = jwkToPem(privateKey);
    this.privateKeyPEM = privateKeyPEM;
    this.principal = principal;
    this.scopes = scopes != null ? scopes : DEFAULT_SCOPES;
    this.tokenLifetime = tokenLifetime != null ? tokenLifetime : 1 * 60 * 60;
  }
  async renewToken() {
    const expiry = Date.now() / 1e3 + this.tokenLifetime;
    const token = makeJWT({
      privateKey: this.privateKeyPEM,
      keyId: this.privateKey.kid,
      payload: {
        sub: this.principal,
        iss: this.principal,
        aud: PARCEL_RUNTIME_AUD,
        scope: this.scopes.join(" ")
      },
      lifetime: this.tokenLifetime
    });
    return new Token2(token, expiry);
  }
};
var Token2 = class {
  constructor(token, expiry) {
    this.token = token;
    this.expiry = expiry;
  }
  static async fromResponse(response) {
    const requestTime = Date.now();
    const body = await (await response).json();
    return new Token2(body.access_token, requestTime + body.expires_in * 1e3);
  }
  isExpired() {
    return this.expiry <= Date.now();
  }
  toString() {
    return this.token;
  }
};
function jwkToPem(jwk) {
  if (jwk.kty !== "EC" || jwk.alg !== "ES256") {
    throw new Error(`Unsupported private key. Expected \`alg: 'ES256'\` but was \`${jwk.alg}\` }`);
  }
  const kjurJWK = JSON.parse(JSON.stringify(jwk));
  kjurJWK.crv = "secp256r1";
  const privateKey = import_jsrsasign.default.KEYUTIL.getPEM(import_jsrsasign.default.KEYUTIL.getKey(kjurJWK), "PKCS8PRV");
  return privateKey;
}
function makeJWT({
  privateKey,
  keyId,
  payload,
  lifetime
}) {
  const header = {
    alg: "ES256",
    typ: "JWT",
    kid: keyId
  };
  const now = Math.floor(Date.now() / 1e3);
  payload.iat = now - 2 * 60;
  payload.exp = now + lifetime;
  return import_jsrsasign.default.KJUR.jws.JWS.sign(null, header, payload, privateKey);
}

// src/tokenization.ts
var TOKENS_EP = "tokens";
var RECEIPTS_EP = "receipts";
var endpointForId10 = (id) => `${TOKENS_EP}/${id}`;
var endpointForAssets = (token) => `${endpointForId10(token)}/assets`;
var endpointForAsset = (token, asset) => `${endpointForAssets(token)}/${asset}`;
var endpointForTransfers = (id) => `${endpointForId10(id)}/transfers`;
var endpointForTransfer = (token, receipt) => `${endpointForTransfers(token)}/${receipt}`;
var _client12;
var Token3 = class {
  constructor(client, pod) {
    __privateAdd(this, _client12, void 0);
    __privateSet(this, _client12, client);
    this.id = pod.id;
    this.creator = pod.creator;
    this.createdAt = new Date(pod.createdAt);
    this.grant = pod.grant;
    this.supply = pod.supply;
    this.consumesAssets = pod.consumesAssets;
    this.ethBridge = pod.ethBridge;
  }
  async delete() {
    return TokenImpl.delete_(__privateGet(this, _client12), this.id);
  }
  async searchAssets(filter) {
    return AssetImpl.search(__privateGet(this, _client12), __spreadProps(__spreadValues({}, filter), {
      token: this.id
    }));
  }
  async addAsset(asset) {
    return TokenImpl.addAsset(__privateGet(this, _client12), this.id, asset);
  }
  async removeAsset(asset) {
    return TokenImpl.removeAsset(__privateGet(this, _client12), this.id, asset);
  }
  async transfer(amount, recipient) {
    return TokenImpl.transfer(__privateGet(this, _client12), this.id, amount, recipient);
  }
  async listTransfers(filter) {
    return TokenImpl.listTransferReceipts(__privateGet(this, _client12), this.id, filter);
  }
};
_client12 = new WeakMap();
var TokenImpl;
(function(TokenImpl2) {
  async function mint(client, params) {
    const podToken = await client.create(TOKENS_EP, params);
    return new Token3(client, podToken);
  }
  TokenImpl2.mint = mint;
  async function get(client, id) {
    const podToken = await client.get(endpointForId10(id));
    return new Token3(client, podToken);
  }
  TokenImpl2.get = get;
  async function delete_(client, id) {
    return client.delete(endpointForId10(id));
  }
  TokenImpl2.delete_ = delete_;
  async function search(client, params) {
    const podPage = await client.search(TOKENS_EP, params);
    return makePage(Token3, podPage, client);
  }
  TokenImpl2.search = search;
  async function addAsset(client, token, asset) {
    return client.post(endpointForAsset(token, asset), void 0);
  }
  TokenImpl2.addAsset = addAsset;
  async function removeAsset(client, token, asset) {
    await client.delete(endpointForAsset(token, asset));
  }
  TokenImpl2.removeAsset = removeAsset;
  async function transfer(client, token, amount, recipient) {
    if (amount % 1 !== 0 || amount < 0) {
      throw new Error(`invalid token amount ${amount}. must be a positive integer`);
    }
    const podReceipt = await client.post(endpointForTransfers(token), {
      recipient,
      amount
    });
    return __spreadProps(__spreadValues({}, podReceipt), {
      completedAt: new Date(podReceipt.completedAt)
    });
  }
  TokenImpl2.transfer = transfer;
  async function listTransferReceipts(client, tokenId, filter) {
    const podPage = await client.get(endpointForTransfers(tokenId), filter);
    return __spreadProps(__spreadValues({}, podPage), {
      results: podPage.results.map((podReceipt) => __spreadProps(__spreadValues({}, podReceipt), {
        completedAt: new Date(podReceipt.completedAt)
      }))
    });
  }
  TokenImpl2.listTransferReceipts = listTransferReceipts;
  async function getTransferReceipt(client, receipt, token) {
    const url = token ? endpointForTransfer(token, receipt) : `${RECEIPTS_EP}/${receipt}`;
    const podReceipt = await client.get(url);
    return __spreadProps(__spreadValues({}, podReceipt), {
      completedAt: new Date(podReceipt.completedAt)
    });
  }
  TokenImpl2.getTransferReceipt = getTransferReceipt;
})(TokenImpl || (TokenImpl = {}));

// src/index.ts
var Parcel = class {
  constructor(tokenSource, config) {
    const tokenProvider = TokenProvider.fromSource(tokenSource);
    this.client = new HttpClient(tokenProvider, {
      apiUrl: config == null ? void 0 : config.apiUrl,
      storageUrl: config == null ? void 0 : config.storageUrl,
      httpClientConfig: config == null ? void 0 : config.httpClientConfig
    });
  }
  get apiUrl() {
    return this.client.apiUrl;
  }
  async createIdentity(params) {
    return IdentityImpl.create(this.client, params);
  }
  async getCurrentIdentity() {
    if (!this.currentIdentity) {
      this.currentIdentity = await IdentityImpl.current(this.client);
    }
    return this.currentIdentity;
  }
  async createDatabase(params) {
    return DatabaseImpl.create(this.client, params);
  }
  async getDatabase(id) {
    return DatabaseImpl.get(this.client, id);
  }
  async updateDatabase(id, params) {
    return DatabaseImpl.update(this.client, id, params);
  }
  async queryDatabase(id, params) {
    return DatabaseImpl.query(this.client, id, params);
  }
  async listDatabases(params) {
    return DatabaseImpl.list(this.client, params);
  }
  async deleteDatabase(id) {
    return DatabaseImpl.delete_(this.client, id);
  }
  uploadDocument(data, params) {
    return DocumentImpl.upload(this.client, data, params);
  }
  async getDocument(id) {
    return DocumentImpl.get(this.client, id);
  }
  async searchDocuments(params) {
    return DocumentImpl.search(this.client, params);
  }
  downloadDocument(id) {
    return DocumentImpl.download(this.client, id);
  }
  async getDocumentHistory(id, filter) {
    return DocumentImpl.history(this.client, id, filter);
  }
  async updateDocument(id, update) {
    return DocumentImpl.update(this.client, id, update);
  }
  async deleteDocument(id) {
    return DocumentImpl.delete_(this.client, id);
  }
  async createApp(params) {
    return AppImpl.create(this.client, params);
  }
  async getApp(id) {
    return AppImpl.get(this.client, id);
  }
  async listApps(filter) {
    return AppImpl.list(this.client, filter);
  }
  async updateApp(id, update) {
    return AppImpl.update(this.client, id, update);
  }
  async deleteApp(id) {
    return AppImpl.delete_(this.client, id);
  }
  async createPermission(appId, params) {
    return PermissionImpl.create(this.client, appId, params);
  }
  async listPermissions(appId, filter) {
    return PermissionImpl.list(this.client, appId, filter);
  }
  async deletePermission(appId, permissionId) {
    return PermissionImpl.delete_(this.client, appId, permissionId);
  }
  async createClient(appId, params) {
    return ClientImpl.create(this.client, appId, params);
  }
  async getClient(appId, clientId) {
    return ClientImpl.get(this.client, appId, clientId);
  }
  async listClients(appId, filter) {
    return ClientImpl.list(this.client, appId, filter);
  }
  async updateClient(appId, clientId, update) {
    return ClientImpl.update(this.client, appId, clientId, update);
  }
  async deleteClient(appId, clientId) {
    return ClientImpl.delete_(this.client, appId, clientId);
  }
  async createGrant(params) {
    return GrantImpl.create(this.client, params);
  }
  async getGrant(id) {
    return GrantImpl.get(this.client, id);
  }
  async listGrants(filter) {
    return GrantImpl.list(this.client, filter);
  }
  async deleteGrant(id) {
    return GrantImpl.delete_(this.client, id);
  }
  async submitJob(spec) {
    return ComputeImpl.submitJob(this.client, spec);
  }
  async listJobs(filter = {}) {
    return ComputeImpl.listJobs(this.client, filter);
  }
  async getJob(jobId) {
    return ComputeImpl.getJob(this.client, jobId);
  }
  async getJobStatus(jobId) {
    return ComputeImpl.getJobStatus(this.client, jobId);
  }
  async terminateJob(jobId) {
    return ComputeImpl.terminateJob(this.client, jobId);
  }
  async getUsage(filter) {
    return MeterImpl.getUsage(this.client, filter);
  }
  async getQuota() {
    return MeterImpl.getQuota(this.client);
  }
  async setQuota(params) {
    return MeterImpl.setQuota(this.client, params);
  }
  async getTokenBalance(identityId, tokenId) {
    return IdentityImpl.getTokenBalance(this.client, identityId, tokenId);
  }
  async mintToken(params) {
    return TokenImpl.mint(this.client, params);
  }
  async getToken(tokenId) {
    return TokenImpl.get(this.client, tokenId);
  }
  async searchTokens(filter) {
    return TokenImpl.search(this.client, filter);
  }
  async searchEscrowedAssets(filter) {
    return AssetImpl.search(this.client, filter);
  }
  async getEscrowedAsset(assetId) {
    return AssetImpl.get(this.client, assetId);
  }
  async transferToken(tokenId, amount, recipient) {
    return TokenImpl.transfer(this.client, tokenId, amount, recipient);
  }
  async getTransferReceipt(recieptId) {
    return TokenImpl.getTransferReceipt(this.client, recieptId);
  }
};
var src_default = Parcel;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ApiError,
  BackendClient,
  Capabilities,
  ClientType,
  FrontendClient,
  JobPhase,
  PARCEL_RUNTIME_AUD,
  Parcel,
  ServiceClient
});
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! (c) Stefan Thomas | https://github.com/bitcoinjs/bitcoinjs-lib
 */
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
/*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/*! CryptoJS v3.1.2 core-fix.js
 * code.google.com/p/crypto-js
 * (c) 2009-2013 by Jeff Mott. All rights reserved.
 * code.google.com/p/crypto-js/wiki/License
 * THIS IS FIX of 'core.js' to fix Hmac issue.
 * https://code.google.com/p/crypto-js/issues/detail?id=84
 * https://crypto-js.googlecode.com/svn-history/r667/branches/3.x/src/core.js
 */
/*! MIT License  Sindre Sorhus */
/*! Mike Samuel (c) 2009 | code.google.com/p/json-sans-eval
 */
