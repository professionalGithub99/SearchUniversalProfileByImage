/// <reference types="node" />
import type { WriteStream } from 'fs';
import type { Writable } from 'stream';
import FormData from 'form-data';
import type { BeforeRequestHook, NormalizedOptions, Options as KyOptions } from 'ky';
import ky, { HTTPError } from 'ky';
import type { PODDocument } from './document';
import type { JsonSerializable, Page } from './model.js';
import type { TokenProvider } from './token.js';
export declare type Config = Partial<{
    apiUrl: string;
    storageUrl: string;
    httpClientConfig: KyOptions;
}>;
export declare class HttpClient {
    private readonly tokenProvider;
    readonly apiUrl: string;
    readonly storageUrl: string;
    private readonly apiKy;
    constructor(tokenProvider: TokenProvider, config?: Config);
    get<T>(endpoint: string, params?: Record<string, string | number | Date | boolean | undefined>, requestOptions?: KyOptions): Promise<T>;
    upload(data: FormData, requestOptions?: KyOptions): Promise<PODDocument>;
    /** Convenience method for POSTing and expecting a 201 response */
    create<T>(endpoint: string, data: Record<string, JsonSerializable> | FormData | undefined, requestOptions?: KyOptions): Promise<T>;
    /** Convenience method for POSTing and expecting a 200 response */
    search<T>(baseEndpoint: string, // Without the `/search` suffix.
    params: Record<string, JsonSerializable> | undefined, requestOptions?: KyOptions): Promise<Page<T>>;
    post<T>(endpoint: string, data: Record<string, JsonSerializable> | FormData | undefined, requestOptions?: KyOptions): Promise<T>;
    update<T>(endpoint: string, params: Record<string, JsonSerializable>): Promise<T>;
    put<T>(endpoint: string, params: Record<string, JsonSerializable>): Promise<T>;
    delete(endpoint: string): Promise<void>;
    download(endpoint: string): Download;
}
declare module 'ky' {
    type Response = Readonly<globalThis.Response>;
}
/**
 * Workaround to fix `afterResponse` breaking >20MB file downloads.
 *
 * Ky clones the response when using afterResponse. Cloning causes requests to
 * stop requesting data after 2x highWaterMark (we use 10 MB) unless all clones
 * consume data at the same time. This workaround uses beforeRequest hook to
 * skip ky's fetch call + afterResponse handling, and reimplements both.
 *
 * WARNING: Use caution if modifying response.json or response.body in hooks. In
 * vanilla ky every hook receives its own clone of the response; with this
 * workaround, the same response object is passed to all hooks, so changes
 * propagate (somewhat mitigated by readonly fields on Response). In addition,
 * response.body can only be read once.
 *
 * Related issues:
 * - https://github.com/node-fetch/node-fetch#custom-highwatermark
 * - https://github.com/sindresorhus/ky-universal/issues/8
 * - https://github.com/sindresorhus/ky/issues/135
 * - https://github.com/node-fetch/node-fetch/issues/386
 *
 * TODO: remove if fixed by https://github.com/sindresorhus/ky/pull/356
 */
export declare function dontCloneForAfterResponses(): BeforeRequestHook;
/** Attaches a hook to end of hooks.beforeRequest (incl. after one-off hooks specified in the call to fetch(), e.g. setExpectedStatus) */
export declare function appendAsLastBeforeRequest(hookToSchedule: BeforeRequestHook): BeforeRequestHook;
export declare function addAllowedStatusCode(status: number): BeforeRequestHook;
/**
 * A `Download` is the result of calling `parcel.downloadDocument` or `document.download()`.
 *
 * The downloaded data can be read using async iterable `for await (const chunk of download)`,
 * or by calling `await download.pipeTo(sink)`.
 *
 * The download may be aborted by calling `download.destroy()`, as with any `Readable`.
 */
export declare class Download implements AsyncIterable<Uint8Array> {
    private readonly client;
    private readonly endpoint;
    private res?;
    private readonly abortController;
    constructor(client: typeof ky, endpoint: string);
    [Symbol.asyncIterator](): AsyncIterator<Uint8Array>;
    abort(): void;
    get aborted(): boolean;
    /**
     * Convenience method for piping to a sink and waiting for writing to finish.
     * This method must not be used alongside `getStream` or `AsyncIterable`.
     */
    pipeTo(sink: Writable | WriteStream | WritableStream): Promise<void>;
    /**
     * Lazily make the request. Helps avoid unhandled promise rejections when the request
     * fails before a pipe or iterator handler is attached.
     */
    private makeRequest;
}
export declare class ApiError extends HTTPError {
    name: string;
    readonly message: string;
    constructor(
    /** @see attachContext */
    request: Request & {
        context?: string;
    }, options: NormalizedOptions, response: Response, message: string);
    static fromHTTPError(error: HTTPError): Promise<ApiError>;
}
//# sourceMappingURL=http.d.ts.map