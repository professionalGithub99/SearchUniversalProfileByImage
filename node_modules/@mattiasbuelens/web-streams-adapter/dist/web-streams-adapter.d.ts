interface ReadableStreamLikeConstructor {
    new <R = any>(underlyingSource?: UnderlyingSource<R>, strategy?: QueuingStrategy<R>): ReadableStreamLike<R>;
}
interface ReadableByteStreamLikeConstructor extends ReadableStreamLikeConstructor {
    new (underlyingSource: UnderlyingByteSource, strategy?: {
        highWaterMark?: number;
        size?: undefined;
    }): ReadableByteStreamLike;
    new <R = any>(underlyingSource?: UnderlyingSource<R>, strategy?: QueuingStrategy<R>): ReadableStreamLike<R>;
}
interface ReadableStreamLike<R = any> {
    readonly locked: boolean;
    getReader(): ReadableStreamDefaultReader<R>;
}
interface ReadableByteStreamLike extends ReadableStreamLike<ArrayBufferView> {
    getReader(): ReadableStreamDefaultReader<ArrayBufferView>;
    getReader({ mode }: {
        mode: 'byob';
    }): ReadableStreamBYOBReader;
}
interface UnderlyingByteSource {
    start?: UnderlyingByteSourceStartCallback;
    pull?: UnderlyingByteSourcePullCallback;
    cancel?: UnderlyingSourceCancelCallback;
    type: 'bytes';
    autoAllocateChunkSize?: number;
}
declare type UnderlyingByteSourcePullCallback = (controller: ReadableByteStreamController) => void | PromiseLike<void>;
declare type UnderlyingByteSourceStartCallback = (controller: ReadableByteStreamController) => void | PromiseLike<void>;
interface ReadableByteStreamController {
    readonly byobRequest: ReadableStreamBYOBRequest | null;
    readonly desiredSize: number | null;
    close(): void;
    enqueue(chunk: ArrayBufferView): void;
    error(e?: any): void;
}
interface ReadableStreamBYOBRequest {
    readonly view: ArrayBufferView | null;
    respond(bytesWritten: number): void;
    respondWithNewView(view: ArrayBufferView): void;
}
interface ReadableStreamBYOBReader {
    readonly closed: Promise<void>;
    cancel(reason?: any): Promise<void>;
    read<T extends ArrayBufferView>(view: T): Promise<ReadableStreamBYOBReadResult<T>>;
    releaseLock(): void;
}
declare type ReadableStreamBYOBReadResult<T extends ArrayBufferView> = {
    done: boolean;
    value: T;
};
interface WritableStreamLikeConstructor {
    new <W = any>(underlyingSink?: UnderlyingSink<W>, strategy?: QueuingStrategy<W>): WritableStreamLike<W>;
}
interface WritableStreamLike<W = any> {
    readonly locked: boolean;
    getWriter(): WritableStreamDefaultWriter<W>;
}
interface TransformStreamLikeConstructor {
    new <I = any, O = any>(transformer?: Transformer<I, O>, writableStrategy?: QueuingStrategy<I>, readableStrategy?: QueuingStrategy<O>): TransformStreamLike<I, O>;
}
interface TransformStreamLike<I = any, O = any> {
    readonly writable: WritableStreamLike<I>;
    readonly readable: ReadableStreamLike<O>;
}

declare type ReadableStreamWrapper = <R>(readable: ReadableStreamLike<R>, options?: {
    type?: undefined;
}) => ReadableStreamLike<R>;
interface ReadableByteStreamWrapper {
    (readable: ReadableByteStreamLike, options: {
        type: 'bytes';
    }): ReadableByteStreamLike;
    <R>(readable: ReadableStreamLike<R>, options?: {
        type?: undefined;
    }): ReadableStreamLike<R>;
}
declare type TransformStreamWrapper = <I, O>(Transform: TransformStreamLike<I, O>) => TransformStreamLike<I, O>;
declare type WritableStreamWrapper = <W>(writable: WritableStreamLike<W>) => WritableStreamLike<W>;

declare function createReadableStreamWrapper(ctor: ReadableByteStreamLikeConstructor): ReadableByteStreamWrapper;
declare function createReadableStreamWrapper(ctor: ReadableStreamLikeConstructor): ReadableStreamWrapper;
declare function createWrappingReadableSource(readable: ReadableByteStreamLike, options: {
    type: 'bytes';
}): UnderlyingByteSource;
declare function createWrappingReadableSource<R = any>(readable: ReadableStreamLike<R>, options?: {
    type?: undefined;
}): UnderlyingSource<R>;

declare function createWritableStreamWrapper(ctor: WritableStreamLikeConstructor): WritableStreamWrapper;
declare function createWrappingWritableSink<W = any>(writable: WritableStreamLike<W>): UnderlyingSink<W>;

declare function createTransformStreamWrapper(ctor: TransformStreamLikeConstructor): TransformStreamWrapper;
declare function createWrappingTransformer<I = any, O = any>(transform: TransformStreamLike<I, O>): Transformer<I, O>;

export { ReadableByteStreamController, ReadableByteStreamLike, ReadableByteStreamLikeConstructor, ReadableByteStreamWrapper, ReadableStreamBYOBReadResult, ReadableStreamBYOBReader, ReadableStreamBYOBRequest, ReadableStreamLike, ReadableStreamLikeConstructor, ReadableStreamWrapper, TransformStreamLike, TransformStreamLikeConstructor, TransformStreamWrapper, UnderlyingByteSource, UnderlyingByteSourcePullCallback, UnderlyingByteSourceStartCallback, WritableStreamLike, WritableStreamLikeConstructor, WritableStreamWrapper, createReadableStreamWrapper, createTransformStreamWrapper, createWrappingReadableSource, createWrappingTransformer, createWrappingWritableSink, createWritableStreamWrapper };
