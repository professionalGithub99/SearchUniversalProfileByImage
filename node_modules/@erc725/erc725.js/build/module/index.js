/*
    This file is part of @erc725/erc725.js.
    @erc725/erc725.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    @erc725/erc725.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.
    You should have received a copy of the GNU Lesser General Public License
    along with @erc725/erc725.js.  If not, see <http://www.gnu.org/licenses/>.
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @file index.ts
 * @author Robert McLeod <@robertdavid010>, Fabian Vogelsteller <fabian@lukso.network>
 * @date 2020
 */
import { isAddress } from 'web3-utils';
import { Web3ProviderWrapper } from './providers/web3ProviderWrapper';
import { EthereumProviderWrapper } from './providers/ethereumProviderWrapper';
import { encodeArrayKey, getSchemaElement, decodeData, decodeKeyValue, decodeKey, isDataAuthentic, encodeData, } from './lib/utils';
import { SUPPORTED_HASH_FUNCTION_STRINGS } from './lib/constants';
export { flattenEncodedData, encodeData } from './lib/utils';
/**
 * :::warning
 * This package is currently in early stages of development, <br/>use only for testing or experimentation purposes.<br/>
 * :::
 *
 * @typeParam Schema **Work in progress, nothing to see here**.
 *
 */
export class ERC725 {
    /**
     * Creates an instance of ERC725.
     *
     * ```js reference title="Instantiation"
     * https://github.com/ERC725Alliance/erc725.js/tree/main/examples/src/instantiation.js#L1-L50
     * ```
     *
     * @param {ERC725JSONSchema[]} schema More information available here: [LSP-2-ERC725YJSONSchema](https://github.com/lukso-network/LIPs/blob/master/LSPs/LSP-2-ERC725YJSONSchema.md)
     * @param {string} address Address of the ERC725 contract you want to interact with
     * @param {any} provider
     * @param {ERC725Config} config Configuration object.
     *
     */
    constructor(schema, address, provider, config) {
        // NOTE: provider param can be either the provider, or and object with {provider:xxx ,type:xxx}
        // TODO: Add check for schema format?
        if (!schema) {
            throw new Error('Missing schema.');
        }
        const defaultConfig = {
            ipfsGateway: 'https://cloudflare-ipfs.com/ipfs/',
        };
        this.options = {
            schema,
            address,
            provider: this.initializeProvider(provider),
            config: Object.assign(Object.assign({}, defaultConfig), config),
        };
    }
    // eslint-disable-next-line class-methods-use-this
    initializeProvider(providerOrProviderWrapper) {
        // do not fail on no-provider
        if (!providerOrProviderWrapper)
            return undefined;
        if (typeof providerOrProviderWrapper.request === 'function')
            return new EthereumProviderWrapper(providerOrProviderWrapper);
        if (!providerOrProviderWrapper.request &&
            typeof providerOrProviderWrapper.send === 'function')
            return new Web3ProviderWrapper(providerOrProviderWrapper);
        if (providerOrProviderWrapper.type === "GRAPH_QL" /* GRAPH_QL */)
            return providerOrProviderWrapper;
        throw new Error(`Incorrect or unsupported provider ${providerOrProviderWrapper}`);
    }
    /**
     * Gets **decoded data** for one, many or all keys of the specified `ERC725` smart-contract.
     * When omitting the `keyOrKeys` parameter, it will get all the keys (as per {@link ERC725JSONSchema | ERC725JSONSchema} definition).
     *
     * :::caution
     * Data returned by this function does not contain external data of [`JSONURL`](https://github.com/lukso-network/LIPs/blob/master/LSPs/LSP-2-ERC725YJSONSchema.md#jsonurl)
     * or [`ASSETURL`](https://github.com/lukso-network/LIPs/blob/master/LSPs/LSP-2-ERC725YJSONSchema.md#asseturl) schema elements.
     *
     * If you would like to receive everything in one go, you can use {@link ERC725.fetchData | `fetchData`} for that.
     * :::
     *
     * @returns An object with schema element key names as properties, with corresponding **decoded** data as values.
     *
     * ```javascript reference title="getData - all keys from schema"
     * https://github.com/ERC725Alliance/erc725.js/tree/main/examples/src/getData.js#L7-L30
     * ```
     *
     * ```javascript reference title="getData - one key  "
     * https://github.com/ERC725Alliance/erc725.js/tree/main/examples/src/getData.js#L32-L41
     * ```
     *
     * ```javascript reference title="getData - many keys"
     * https://github.com/ERC725Alliance/erc725.js/tree/main/examples/src/getData.js#L43-L56
     * ```
     */
    getData(keyOrKeys) {
        return __awaiter(this, void 0, void 0, function* () {
            this.getAddressAndProvider();
            if (!keyOrKeys) {
                // eslint-disable-next-line no-param-reassign
                keyOrKeys = this.options.schema.map((element) => element.name);
            }
            if (Array.isArray(keyOrKeys)) {
                return this.getDataMultiple(keyOrKeys);
            }
            return this.getDataSingle(keyOrKeys);
        });
    }
    /**
     * Since {@link ERC725.getData | `getData`} exclusively returns data that is stored on the blockchain, `fetchData` comes in handy.
     * Additionally to the data from the blockchain, `fetchData` also returns data from IPFS or HTTP(s) endpoints
     * stored as [`JSONURL`](https://github.com/lukso-network/LIPs/blob/master/LSPs/LSP-2-ERC725YJSONSchema.md#jsonurl) or [`ASSETURL`](https://github.com/lukso-network/LIPs/blob/master/LSPs/LSP-2-ERC725YJSONSchema.md#asseturl).
     *
     * :::info
     * To ensure **data authenticity** `fetchData` compares the `hash` of the fetched JSON with the `hash` stored on the blockchain.
     * :::
     *
     * @param {string} keyOrKeys The name (or the encoded name as the schema ‘key’) of the schema element in the class instance’s schema.
     * @param {ERC725JSONSchema} customSchema An optional custom schema element to use for decoding the returned value. Overrides attached schema of the class instance on this call only.
     * @returns Returns the fetched and decoded value depending ‘valueContent’ for the schema element, otherwise works like getData
     *
     * ```javascript title="getData - all keys from schema"
     * https://github.com/ERC725Alliance/erc725.js/tree/main/examples/src/fetchData.js#L7-L35
     * ```
     *
     * ```javascript reference title="getData - one key  "
     * https://github.com/ERC725Alliance/erc725.js/tree/main/examples/src/fetchData.js#L37-L51
     * ```
     *
     * ```javascript reference title="getData - many keys"
     * https://github.com/ERC725Alliance/erc725.js/tree/main/examples/src/fetchData.js#L53-L71
     * ```
     */
    fetchData(keyOrKeys) {
        return __awaiter(this, void 0, void 0, function* () {
            const dataFromChain = yield this.getData(keyOrKeys);
            const dataFromExternalSources = yield this.getDataFromExternalSources(dataFromChain);
            return Object.assign(Object.assign({}, dataFromChain), dataFromExternalSources);
        });
    }
    getDataFromExternalSources(dataFromChain) {
        return Object.entries(dataFromChain)
            .filter(([key]) => {
            const keySchema = getSchemaElement(this.options.schema, key);
            return ['jsonurl', 'asseturl'].includes(keySchema.valueContent.toLowerCase());
        })
            .reduce((accumulator, [key, dataEntry]) => __awaiter(this, void 0, void 0, function* () {
            let receivedData;
            try {
                const { url } = this.patchIPFSUrlsIfApplicable(dataEntry);
                receivedData = yield fetch(url).then((response) => __awaiter(this, void 0, void 0, function* () {
                    if (dataEntry.hashFunction ===
                        SUPPORTED_HASH_FUNCTION_STRINGS.KECCAK256_BYTES) {
                        return response
                            .arrayBuffer()
                            .then((buffer) => new Uint8Array(buffer));
                    }
                    return response.json();
                }));
            }
            catch (error) {
                console.error(error, `GET request to ${dataEntry.url} failed`);
                throw error;
            }
            accumulator[key] = isDataAuthentic(receivedData, dataEntry.hash, dataEntry.hashFunction)
                ? receivedData
                : null;
            return accumulator;
        }), {});
    }
    encodeData(data) {
        return encodeData(data, this.options.schema);
    }
    decodeData(data) {
        return decodeData(data, this.options.schema);
    }
    /**
     * An added utility method which simply returns the owner of the contract.
     * Not directly related to ERC725 specifications.
     *
     * @param {string} [address]
     * @returns The address of the contract owner as stored in the contract.
     *
     * :::warning
     *    This method is not yet supported when using the `graph` provider type.
     * :::
     *
     * ```javascript title="Example"
     * await myERC725.getOwner();
     * // '0x94933413384997F9402cc07a650e8A34d60F437A'
     *
     * await myERC725.getOwner("0x3000783905Cc7170cCCe49a4112Deda952DDBe24");
     * // '0x7f1b797b2Ba023Da2482654b50724e92EB5a7091'
     * ```
     */
    getOwner(_address) {
        return __awaiter(this, void 0, void 0, function* () {
            const { address, provider } = this.getAddressAndProvider();
            return provider.getOwner(_address || address);
        });
    }
    /**
     * @internal
     * @param schema associated with the schema with keyType = 'Array'
     *               the data includes the raw (encoded) length key-value pair for the array
     * @param data array of key-value pairs, one of which is the length key for the schema array
     *             Data can hold other field data not relevant here, and will be ignored
     * @return an array of keys/values
     */
    getArrayValues(schema, data) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (schema.keyType !== 'Array') {
                throw new Error(`The "getArrayValues" method requires a schema definition with "keyType: Array",
         ${schema}`);
            }
            const results = [];
            // 1. get the array length
            const value = data[schema.key]; // get the length key/value pair
            if (!value || !value.value) {
                return results;
            } // Handle empty/non-existent array
            const arrayLength = yield decodeKeyValue('Number', 'uint256', value.value, schema.name); // get the int array length
            const arrayElementKeys = [];
            for (let index = 0; index < arrayLength; index++) {
                const arrayElementKey = encodeArrayKey(schema.key, index);
                if (!data[arrayElementKey]) {
                    arrayElementKeys.push(arrayElementKey);
                }
            }
            if (this.options.provider.type !== "GRAPH_QL" /* GRAPH_QL */) {
                try {
                    const arrayElements = yield ((_a = this.options.provider) === null || _a === void 0 ? void 0 : _a.getAllData(this.options.address, arrayElementKeys));
                    results.push(...arrayElements);
                }
                catch (err) {
                    // This case may happen if user requests an array key which does not exist in the contract.
                    // In this case, we simply skip
                }
                return results;
            }
            for (let index = 0; index < arrayElementKeys.length; index++) {
                // GraphQL provider has a different signature for getAllData(), it doesn't support `keys[]` parameter
                const arrayElement = yield ((_b = this.options.provider) === null || _b === void 0 ? void 0 : _b.getData(this.options.address, arrayElementKeys[index]));
                results.push({
                    key: arrayElementKeys[index],
                    value: arrayElement,
                });
            }
            return results;
        });
    }
    getDataSingle(data) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const keySchema = getSchemaElement(this.options.schema, data);
            const rawData = yield ((_a = this.options.provider) === null || _a === void 0 ? void 0 : _a.getData(this.options.address, keySchema.key));
            // Decode and return the data
            if (keySchema.keyType.toLowerCase() === 'array') {
                const dataKeyValue = {
                    [keySchema.key]: { key: keySchema.key, value: rawData },
                };
                const arrayValues = yield this.getArrayValues(keySchema, dataKeyValue);
                if (arrayValues && arrayValues.length > 0) {
                    arrayValues.push(dataKeyValue[keySchema.key]); // add the raw data array length
                    return {
                        [keySchema.name]: decodeKey(keySchema, arrayValues),
                    };
                }
                return { [keySchema.name]: [] }; // return empty object if there are no arrayValues
            }
            return {
                [keySchema.name]: decodeKey(keySchema, rawData),
            };
        });
    }
    getDataMultiple(keyNames) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const keyHashes = keyNames.map((keyName) => {
                const schemaElement = getSchemaElement(this.options.schema, keyName);
                return schemaElement.key;
            });
            // Get all the raw data from the provider based on schema key hashes
            const allRawData = yield ((_a = this.options.provider) === null || _a === void 0 ? void 0 : _a.getAllData(this.options.address, keyHashes));
            if (((_b = this.options.provider) === null || _b === void 0 ? void 0 : _b.type) === "GRAPH_QL" /* GRAPH_QL */) {
                // If the provider type is a graphql client, we assume it can get ALL keys (including array keys)
                return allRawData.reduce((accumulator, current) => {
                    accumulator[current.key] = current.value;
                    return accumulator;
                }, {});
            }
            const tmpData = allRawData.reduce((accumulator, current) => {
                accumulator[current.key] = current.value;
                return accumulator;
            }, {});
            // Get missing 'Array' fields for all arrays, as necessary
            const arraySchemas = this.options.schema.filter((e) => e.keyType.toLowerCase() === 'array');
            // eslint-disable-next-line no-restricted-syntax
            for (const keySchema of arraySchemas) {
                const dataKeyValue = {
                    [keySchema.key]: { key: keySchema.key, value: tmpData[keySchema.key] },
                };
                const arrayValues = yield this.getArrayValues(keySchema, dataKeyValue);
                if (arrayValues && arrayValues.length > 0) {
                    arrayValues.push(dataKeyValue[keySchema.key]); // add the raw data array length
                    tmpData[keySchema.key] = arrayValues;
                }
            }
            return decodeData(tmpData, this.options.schema);
        });
    }
    /**
     * Changes the protocol from `ipfs://` to `http(s)://` and adds the selected IPFS gateway.
     * `ipfs://QmbKvCVEePiDKxuouyty9bMsWBAxZDGr2jhxd4pLGLx95D => https://ipfs.lukso.network/ipfs/QmbKvCVEePiDKxuouyty9bMsWBAxZDGr2jhxd4pLGLx95D`
     */
    patchIPFSUrlsIfApplicable(receivedData) {
        if (receivedData &&
            receivedData.url &&
            receivedData.url.indexOf('ipfs://') !== -1) {
            return Object.assign(Object.assign({}, receivedData), { url: receivedData.url.replace('ipfs://', this.options.config.ipfsGateway) });
        }
        return receivedData;
    }
    getAddressAndProvider() {
        if (!isAddress(this.options.address)) {
            throw new Error('Missing ERC725 contract address.');
        }
        if (!this.options.provider) {
            throw new Error('Missing provider.');
        }
        return {
            address: this.options.address,
            provider: this.options.provider,
        };
    }
}
export default ERC725;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7OztFQVlFOzs7Ozs7Ozs7O0FBRUY7Ozs7R0FJRztBQUVILE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFFdkMsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDdEUsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFFOUUsT0FBTyxFQUNMLGNBQWMsRUFDZCxnQkFBZ0IsRUFDaEIsVUFBVSxFQUNWLGNBQWMsRUFDZCxTQUFTLEVBQ1QsZUFBZSxFQUNmLFVBQVUsR0FDWCxNQUFNLGFBQWEsQ0FBQztBQVdyQixPQUFPLEVBQUUsK0JBQStCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQVdsRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsVUFBVSxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQzdEOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLE9BQU8sTUFBTTtJQVFqQjs7Ozs7Ozs7Ozs7O09BWUc7SUFDSCxZQUNFLE1BQTBCLEVBQzFCLE9BQVEsRUFDUixRQUFjLEVBQ2QsTUFBcUI7UUFFckIsK0ZBQStGO1FBRS9GLHFDQUFxQztRQUNyQyxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ1gsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1NBQ3BDO1FBRUQsTUFBTSxhQUFhLEdBQUc7WUFDcEIsV0FBVyxFQUFFLG1DQUFtQztTQUNqRCxDQUFDO1FBRUYsSUFBSSxDQUFDLE9BQU8sR0FBRztZQUNiLE1BQU07WUFDTixPQUFPO1lBQ1AsUUFBUSxFQUFFLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLENBQUM7WUFDM0MsTUFBTSxrQ0FDRCxhQUFhLEdBQ2IsTUFBTSxDQUNWO1NBQ0YsQ0FBQztJQUNKLENBQUM7SUFFRCxrREFBa0Q7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