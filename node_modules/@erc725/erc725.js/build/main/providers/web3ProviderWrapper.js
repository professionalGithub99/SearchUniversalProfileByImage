"use strict";
/*
    This file is part of @erc725/erc725.js.
    @erc725/erc725.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    @erc725/erc725.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.
    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file providers/web3ProviderWrapper.ts
 * @author Robert McLeod <@robertdavid010>, Fabian Vogelsteller <fabian@lukso.network>
 * @date 2020
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Web3ProviderWrapper = void 0;
/*
  This file will handle querying the Ethereum web3 rpc based on a given provider
  in accordance with implementation of smart contract interfaces of ERC725
*/
const web3_eth_abi_1 = __importDefault(require("web3-eth-abi"));
const Method_1 = require("../types/Method");
const provider_wrapper_utils_1 = require("../lib/provider-wrapper-utils");
const constants_1 = require("../lib/constants");
// TS can't get the types from the import...
// @ts-ignore
const abiCoder = web3_eth_abi_1.default;
class Web3ProviderWrapper {
    constructor(provider) {
        this.type = "WEB3" /* WEB3 */;
        this.provider = provider;
    }
    async getOwner(address) {
        const result = await this.callContract(provider_wrapper_utils_1.constructJSONRPC(address, Method_1.Method.OWNER));
        if (result.error) {
            throw result.error;
        }
        return provider_wrapper_utils_1.decodeResult(Method_1.Method.OWNER, result);
    }
    async getErc725YVersion(address) {
        const isErc725Y = await this.supportsInterface(address, constants_1.INTERFACE_IDS.ERC725Y);
        if (isErc725Y) {
            return constants_1.ERC725_VERSION.ERC725;
        }
        const isErc725YLegacy = await this.supportsInterface(address, constants_1.INTERFACE_IDS.ERC725Y_LEGACY);
        return isErc725YLegacy
            ? constants_1.ERC725_VERSION.ERC725_LEGACY
            : constants_1.ERC725_VERSION.NOT_ERC725;
    }
    /**
     * https://eips.ethereum.org/EIPS/eip-165
     *
     * @param address the smart contract address
     * @param interfaceId ERC-165 identifier as described here: https://github.com/ERC725Alliance/ERC725/blob/develop/docs/ERC-725.md#specification
     */
    async supportsInterface(address, interfaceId) {
        return provider_wrapper_utils_1.decodeResult(Method_1.Method.SUPPORTS_INTERFACE, await this.callContract(provider_wrapper_utils_1.constructJSONRPC(address, Method_1.Method.SUPPORTS_INTERFACE, `${interfaceId}${'00000000000000000000000000000000000000000000000000000000'}`)));
    }
    async getData(address, keyHash) {
        const erc725Version = await this.getErc725YVersion(address);
        switch (erc725Version) {
            case 'ERC725': {
                return provider_wrapper_utils_1.decodeResult(Method_1.Method.GET_DATA, await this.callContract(provider_wrapper_utils_1.constructJSONRPC(address, Method_1.Method.GET_DATA, abiCoder.encodeParameter('bytes32[]', [keyHash]))))[0];
            }
            case 'ERC725_LEGACY': {
                return provider_wrapper_utils_1.decodeResult(Method_1.Method.GET_DATA_LEGACY, await this.callContract(provider_wrapper_utils_1.constructJSONRPC(address, Method_1.Method.GET_DATA_LEGACY, keyHash)));
            }
            default:
                throw new Error(`Contract: ${address} does not support ERC725Y interface.`);
        }
    }
    async getAllData(address, keys) {
        const erc725Version = await this.getErc725YVersion(address);
        if (erc725Version === 'NOT_ERC725') {
            throw new Error(`Contract: ${address} does not support ERC725Y interface.`);
        }
        const method = erc725Version === 'ERC725' ? Method_1.Method.GET_DATA : Method_1.Method.GET_DATA_LEGACY;
        const payload = [];
        for (let index = 0; index < keys.length; index++) {
            payload.push(provider_wrapper_utils_1.constructJSONRPC(address, method, erc725Version === 'ERC725'
                ? abiCoder.encodeParameter('bytes32[]', [keys[index]])
                : keys[index]));
        }
        const results = await this.callContract(payload);
        // map results to keys
        const returnValues = [];
        for (let index = 0; index < payload.length; index++) {
            const decodedValue = provider_wrapper_utils_1.decodeResult(method, results.find((element) => payload[index].id === element.id));
            returnValues.push({
                key: keys[index],
                value: erc725Version === 'ERC725' ? decodedValue[0] : decodedValue,
            });
        }
        return returnValues;
    }
    async callContract(payload) {
        return new Promise((resolve, reject) => {
            // Send old web3 method with callback to resolve promise
            this.provider.send(payload, (e, r) => {
                if (e) {
                    reject(e);
                }
                else {
                    resolve(r);
                }
            });
        });
    }
}
exports.Web3ProviderWrapper = Web3ProviderWrapper;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2ViM1Byb3ZpZGVyV3JhcHBlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wcm92aWRlcnMvd2ViM1Byb3ZpZGVyV3JhcHBlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7OztFQVlFO0FBQ0Y7Ozs7R0FJRzs7Ozs7O0FBRUg7OztFQUdFO0FBRUYsZ0VBQW9DO0FBR3BDLDRDQUF5QztBQUN6QywwRUFBK0U7QUFFL0UsZ0RBQWlFO0FBRWpFLDRDQUE0QztBQUM1QyxhQUFhO0FBQ2IsTUFBTSxRQUFRLEdBQXNCLHNCQUFRLENBQUM7QUFFN0MsTUFBYSxtQkFBbUI7SUFHOUIsWUFBWSxRQUFhO1FBQ3ZCLElBQUksQ0FBQyxJQUFJLG9CQUFxQixDQUFDO1FBQy9CLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0lBQzNCLENBQUM7SUFFRCxLQUFLLENBQUMsUUFBUSxDQUFDLE9BQWU7UUFDNUIsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUNwQyx5Q0FBZ0IsQ0FBQyxPQUFPLEVBQUUsZUFBTSxDQUFDLEtBQUssQ0FBQyxDQUN4QyxDQUFDO1FBQ0YsSUFBSSxNQUFNLENBQUMsS0FBSyxFQUFFO1lBQ2hCLE1BQU0sTUFBTSxDQUFDLEtBQUssQ0FBQztTQUNwQjtRQUVELE9BQU8scUNBQVksQ0FBQyxlQUFNLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQzVDLENBQUM7SUFFRCxLQUFLLENBQUMsaUJBQWlCLENBQUMsT0FBZTtRQUNyQyxNQUFNLFNBQVMsR0FBRyxNQUFNLElBQUksQ0FBQyxpQkFBaUIsQ0FDNUMsT0FBTyxFQUNQLHlCQUFhLENBQUMsT0FBTyxDQUN0QixDQUFDO1FBRUYsSUFBSSxTQUFTLEVBQUU7WUFDYixPQUFPLDBCQUFjLENBQUMsTUFBTSxDQUFDO1NBQzlCO1FBRUQsTUFBTSxlQUFlLEdBQUcsTUFBTSxJQUFJLENBQUMsaUJBQWlCLENB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