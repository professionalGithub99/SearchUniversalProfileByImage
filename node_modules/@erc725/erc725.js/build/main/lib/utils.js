"use strict";
/*
    This file is part of @erc725/erc725.js.
    @erc725/erc725.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    @erc725/erc725.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.
    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file lib/utils.ts
 * @author Robert McLeod <@robertdavid010>, Fabian Vogelsteller <fabian@lukso.network>
 * @date 2020
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.flattenEncodedData = exports.isDataAuthentic = exports.hashData = exports.getHashFunction = exports.encodeData = exports.decodeData = exports.decodeKey = exports.decodeKeyValue = exports.encodeKey = exports.getSchemaElement = exports.encodeKeyName = exports.guessKeyTypeFromKeyName = exports.encodeArrayKey = exports.encodeKeyValue = void 0;
const web3_utils_1 = require("web3-utils");
const constants_1 = require("./constants");
const encoder_1 = require("./encoder");
/**
 *
 * @param {string} valueContent as per ERC725Schema definition
 * @param {string} valueType as per ERC725Schema definition
 * @param value can contain single value, an array, or an object as required by schema (JSONURL, or ASSETURL)
 * @param {string} [name]
 * @return the encoded value as per the schema
 */
function encodeKeyValue(valueContent, valueType, value, name) {
    const isSupportedValueContent = encoder_1.valueContentEncodingMap[valueContent] || valueContent.substr(0, 2) === '0x';
    if (!isSupportedValueContent) {
        throw new Error(`The valueContent '${valueContent}' 
            for ${name} is not supported.`);
    }
    let result;
    const sameEncoding = encoder_1.valueContentEncodingMap[valueContent] &&
        encoder_1.valueContentEncodingMap[valueContent].type === valueType.split('[]')[0];
    const isArray = valueType.substr(valueType.length - 2) === '[]';
    // We only loop if the valueType done by abi.encodeParameter can not handle it directly
    if (Array.isArray(value) && !sameEncoding) {
        // value type encoding will handle it?
        // we handle an array element encoding
        const results = [];
        for (let index = 0; index < value.length; index++) {
            const element = value[index];
            results.push(encoder_1.encodeValueContent(valueContent, element));
        }
        result = results;
    }
    else if (!isArray && !Array.isArray(value)) {
        // Straight forward encode
        result = encoder_1.encodeValueContent(valueContent, value);
    }
    else if (sameEncoding) {
        result = value; // leaving this for below
    }
    if (
    // and we only skip bytes regardless
    valueType !== 'bytes' &&
        // Requires encoding because !sameEncoding means both encodings are required
        !sameEncoding) {
        result = encoder_1.encodeValueType(valueType, result);
    }
    else if (isArray && sameEncoding) {
        result = encoder_1.encodeValueType(valueType, result);
    }
    return result;
}
exports.encodeKeyValue = encodeKeyValue;
/**
 *
 * @param key The schema key of a schema with keyType = 'Array'
 * @param index An integer representing the intended array index
 * @return The raw bytes key for the array element
 */
function encodeArrayKey(key, index) {
    return key.substr(0, 34) + web3_utils_1.padLeft(web3_utils_1.numberToHex(index), 32).replace('0x', '');
}
exports.encodeArrayKey = encodeArrayKey;
/**
 *
 * @param keyName the schema key name
 * @returns a guess of the schema key type
 */
function guessKeyTypeFromKeyName(keyName) {
    // This function could not work with subsequents keys of an Array
    // It will always assume the given key, if array, is the initial array key.
    const splittedKeyName = keyName.split(':');
    if (splittedKeyName.length === 3) {
        return 'Bytes20MappingWithGrouping';
    }
    if (splittedKeyName.length === 2) {
        if (splittedKeyName[1].substr(0, 2) === '0x') {
            return 'Bytes20Mapping';
        }
        return 'Mapping';
    }
    if (keyName.substring(keyName.length - 2, keyName.length) === '[]') {
        return 'Array';
    }
    return 'Singleton';
}
exports.guessKeyTypeFromKeyName = guessKeyTypeFromKeyName;
/**
 *
 * @param name the schema element name
 * @return the name of the key encoded as per specifications
 * @return a string of the encoded schema name
 */
function encodeKeyName(name) {
    const keyType = guessKeyTypeFromKeyName(name);
    switch (keyType) {
        case 'Bytes20MappingWithGrouping': {
            // bytes4(keccak256(FirstWord)) + bytes4(0) + bytes2(keccak256(SecondWord)) + bytes2(0) + bytes20(address)
            const keyNameSplit = name.split(':');
            return (web3_utils_1.keccak256(keyNameSplit[0]).substr(0, 10) +
                '00000000' +
                web3_utils_1.keccak256(keyNameSplit[1]).substr(2, 4) +
                '0000' +
                keyNameSplit[2].substr(0, 40));
        }
        case 'Bytes20Mapping': {
            // bytes8(keccak256(FirstWord)) + bytes4(0) + bytes20(address)
            const keyNameSplit = name.split(':');
            return (web3_utils_1.keccak256(keyNameSplit[0]).substr(0, 18) +
                '00000000' +
                keyNameSplit[1].substr(2, 40));
        }
        case 'Mapping': {
            // bytes16(keccak256(FirstWord)) + bytes12(0) + bytes4(keccak256(LastWord))
            const keyNameSplit = name.split(':');
            return (web3_utils_1.keccak256(keyNameSplit[0]).substr(0, 34) +
                '000000000000000000000000' +
                web3_utils_1.keccak256(keyNameSplit[1]).substr(2, 8));
        }
        case 'Array': // Warning: this can not correctly encode subsequent keys of array, only the initial Array key will work
        case 'Singleton':
            return web3_utils_1.keccak256(name);
        default:
            return web3_utils_1.keccak256(name);
    }
}
exports.encodeKeyName = encodeKeyName;
/**
 *
 * @param schemas An array of ERC725JSONSchema objects
 * @param {string} key A string of either the schema element name, or key
 * @return The requested schema element from the full array of schemas
 */
function getSchemaElement(schemas, key) {
    const keyHash = key.substr(0, 2) === '0x' ? key : encodeKeyName(key);
    const schemaElement = schemas.find((e) => e.key === keyHash);
    if (!schemaElement) {
        throw new Error('No matching schema found for key: "' + key + '" (' + keyHash + ').');
    }
    return schemaElement;
}
exports.getSchemaElement = getSchemaElement;
/**
 *
 * @param schema is an object of a schema definitions
 * @param value will be either key-value pairs for a key type of Array, or a single value for type Singleton
 * @return the encoded value for the key as per the supplied schema
 */
function encodeKey(schema, value) {
    // NOTE: This will not guarantee order of array as on chain. Assumes developer must set correct order
    const lowerCaseKeyType = schema.keyType.toLowerCase();
    switch (lowerCaseKeyType) {
        case 'array': {
            if (!Array.isArray(value)) {
                console.error("Can't encode a non array for key of type array");
                return null;
            }
            const results = [];
            for (let index = 0; index < value.length; index++) {
                const dataElement = value[index];
                if (index === 0) {
                    // This is arrayLength as the first element in the raw array
                    results.push({
                        key: schema.key,
                        value: encodeKeyValue('Number', 'uint256', value.length.toString(), schema.name),
                    });
                }
                results.push({
                    key: encodeArrayKey(schema.key, index),
                    value: encodeKeyValue(schema.valueContent, schema.valueType, dataElement, schema.name),
                });
            }
            return results;
        }
        case 'bytes20mapping':
        case 'bytes20mappingwithgrouping':
        case 'singleton':
        case 'mapping':
            return encodeKeyValue(schema.valueContent, schema.valueType, value, schema.name);
        default:
            console.error('Incorrect data match or keyType in schema from encodeKey(): "' +
                schema.keyType +
                '"');
            return null;
    }
}
exports.encodeKey = encodeKey;
/**
 *
 * @param {string} valueContent as per ERC725Schema definition
 * @param {string} valueType as per ERC725Schema definition
 * @param {string} value the encoded value as string
 * @param {string} [name]
 * @return the decoded value as per the schema
 */
function decodeKeyValue(valueContent, valueType, value, name) {
    // Check for the missing map.
    if (!encoder_1.valueContentEncodingMap[valueContent] && valueContent.substr(0, 2) !== '0x') {
        throw new Error('The valueContent "' +
            valueContent +
            '" for "' +
            name +
            '" is not supported.');
    }
    let sameEncoding = encoder_1.valueContentEncodingMap[valueContent] &&
        encoder_1.valueContentEncodingMap[valueContent].type === valueType.split('[]')[0];
    const isArray = valueType.substr(valueType.length - 2) === '[]';
    // VALUE TYPE
    if (valueType !== 'bytes' && // we ignore because all is decoded by bytes to start with (abi)
        valueType !== 'string' &&
        !web3_utils_1.isAddress(value) // checks for addresses, since technically an address is bytes?
    ) {
        // eslint-disable-next-line no-param-reassign
        value = encoder_1.decodeValueType(valueType, value);
    }
    // As per exception above, if address and sameEncoding, then the address still needs to be handled
    if (sameEncoding && web3_utils_1.isAddress(value) && !web3_utils_1.checkAddressChecksum(value)) {
        sameEncoding = !sameEncoding;
    }
    if (sameEncoding && valueType !== 'string') {
        return value;
    }
    // VALUE CONTENT
    // We are finished if duplicated encoding methods
    if (isArray && Array.isArray(value)) {
        // value must be an array also
        const results = [];
        for (let index = 0; index < value.length; index++) {
            const element = value[index];
            results.push(encoder_1.decodeValueContent(valueContent, element));
        }
        return results;
    }
    return encoder_1.decodeValueContent(valueContent, value);
}
exports.decodeKeyValue = decodeKeyValue;
/**
 *
 * @param schema is an object of a schema definitions
 * @param value will be either key-value pairs for a key type of Array, or a single value for type Singleton
 * @return the decoded value/values as per the schema definition
 */
function decodeKey(schema, value) {
    const lowerCaseKeyType = schema.keyType.toLowerCase();
    switch (lowerCaseKeyType) {
        case 'array': {
            const results = [];
            // If user has requested a key which does not exist in the contract, value will be: 0x and value.find() will fail.
            if (!value || typeof value === 'string') {
                return results;
            }
            const valueElement = value.find((e) => e.key === schema.key);
            // Handle empty/non-existent array
            if (!valueElement) {
                return results;
            }
            const arrayLength = decodeKeyValue('Number', 'uint256', valueElement.value, schema.name) ||
                0;
            // This will not run if no match or arrayLength
            for (let index = 0; index < arrayLength; index++) {
                const dataElement = value.find((e) => e.key === encodeArrayKey(schema.key, index));
                if (dataElement) {
                    results.push(decodeKeyValue(schema.valueContent, schema.valueType, dataElement.value, schema.name));
                }
            } // end for loop
            return results;
        }
        case 'bytes20mapping':
        case 'bytes20mappingwithgrouping':
        case 'singleton':
        case 'mapping': {
            if (Array.isArray(value)) {
                const newValue = value.find((e) => e.key === schema.key);
                // Handle empty or non-values
                if (!newValue) {
                    return null;
                }
                return decodeKeyValue(schema.valueContent, schema.valueType, newValue.value, schema.name);
            }
            return decodeKeyValue(schema.valueContent, schema.valueType, value, schema.name);
        }
        default: {
            console.error('Incorrect data match or keyType in schema from decodeKey(): "' +
                schema.keyType +
                '"');
            return null;
        }
    }
}
exports.decodeKey = decodeKey;
/**
 *
 * @param schema schema is an array of objects of schema definitions
 * @param data data is an array of objects of key-value pairs
 * @return: all decoded data as per required by the schema and provided data
 */
function decodeData(data, schema) {
    return Object.entries(data).reduce((decodedData, [key, value]) => {
        const schemaElement = getSchemaElement(schema, key);
        return Object.assign(Object.assign({}, decodedData), { [schemaElement.name]: decodeKey(schemaElement, value) });
    }, {});
}
exports.decodeData = decodeData;
/**
 * @param schema an array of schema definitions as per ${@link ERC725JSONSchema}
 * @param data an object of key-value pairs
 */
function encodeData(data, schema) {
    return Object.entries(data).reduce((accumulator, [key, value]) => {
        const schemaElement = getSchemaElement(schema, key);
        accumulator[key] = {
            value: encodeKey(schemaElement, value),
            key: schemaElement.key,
        };
        return accumulator;
    }, {});
}
exports.encodeData = encodeData;
function getHashFunction(hashFunctionNameOrHash) {
    const hashFunction = constants_1.HASH_FUNCTIONS[hashFunctionNameOrHash];
    if (!hashFunction) {
        throw new Error(`Chosen hashFunction '${hashFunctionNameOrHash}' is not supported.
      Supported hashFunctions: ${constants_1.SUPPORTED_HASH_FUNCTIONS_LIST}
      `);
    }
    return hashFunction;
}
exports.getHashFunction = getHashFunction;
function hashData(data, hashFunctionNameOrHash) {
    const hashFunction = getHashFunction(hashFunctionNameOrHash);
    return hashFunction.method(data);
}
exports.hashData = hashData;
/**
 * Hashes the data received with the specified hashing function,
 * and compares the result with the provided hash.
 */
function isDataAuthentic(data, expectedHash, lowerCaseHashFunction) {
    const dataHash = hashData(data, lowerCaseHashFunction);
    if (dataHash !== expectedHash) {
        console.error(`Hash mismatch, returned JSON hash ("${dataHash}") is different from expected hash "${expectedHash}"`);
        return false;
    }
    return true;
}
exports.isDataAuthentic = isDataAuthentic;
/**
 * Transform the object containing the encoded data into an array ordered by keys,
 * for easier handling when writing the data to the blockchain.
 *
 * @param {{
 *   [key: string]: any;
 * }} encodedData This is essentially the object you receive when calling `encodeData(...)`
 * @return {*}  KeyValuePair[] An array of key-value objects
 */
function flattenEncodedData(encodedData) {
    return (Object.entries(encodedData)
        .reduce((keyValuePairs, [, encodedDataElement]) => {
        if (Array.isArray(encodedDataElement.value)) {
            return keyValuePairs.concat(encodedDataElement.value);
        }
        keyValuePairs.push({
            key: encodedDataElement.key,
            value: encodedDataElement.value,
        });
        return keyValuePairs;
    }, [])
        // sort array of objects by keys, to not be dependent on the order of the object's keys
        .sort((a, b) => {
        if (a.key < b.key)
            return -1;
        return a.key > b.key ? 1 : 0;
    }));
}
exports.flattenEncodedData = flattenEncodedData;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7O0VBWUU7QUFDRjs7OztHQUlHOzs7QUFFSCwyQ0FNb0I7QUFVcEIsMkNBSXFCO0FBQ3JCLHVDQU1tQjtBQUVuQjs7Ozs7OztHQU9HO0FBQ0gsU0FBZ0IsY0FBYyxDQUM1QixZQUFvQixFQUNwQixTQUFvQyxFQUNwQyxLQUFzRSxFQUN0RSxJQUFhO0lBRWIsTUFBTSx1QkFBdUIsR0FDM0IsaUNBQWUsQ0FBQyxZQUFZLENBQUMsSUFBSSxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUM7SUFFdEUsSUFBSSxDQUFDLHVCQUF1QixFQUFFO1FBQzVCLE1BQU0sSUFBSSxLQUFLLENBQ2IscUJBQXFCLFlBQVk7a0JBQ3JCLElBQUksb0JBQW9CLENBQ3JDLENBQUM7S0FDSDtJQUVELElBQUksTUFBTSxDQUFDO0lBQ1gsTUFBTSxZQUFZLEdBQ2hCLGlDQUFlLENBQUMsWUFBWSxDQUFDO1FBQzdCLGlDQUFlLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxLQUFLLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbEUsTUFBTSxPQUFPLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQztJQUVoRSx1RkFBdUY7SUFDdkYsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFO1FBQ3pDLHNDQUFzQztRQUV0QyxzQ0FBc0M7UUFDdEMsTUFBTSxPQUFPLEdBUVAsRUFBRSxDQUFDO1FBQ1QsS0FBSyxJQUFJLEtBQUssR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHLEtBQUssQ0FBQyxNQUFN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