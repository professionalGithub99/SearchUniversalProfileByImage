"use strict";
/*
    This file is part of @erc725/erc725.js.
    @erc725/erc725.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    @erc725/erc725.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.
    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file lib/utils.ts
 * @author Robert McLeod <@robertdavid010>, Fabian Vogelsteller <fabian@lukso.network>
 * @date 2020
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.flattenEncodedData = exports.isDataAuthentic = exports.hashData = exports.getHashFunction = exports.encodeData = exports.decodeData = exports.decodeKey = exports.decodeKeyValue = exports.encodeKey = exports.transposeArraySchema = exports.getSchemaElement = exports.encodeKeyName = exports.encodeArrayKey = exports.encodeKeyValue = void 0;
const web3_utils_1 = require("web3-utils");
const constants_1 = require("./constants");
const encoder_1 = require("./encoder");
/**
 *
 * @param schemaElementDefinition An object of the schema for this key
 * @param value can contain single value, or an object as required by schema (JSONURL, or ASSETURL)
 * @return the encoded value as per the schema
 */
function encodeKeyValue(schemaElementDefinition, value) {
    // Check if existing in the supported valueContent mapping.
    if (!encoder_1.valueContentEncodingMap[schemaElementDefinition.valueContent] &&
        schemaElementDefinition.valueContent.substr(0, 2) !== '0x') {
        throw new Error(`The valueContent '${schemaElementDefinition.valueContent} 
            for ${schemaElementDefinition.name} is not supported.`);
    }
    let result;
    const sameEncoding = encoder_1.valueContentEncodingMap[schemaElementDefinition.valueContent] &&
        encoder_1.valueContentEncodingMap[schemaElementDefinition.valueContent].type ===
            schemaElementDefinition.valueType.split('[]')[0];
    const isArray = schemaElementDefinition.valueType.substr(schemaElementDefinition.valueType.length - 2) === '[]';
    // We only loop if the valueType done by abi.encodeParameter can not handle it directly
    if (Array.isArray(value) && !sameEncoding) {
        // value type encoding will handle it?
        // we handle an array element encoding
        const results = [];
        for (let index = 0; index < value.length; index++) {
            const element = value[index];
            results.push(encoder_1.encodeValueContent(schemaElementDefinition.valueContent, element));
        }
        result = results;
    }
    else if (!isArray) {
        // Straight forward encode
        result = encoder_1.encodeValueContent(schemaElementDefinition.valueContent, value);
    }
    else if (sameEncoding) {
        result = value; // leaving this for below
    }
    if (
    // and we only skip bytes regardless
    schemaElementDefinition.valueType !== 'bytes' &&
        // Requires encoding because !sameEncoding means both encodings are required
        !sameEncoding) {
        result = encoder_1.encodeValueType(schemaElementDefinition.valueType, result);
    }
    else if (isArray && sameEncoding) {
        result = encoder_1.encodeValueType(schemaElementDefinition.valueType, result);
    }
    return result;
}
exports.encodeKeyValue = encodeKeyValue;
/**
 *
 * @param key The schema key of a schema with keyType = 'Array'
 * @param index An integer representing the intended array index
 * @return The raw bytes key for the array element
 */
function encodeArrayKey(key, index) {
    return key.substr(0, 34) + web3_utils_1.padLeft(web3_utils_1.numberToHex(index), 32).replace('0x', '');
}
exports.encodeArrayKey = encodeArrayKey;
/**
 *
 * @param name the schema element name
 * @return the name of the key encoded as per specifications
 * @return a string of the encoded schema name
 */
function encodeKeyName(name) {
    const colon = name.indexOf(':');
    // if name:subname, then construct using bytes16(hashFirstWord) + bytes12(0) + bytes4(hashLastWord)
    return colon !== -1
        ? web3_utils_1.keccak256(name.substr(0, colon)).substr(0, 34) +
            web3_utils_1.leftPad(web3_utils_1.keccak256(name.substr(colon + 1)).substr(2, 8), 32)
        : web3_utils_1.keccak256(name); // otherwise just bytes32(hash)
}
exports.encodeKeyName = encodeKeyName;
/**
 *
 * @param schemas An array of objects
 * @param {string} key A string of either the schema element name, or key
 * @return The requested schema element from the full array of schemas
 */
function getSchemaElement(schemas, key) {
    const keyHash = key.substr(0, 2) !== '0x' ? encodeKeyName(key) : key;
    const schemaElement = schemas.find((e) => e.key === keyHash);
    if (!schemaElement) {
        throw new Error('No matching schema found for key: "' + key + '" (' + keyHash + ').');
    }
    return schemaElement;
}
exports.getSchemaElement = getSchemaElement;
/**
 *
 * @param schema An object of a schema definition that must have a keyType of 'Array'
 * @param index The index of the array element to transpose the schema to
 * @return Modified schema element of keyType 'Singleton' for fetching or decoding/encoding the array element
 */
function transposeArraySchema(schema, index) {
    // Use enum ERC725JSONSchemaKeyType instead?
    if (schema.keyType.toLowerCase() !== 'array') {
        console.error('Schema is not of keyType "Array" for schema: "' + schema.name + '".');
    }
    return {
        name: schema.name,
        key: encodeArrayKey(schema.key, index),
        keyType: 'Singleton',
        // TODO: This can be solved by defining an extra "Erc725ArraySchema" for array
        // @ts-ignore
        valueContent: schema.elementValueContent,
        // @ts-ignore
        valueType: schema.elementValueType,
    };
}
exports.transposeArraySchema = transposeArraySchema;
/**
 *
 * @param schema is an object of a schema definitions
 * @param value will be either key-value pairs for a key type of Array, or a single value for type Singleton
 * @return the encoded value for the key as per the supplied schema
 */
function encodeKey(schema, value) {
    // NOTE: This will not guarantee order of array as on chain. Assumes developer must set correct order
    if (schema.keyType.toLowerCase() === 'array' && Array.isArray(value)) {
        const results = [];
        for (let index = 0; index < value.length; index++) {
            const dataElement = value[index];
            if (index === 0) {
                // This is arrayLength as the first element in the raw array
                results.push({
                    key: schema.key,
                    // @ts-ignore
                    value: encodeKeyValue(schema, value.length), // the array length
                });
            }
            const newSchema = transposeArraySchema(schema, index);
            results.push({
                key: newSchema.key,
                value: encodeKeyValue(newSchema, dataElement),
            });
        }
        return results;
    }
    if (schema.keyType.toLowerCase() === 'singleton' ||
        schema.keyType.toLowerCase() === 'mapping') {
        return encodeKeyValue(schema, value);
    }
    console.error('Incorrect data match or keyType in schema from encodeKey(): "' +
        schema.keyType +
        '"');
    return null;
}
exports.encodeKey = encodeKey;
/**
 *
 * @param schemaElementDefinition An object of the schema for this key
 * @param value the value to decode
 * @return the decoded value as per the schema
 */
function decodeKeyValue(schemaElementDefinition, value) {
    // Check for the missing map.
    if (!encoder_1.valueContentEncodingMap[schemaElementDefinition.valueContent] &&
        schemaElementDefinition.valueContent.substr(0, 2) !== '0x') {
        throw new Error('The valueContent "' +
            schemaElementDefinition.valueContent +
            '" for "' +
            schemaElementDefinition.name +
            '" is not supported.');
    }
    let sameEncoding = encoder_1.valueContentEncodingMap[schemaElementDefinition.valueContent] &&
        encoder_1.valueContentEncodingMap[schemaElementDefinition.valueContent].type ===
            schemaElementDefinition.valueType.split('[]')[0];
    const isArray = schemaElementDefinition.valueType.substr(schemaElementDefinition.valueType.length - 2) === '[]';
    // VALUE TYPE
    if (schemaElementDefinition.valueType !== 'bytes' && // we ignore because all is decoded by bytes to start with (abi)
        schemaElementDefinition.valueType !== 'string' &&
        !web3_utils_1.isAddress(value) // checks for addresses, since technically an address is bytes?
    ) {
        // eslint-disable-next-line no-param-reassign
        value = encoder_1.decodeValueType(schemaElementDefinition.valueType, value);
    }
    // As per exception above, if address and sameEncoding, then the address still needs to be handled
    if (sameEncoding && web3_utils_1.isAddress(value) && !web3_utils_1.checkAddressChecksum(value)) {
        sameEncoding = !sameEncoding;
    }
    if (sameEncoding && schemaElementDefinition.valueType !== 'string') {
        return value;
    }
    // VALUE CONTENT
    // We are finished if duplicated encoding methods
    if (isArray && Array.isArray(value)) {
        // value must be an array also
        const results = [];
        for (let index = 0; index < value.length; index++) {
            const element = value[index];
            results.push(encoder_1.decodeValueContent(schemaElementDefinition.valueContent, element));
        }
        return results;
    }
    return encoder_1.decodeValueContent(schemaElementDefinition.valueContent, value);
}
exports.decodeKeyValue = decodeKeyValue;
/**
 *
 * @param schema is an object of a schema definitions
 * @param value will be either key-value pairs for a key type of Array, or a single value for type Singleton
 * @return the decoded value/values as per the schema definition
 */
function decodeKey(schema, value) {
    if (schema.keyType.toLowerCase() === 'array') {
        const results = [];
        const valueElement = value.find((e) => e.key === schema.key);
        // Handle empty/non-existent array
        if (!valueElement) {
            return results;
        }
        const arrayLength = decodeKeyValue(schema, valueElement.value) || 0;
        // This will not run if no match or arrayLength
        for (let index = 0; index < arrayLength; index++) {
            const newSchema = transposeArraySchema(schema, index);
            const dataElement = value.find((e) => e.key === newSchema.key);
            if (dataElement) {
                results.push(decodeKeyValue(newSchema, dataElement.value));
            }
        } // end for loop
        return results;
    }
    if (schema.keyType.toLowerCase() === 'singleton' ||
        schema.keyType.toLowerCase() === 'mapping') {
        if (Array.isArray(value)) {
            const newValue = value.find((e) => e.key === schema.key);
            // Handle empty or non-values
            if (!newValue) {
                return null;
            }
            return decodeKeyValue(schema, newValue.value);
        }
        return decodeKeyValue(schema, value);
    }
    console.error('Incorrect data match or keyType in schema from decodeKey(): "' +
        schema.keyType +
        '"');
    return null;
}
exports.decodeKey = decodeKey;
/**
 *
 * @param schema schema is an array of objects of schema definitions
 * @param data data is an array of objects of key-value pairs
 * @return: all decoded data as per required by the schema and provided data
 */
function decodeData(data, schema) {
    return Object.entries(data).reduce((decodedData, [key, value]) => {
        const schemaElement = getSchemaElement(schema, key);
        return Object.assign(Object.assign({}, decodedData), { [schemaElement.name]: decodeKey(schemaElement, value) });
    }, {});
}
exports.decodeData = decodeData;
/**
 * @param schema an array of schema definitions as per ${@link ERC725JSONSchema}
 * @param data an object of key-value pairs
 */
function encodeData(data, schema) {
    return Object.entries(data).reduce((accumulator, [key, value]) => {
        const schemaElement = getSchemaElement(schema, key);
        accumulator[key] = {
            value: encodeKey(schemaElement, value),
            key: schemaElement.key,
        };
        return accumulator;
    }, {});
}
exports.encodeData = encodeData;
function getHashFunction(hashFunctionNameOrHash) {
    const hashFunction = constants_1.HASH_FUNCTIONS[hashFunctionNameOrHash];
    if (!hashFunction) {
        throw new Error(`Chosen hashFunction '${hashFunctionNameOrHash}' is not supported.
      Supported hashFunctions: ${constants_1.SUPPORTED_HASH_FUNCTIONS_LIST}
      `);
    }
    return hashFunction;
}
exports.getHashFunction = getHashFunction;
function hashData(data, hashFunctionNameOrHash) {
    const hashFunction = getHashFunction(hashFunctionNameOrHash);
    return hashFunction.method(data);
}
exports.hashData = hashData;
/**
 * Hashes the data received with the specified hashing function,
 * and compares the result with the provided hash.
 *
 * @throws *Error* in case of a mismatch of the hashes.
 */
function isDataAuthentic(data, expectedHash, lowerCaseHashFunction) {
    const jsonHash = hashData(data, lowerCaseHashFunction);
    if (jsonHash !== expectedHash) {
        console.error(`Hash mismatch, returned JSON hash ("${jsonHash}") is different from expected hash "${expectedHash}"`);
        return false;
    }
    return true;
}
exports.isDataAuthentic = isDataAuthentic;
/**
 * Transform the object containing the encoded data into an array ordered by keys,
 * for easier handling when writing the data to the blockchain.
 *
 * @param {{
 *   [key: string]: any;
 * }} encodedData This is essentially the object you receive when calling `encodeData(...)`
 * @return {*}  KeyValuePair[] An array of key-value objects
 */
function flattenEncodedData(encodedData) {
    return (Object.entries(encodedData)
        .reduce((keyValuePairs, [, encodedDataElement]) => {
        if (Array.isArray(encodedDataElement.value)) {
            return keyValuePairs.concat(encodedDataElement.value);
        }
        keyValuePairs.push({
            key: encodedDataElement.key,
            value: encodedDataElement.value,
        });
        return keyValuePairs;
    }, [])
        // sort array of objects by keys, to not be dependent on the order of the object's keys
        .sort((a, b) => {
        if (a.key < b.key)
            return -1;
        return a.key > b.key ? 1 : 0;
    }));
}
exports.flattenEncodedData = flattenEncodedData;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7O0VBWUU7QUFDRjs7OztHQUlHOzs7QUFFSCwyQ0FPb0I7QUFHcEIsMkNBSXFCO0FBRXJCLHVDQU1tQjtBQU9uQjs7Ozs7R0FLRztBQUNILFNBQWdCLGNBQWMsQ0FDNUIsdUJBQTJDLEVBQzNDLEtBQWE7SUFFYiwyREFBMkQ7SUFDM0QsSUFDRSxDQUFDLGlDQUFlLENBQUMsdUJBQXVCLENBQUMsWUFBWSxDQUFDO1FBQ3RELHVCQUF1QixDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLElBQUksRUFDMUQ7UUFDQSxNQUFNLElBQUksS0FBSyxDQUNiLHFCQUFxQix1QkFBdUIsQ0FBQyxZQUFZO2tCQUM3Qyx1QkFBdUIsQ0FBQyxJQUFJLG9CQUFvQixDQUM3RCxDQUFDO0tBQ0g7SUFFRCxJQUFJLE1BQU0sQ0FBQztJQUNYLE1BQU0sWUFBWSxHQUNoQixpQ0FBZSxDQUFDLHVCQUF1QixDQUFDLFlBQVksQ0FBQztRQUNyRCxpQ0FBZSxDQUFDLHVCQUF1QixDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUk7WUFDeEQsdUJBQXVCLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNyRCxNQUFNLE9BQU8sR0FDWCx1QkFBdUIsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUN0Qyx1QkFBdUIsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FDN0MsS0FBSyxJQUFJLENBQUM7SUFFYix1RkFBdUY7SUFDdkYsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFO1FBQ3pDLHNDQUFzQztRQUV0QyxzQ0FBc0M7UUFDdEMsTUFBTSxPQUFPLEdBQXVCLEVBQUUs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