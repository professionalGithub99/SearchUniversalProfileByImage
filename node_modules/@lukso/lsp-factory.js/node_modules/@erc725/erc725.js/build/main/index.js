"use strict";
/*
    This file is part of @erc725/erc725.js.
    @erc725/erc725.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    @erc725/erc725.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.
    You should have received a copy of the GNU Lesser General Public License
    along with @erc725/erc725.js.  If not, see <http://www.gnu.org/licenses/>.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERC725 = exports.encodeData = exports.flattenEncodedData = void 0;
/**
 * @file index.ts
 * @author Robert McLeod <@robertdavid010>, Fabian Vogelsteller <fabian@lukso.network>
 * @date 2020
 */
const web3_utils_1 = require("web3-utils");
const web3ProviderWrapper_1 = require("./providers/web3ProviderWrapper");
const ethereumProviderWrapper_1 = require("./providers/ethereumProviderWrapper");
const utils_1 = require("./lib/utils");
const constants_1 = require("./lib/constants");
var utils_2 = require("./lib/utils");
Object.defineProperty(exports, "flattenEncodedData", { enumerable: true, get: function () { return utils_2.flattenEncodedData; } });
Object.defineProperty(exports, "encodeData", { enumerable: true, get: function () { return utils_2.encodeData; } });
/**
 * :::warning
 * This package is currently in early stages of development, <br/>use only for testing or experimentation purposes.<br/>
 * :::
 *
 * @typeParam Schema **Work in progress, nothing to see here**.
 *
 */
class ERC725 {
    /**
     * Creates an instance of ERC725.
     *
     * ```js reference title="Instantiation"
     * https://github.com/ERC725Alliance/erc725.js/tree/main/examples/src/instantiation.js#L1-L50
     * ```
     *
     * @param {ERC725JSONSchema[]} schema More information available here: [LSP-2-ERC725YJSONSchema](https://github.com/lukso-network/LIPs/blob/master/LSPs/LSP-2-ERC725YJSONSchema.md)
     * @param {string} address Address of the ERC725 contract you want to interact with
     * @param {any} provider
     * @param {ERC725Config} config Configuration object.
     *
     */
    constructor(schema, address, provider, config) {
        // NOTE: provider param can be either the provider, or and object with {provider:xxx ,type:xxx}
        // TODO: Add check for schema format?
        if (!schema) {
            throw new Error('Missing schema.');
        }
        const defaultConfig = {
            ipfsGateway: 'https://cloudflare-ipfs.com/ipfs/',
        };
        this.options = {
            schema,
            address,
            provider: this.initializeProvider(provider),
            config: Object.assign(Object.assign({}, defaultConfig), config),
        };
    }
    // eslint-disable-next-line class-methods-use-this
    initializeProvider(providerOrProviderWrapper) {
        // do not fail on no-provider
        if (!providerOrProviderWrapper)
            return undefined;
        if (typeof providerOrProviderWrapper.request === 'function')
            return new ethereumProviderWrapper_1.EthereumProviderWrapper(providerOrProviderWrapper);
        if (!providerOrProviderWrapper.request &&
            typeof providerOrProviderWrapper.send === 'function')
            return new web3ProviderWrapper_1.Web3ProviderWrapper(providerOrProviderWrapper);
        if (providerOrProviderWrapper.type === "GRAPH_QL" /* GRAPH_QL */)
            return providerOrProviderWrapper;
        throw new Error(`Incorrect or unsupported provider ${providerOrProviderWrapper}`);
    }
    async getData(keyOrKeys) {
        this.getAddressAndProvider();
        if (!keyOrKeys) {
            // eslint-disable-next-line no-param-reassign
            keyOrKeys = this.options.schema.map((element) => element.name);
        }
        if (Array.isArray(keyOrKeys)) {
            return this.getDataMultiple(keyOrKeys);
        }
        return this.getDataSingle(keyOrKeys);
    }
    /**
     * Since {@link ERC725.getData | `getData`} exclusively returns data that is stored on the blockchain, `fetchData` comes in handy.
     * Additionally to the data from the blockchain, `fetchData` also returns data from IPFS or HTTP(s) endpoints
     * stored as [`JSONURL`](https://github.com/lukso-network/LIPs/blob/master/LSPs/LSP-2-ERC725YJSONSchema.md#jsonurl) or [`ASSETURL`](https://github.com/lukso-network/LIPs/blob/master/LSPs/LSP-2-ERC725YJSONSchema.md#asseturl).
     *
     * :::info
     * To ensure **data authenticity** `fetchData` compares the `hash` of the fetched JSON with the `hash` stored on the blockchain.
     * :::
     *
     * @param {string} keyOrKeys The name (or the encoded name as the schema ‘key’) of the schema element in the class instance’s schema.
     * @param {ERC725JSONSchema} customSchema An optional custom schema element to use for decoding the returned value. Overrides attached schema of the class instance on this call only.
     * @returns Returns the fetched and decoded value depending ‘valueContent’ for the schema element, otherwise works like getData
     *
     * ```javascript title="getData - all keys from schema"
     * https://github.com/ERC725Alliance/erc725.js/tree/main/examples/src/fetchData.js#L7-L35
     * ```
     *
     * ```javascript reference title="getData - one key  "
     * https://github.com/ERC725Alliance/erc725.js/tree/main/examples/src/fetchData.js#L37-L51
     * ```
     *
     * ```javascript reference title="getData - many keys"
     * https://github.com/ERC725Alliance/erc725.js/tree/main/examples/src/fetchData.js#L53-L71
     * ```
     */
    async fetchData(keyOrKeys) {
        const dataFromChain = await this.getData(keyOrKeys);
        const dataFromExternalSources = await this.getDataFromExternalSources(dataFromChain);
        return Object.assign(Object.assign({}, dataFromChain), dataFromExternalSources);
    }
    getDataFromExternalSources(dataFromChain) {
        return Object.entries(dataFromChain)
            .filter(([key]) => {
            const keySchema = utils_1.getSchemaElement(this.options.schema, key);
            return ['jsonurl', 'asseturl'].includes(keySchema.valueContent.toLowerCase());
        })
            .reduce(async (accumulator, [key, dataEntry]) => {
            let receivedData;
            try {
                const { url } = this.patchIPFSUrlsIfApplicable(dataEntry);
                receivedData = await fetch(url).then(async (response) => {
                    if (dataEntry.hashFunction ===
                        constants_1.SUPPORTED_HASH_FUNCTION_STRINGS.KECCAK256_BYTES) {
                        return response
                            .arrayBuffer()
                            .then((buffer) => new Uint8Array(buffer));
                    }
                    return response.json();
                });
            }
            catch (error) {
                console.error(error, `GET request to ${dataEntry.url} failed`);
                throw error;
            }
            accumulator[key] = utils_1.isDataAuthentic(receivedData, dataEntry.hash, dataEntry.hashFunction)
                ? receivedData
                : null;
            return accumulator;
        }, {});
    }
    encodeData(data) {
        return utils_1.encodeData(data, this.options.schema);
    }
    decodeData(data) {
        return utils_1.decodeData(data, this.options.schema);
    }
    /**
     * An added utility method which simply returns the owner of the contract.
     * Not directly related to ERC725 specifications.
     *
     * @param {string} [address]
     * @returns The address of the contract owner as stored in the contract.
     *
     * :::warning
     *    This method is not yet supported when using the `graph` provider type.
     * :::
     *
     * ```javascript title="Example"
     * await myERC725.getOwner();
     * // '0x94933413384997F9402cc07a650e8A34d60F437A'
     *
     * await myERC725.getOwner("0x3000783905Cc7170cCCe49a4112Deda952DDBe24");
     * // '0x7f1b797b2Ba023Da2482654b50724e92EB5a7091'
     * ```
     */
    async getOwner(_address) {
        const { address, provider } = this.getAddressAndProvider();
        return provider.getOwner(_address || address);
    }
    /**
     * @internal
     * @param schema associated with the schema with keyType = 'Array'
     *               the data includes the raw (encoded) length key-value pair for the array
     * @param data array of key-value pairs, one of which is the length key for the schema array
     *             Data can hold other field data not relevant here, and will be ignored
     * @return an array of keys/values
     */
    async getArrayValues(schema, data) {
        var _a;
        if (schema.keyType !== 'Array') {
            throw new Error(`The "_getArrayFields" method requires a schema definition with "keyType: Array",
        ${schema}`);
        }
        const results = [];
        // 1. get the array length
        const value = data[schema.key]; // get the length key/value pair
        if (!value || !value.value) {
            return results;
        } // Handle empty/non-existent array
        const arrayLength = await utils_1.decodeKeyValue(schema, value.value); // get the int array length
        // 2. Get the array values for the length of the array
        for (let index = 0; index < arrayLength; index++) {
            // 2.1 get the new schema key
            const arrayElementKey = utils_1.encodeArrayKey(schema.key, index);
            let arrayElement;
            // 2.2 Check the data first just in case.
            arrayElement = data[arrayElementKey];
            if (!arrayElement) {
                // 3. Otherwise we get the array key element value
                arrayElement = await ((_a = this.options.provider) === null || _a === void 0 ? void 0 : _a.getData(this.options.address, arrayElementKey));
                results.push({
                    key: arrayElementKey,
                    value: arrayElement,
                });
            }
        }
        return results;
    }
    async getDataSingle(data) {
        var _a;
        const keySchema = utils_1.getSchemaElement(this.options.schema, data);
        const rawData = await ((_a = this.options.provider) === null || _a === void 0 ? void 0 : _a.getData(this.options.address, keySchema.key));
        // Decode and return the data
        if (keySchema.keyType.toLowerCase() === 'array') {
            const dataKeyValue = {
                [keySchema.key]: { key: keySchema.key, value: rawData },
            };
            const arrayValues = await this.getArrayValues(keySchema, dataKeyValue);
            if (arrayValues && arrayValues.length > 0) {
                arrayValues.push(dataKeyValue[keySchema.key]); // add the raw data array length
                return {
                    [keySchema.name]: utils_1.decodeKey(keySchema, arrayValues),
                };
            }
            return {}; // return empty object if there are no arrayValues
        }
        return {
            [keySchema.name]: utils_1.decodeKey(keySchema, rawData),
        };
    }
    async getDataMultiple(keyNames) {
        var _a, _b;
        const keyHashes = keyNames.map((keyName) => {
            const schemaElement = utils_1.getSchemaElement(this.options.schema, keyName);
            return schemaElement.key;
        });
        // Get all the raw data from the provider based on schema key hashes
        const allRawData = await ((_a = this.options.provider) === null || _a === void 0 ? void 0 : _a.getAllData(this.options.address, keyHashes));
        if (((_b = this.options.provider) === null || _b === void 0 ? void 0 : _b.type) === "GRAPH_QL" /* GRAPH_QL */) {
            // If the provider type is a graphql client, we assume it can get ALL keys (including array keys)
            return allRawData.reduce((accumulator, current) => {
                accumulator[current.key] = current.value;
                return accumulator;
            }, {});
        }
        const tmpData = allRawData.reduce((accumulator, current) => {
            accumulator[current.key] = current.value;
            return accumulator;
        }, {});
        // Get missing 'Array' fields for all arrays, as necessary
        const arraySchemas = this.options.schema.filter((e) => e.keyType.toLowerCase() === 'array');
        // eslint-disable-next-line no-restricted-syntax
        for (const keySchema of arraySchemas) {
            const dataKeyValue = {
                [keySchema.key]: { key: keySchema.key, value: tmpData[keySchema.key] },
            };
            const arrayValues = await this.getArrayValues(keySchema, dataKeyValue);
            if (arrayValues && arrayValues.length > 0) {
                arrayValues.push(dataKeyValue[keySchema.key]); // add the raw data array length
                tmpData[keySchema.key] = arrayValues;
            }
        }
        return utils_1.decodeData(tmpData, this.options.schema);
    }
    /**
     * Changes the protocol from `ipfs://` to `http(s)://` and adds the selected IPFS gateway.
     * `ipfs://QmbKvCVEePiDKxuouyty9bMsWBAxZDGr2jhxd4pLGLx95D => https://ipfs.lukso.network/ipfs/QmbKvCVEePiDKxuouyty9bMsWBAxZDGr2jhxd4pLGLx95D`
     */
    patchIPFSUrlsIfApplicable(receivedData) {
        if (receivedData &&
            receivedData.url &&
            receivedData.url.indexOf('ipfs://') !== -1) {
            return Object.assign(Object.assign({}, receivedData), { url: receivedData.url.replace('ipfs://', this.options.config.ipfsGateway) });
        }
        return receivedData;
    }
    getAddressAndProvider() {
        if (!web3_utils_1.isAddress(this.options.address)) {
            throw new Error('Missing ERC725 contract address.');
        }
        if (!this.options.provider) {
            throw new Error('Missing provider.');
        }
        return {
            address: this.options.address,
            provider: this.options.provider,
        };
    }
}
exports.ERC725 = ERC725;
exports.default = ERC725;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7RUFZRTs7O0FBRUY7Ozs7R0FJRztBQUVILDJDQUF1QztBQUV2Qyx5RUFBc0U7QUFDdEUsaUZBQThFO0FBRTlFLHVDQVFxQjtBQVdyQiwrQ0FBa0U7QUFXbEUscUNBQTZEO0FBQXBELDJHQUFBLGtCQUFrQixPQUFBO0FBQUUsbUdBQUEsVUFBVSxPQUFBO0FBQ3ZDOzs7Ozs7O0dBT0c7QUFDSCxNQUFhLE1BQU07SUFRakI7Ozs7Ozs7Ozs7OztPQVlHO0lBQ0gsWUFDRSxNQUEwQixFQUMxQixPQUFRLEVBQ1IsUUFBYyxFQUNkLE1BQXFCO1FBRXJCLCtGQUErRjtRQUUvRixxQ0FBcUM7UUFDckMsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNYLE1BQU0sSUFBSSxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQztTQUNwQztRQUVELE1BQU0sYUFBYSxHQUFHO1lBQ3BCLFdBQVcsRUFBRSxtQ0FBbUM7U0FDakQsQ0FBQztRQUVGLElBQUksQ0FBQyxPQUFPLEdBQUc7WUFDYixNQUFNO1lBQ04sT0FBTztZQUNQLFFBQVEsRUFBRSxJQUFJLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDO1lBQzNDLE1BQU0sa0NBQ0QsYUFBYSxHQUNiLE1BQU0sQ0FDVjtTQUNGLENBQUM7SUFDSixDQUFDO0lBRUQsa0RBQWtEO0lBQzFDLGtCQUFrQixDQUFDLHlCQUF5QjtRQUNsRCw2QkFBNkI7UUFDN0IsSUFBSSxDQUFDLHlCQUF5QjtZQUFFLE9BQU8sU0FBUyxDQUFDO1FBRWpELElBQUksT0FBTyx5QkFBeUIsQ0FBQyxPQUFPLEtBQUssVUFBVTtZQUN6RCxPQUFPLElBQUksaURBQXVCLENBQUMseUJBQXlCLENBQUMsQ0FBQztRQUVoRSxJQUNFLENBQUMseUJBQXlCLENBQUMsT0FBTztZQUNsQyxPQUFPLHlCQUF5QixD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