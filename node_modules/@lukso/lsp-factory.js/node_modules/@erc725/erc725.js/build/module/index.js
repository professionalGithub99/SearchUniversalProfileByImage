/*
    This file is part of @erc725/erc725.js.
    @erc725/erc725.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    @erc725/erc725.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.
    You should have received a copy of the GNU Lesser General Public License
    along with @erc725/erc725.js.  If not, see <http://www.gnu.org/licenses/>.
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @file index.ts
 * @author Robert McLeod <@robertdavid010>, Fabian Vogelsteller <fabian@lukso.network>
 * @date 2020
 */
import { isAddress } from 'web3-utils';
import { Web3ProviderWrapper } from './providers/web3ProviderWrapper';
import { EthereumProviderWrapper } from './providers/ethereumProviderWrapper';
import { encodeArrayKey, getSchemaElement, decodeData, decodeKeyValue, decodeKey, isDataAuthentic, encodeData, } from './lib/utils';
import { SUPPORTED_HASH_FUNCTION_STRINGS } from './lib/constants';
export { flattenEncodedData, encodeData } from './lib/utils';
/**
 * :::warning
 * This package is currently in early stages of development, <br/>use only for testing or experimentation purposes.<br/>
 * :::
 *
 * @typeParam Schema **Work in progress, nothing to see here**.
 *
 */
export class ERC725 {
    /**
     * Creates an instance of ERC725.
     *
     * ```js reference title="Instantiation"
     * https://github.com/ERC725Alliance/erc725.js/tree/main/examples/src/instantiation.js#L1-L50
     * ```
     *
     * @param {ERC725JSONSchema[]} schema More information available here: [LSP-2-ERC725YJSONSchema](https://github.com/lukso-network/LIPs/blob/master/LSPs/LSP-2-ERC725YJSONSchema.md)
     * @param {string} address Address of the ERC725 contract you want to interact with
     * @param {any} provider
     * @param {ERC725Config} config Configuration object.
     *
     */
    constructor(schema, address, provider, config) {
        // NOTE: provider param can be either the provider, or and object with {provider:xxx ,type:xxx}
        // TODO: Add check for schema format?
        if (!schema) {
            throw new Error('Missing schema.');
        }
        const defaultConfig = {
            ipfsGateway: 'https://cloudflare-ipfs.com/ipfs/',
        };
        this.options = {
            schema,
            address,
            provider: this.initializeProvider(provider),
            config: Object.assign(Object.assign({}, defaultConfig), config),
        };
    }
    // eslint-disable-next-line class-methods-use-this
    initializeProvider(providerOrProviderWrapper) {
        // do not fail on no-provider
        if (!providerOrProviderWrapper)
            return undefined;
        if (typeof providerOrProviderWrapper.request === 'function')
            return new EthereumProviderWrapper(providerOrProviderWrapper);
        if (!providerOrProviderWrapper.request &&
            typeof providerOrProviderWrapper.send === 'function')
            return new Web3ProviderWrapper(providerOrProviderWrapper);
        if (providerOrProviderWrapper.type === "GRAPH_QL" /* GRAPH_QL */)
            return providerOrProviderWrapper;
        throw new Error(`Incorrect or unsupported provider ${providerOrProviderWrapper}`);
    }
    getData(keyOrKeys) {
        return __awaiter(this, void 0, void 0, function* () {
            this.getAddressAndProvider();
            if (!keyOrKeys) {
                // eslint-disable-next-line no-param-reassign
                keyOrKeys = this.options.schema.map((element) => element.name);
            }
            if (Array.isArray(keyOrKeys)) {
                return this.getDataMultiple(keyOrKeys);
            }
            return this.getDataSingle(keyOrKeys);
        });
    }
    /**
     * Since {@link ERC725.getData | `getData`} exclusively returns data that is stored on the blockchain, `fetchData` comes in handy.
     * Additionally to the data from the blockchain, `fetchData` also returns data from IPFS or HTTP(s) endpoints
     * stored as [`JSONURL`](https://github.com/lukso-network/LIPs/blob/master/LSPs/LSP-2-ERC725YJSONSchema.md#jsonurl) or [`ASSETURL`](https://github.com/lukso-network/LIPs/blob/master/LSPs/LSP-2-ERC725YJSONSchema.md#asseturl).
     *
     * :::info
     * To ensure **data authenticity** `fetchData` compares the `hash` of the fetched JSON with the `hash` stored on the blockchain.
     * :::
     *
     * @param {string} keyOrKeys The name (or the encoded name as the schema ‘key’) of the schema element in the class instance’s schema.
     * @param {ERC725JSONSchema} customSchema An optional custom schema element to use for decoding the returned value. Overrides attached schema of the class instance on this call only.
     * @returns Returns the fetched and decoded value depending ‘valueContent’ for the schema element, otherwise works like getData
     *
     * ```javascript title="getData - all keys from schema"
     * https://github.com/ERC725Alliance/erc725.js/tree/main/examples/src/fetchData.js#L7-L35
     * ```
     *
     * ```javascript reference title="getData - one key  "
     * https://github.com/ERC725Alliance/erc725.js/tree/main/examples/src/fetchData.js#L37-L51
     * ```
     *
     * ```javascript reference title="getData - many keys"
     * https://github.com/ERC725Alliance/erc725.js/tree/main/examples/src/fetchData.js#L53-L71
     * ```
     */
    fetchData(keyOrKeys) {
        return __awaiter(this, void 0, void 0, function* () {
            const dataFromChain = yield this.getData(keyOrKeys);
            const dataFromExternalSources = yield this.getDataFromExternalSources(dataFromChain);
            return Object.assign(Object.assign({}, dataFromChain), dataFromExternalSources);
        });
    }
    getDataFromExternalSources(dataFromChain) {
        return Object.entries(dataFromChain)
            .filter(([key]) => {
            const keySchema = getSchemaElement(this.options.schema, key);
            return ['jsonurl', 'asseturl'].includes(keySchema.valueContent.toLowerCase());
        })
            .reduce((accumulator, [key, dataEntry]) => __awaiter(this, void 0, void 0, function* () {
            let receivedData;
            try {
                const { url } = this.patchIPFSUrlsIfApplicable(dataEntry);
                receivedData = yield fetch(url).then((response) => __awaiter(this, void 0, void 0, function* () {
                    if (dataEntry.hashFunction ===
                        SUPPORTED_HASH_FUNCTION_STRINGS.KECCAK256_BYTES) {
                        return response
                            .arrayBuffer()
                            .then((buffer) => new Uint8Array(buffer));
                    }
                    return response.json();
                }));
            }
            catch (error) {
                console.error(error, `GET request to ${dataEntry.url} failed`);
                throw error;
            }
            accumulator[key] = isDataAuthentic(receivedData, dataEntry.hash, dataEntry.hashFunction)
                ? receivedData
                : null;
            return accumulator;
        }), {});
    }
    encodeData(data) {
        return encodeData(data, this.options.schema);
    }
    decodeData(data) {
        return decodeData(data, this.options.schema);
    }
    /**
     * An added utility method which simply returns the owner of the contract.
     * Not directly related to ERC725 specifications.
     *
     * @param {string} [address]
     * @returns The address of the contract owner as stored in the contract.
     *
     * :::warning
     *    This method is not yet supported when using the `graph` provider type.
     * :::
     *
     * ```javascript title="Example"
     * await myERC725.getOwner();
     * // '0x94933413384997F9402cc07a650e8A34d60F437A'
     *
     * await myERC725.getOwner("0x3000783905Cc7170cCCe49a4112Deda952DDBe24");
     * // '0x7f1b797b2Ba023Da2482654b50724e92EB5a7091'
     * ```
     */
    getOwner(_address) {
        return __awaiter(this, void 0, void 0, function* () {
            const { address, provider } = this.getAddressAndProvider();
            return provider.getOwner(_address || address);
        });
    }
    /**
     * @internal
     * @param schema associated with the schema with keyType = 'Array'
     *               the data includes the raw (encoded) length key-value pair for the array
     * @param data array of key-value pairs, one of which is the length key for the schema array
     *             Data can hold other field data not relevant here, and will be ignored
     * @return an array of keys/values
     */
    getArrayValues(schema, data) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (schema.keyType !== 'Array') {
                throw new Error(`The "_getArrayFields" method requires a schema definition with "keyType: Array",
        ${schema}`);
            }
            const results = [];
            // 1. get the array length
            const value = data[schema.key]; // get the length key/value pair
            if (!value || !value.value) {
                return results;
            } // Handle empty/non-existent array
            const arrayLength = yield decodeKeyValue(schema, value.value); // get the int array length
            // 2. Get the array values for the length of the array
            for (let index = 0; index < arrayLength; index++) {
                // 2.1 get the new schema key
                const arrayElementKey = encodeArrayKey(schema.key, index);
                let arrayElement;
                // 2.2 Check the data first just in case.
                arrayElement = data[arrayElementKey];
                if (!arrayElement) {
                    // 3. Otherwise we get the array key element value
                    arrayElement = yield ((_a = this.options.provider) === null || _a === void 0 ? void 0 : _a.getData(this.options.address, arrayElementKey));
                    results.push({
                        key: arrayElementKey,
                        value: arrayElement,
                    });
                }
            }
            return results;
        });
    }
    getDataSingle(data) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const keySchema = getSchemaElement(this.options.schema, data);
            const rawData = yield ((_a = this.options.provider) === null || _a === void 0 ? void 0 : _a.getData(this.options.address, keySchema.key));
            // Decode and return the data
            if (keySchema.keyType.toLowerCase() === 'array') {
                const dataKeyValue = {
                    [keySchema.key]: { key: keySchema.key, value: rawData },
                };
                const arrayValues = yield this.getArrayValues(keySchema, dataKeyValue);
                if (arrayValues && arrayValues.length > 0) {
                    arrayValues.push(dataKeyValue[keySchema.key]); // add the raw data array length
                    return {
                        [keySchema.name]: decodeKey(keySchema, arrayValues),
                    };
                }
                return {}; // return empty object if there are no arrayValues
            }
            return {
                [keySchema.name]: decodeKey(keySchema, rawData),
            };
        });
    }
    getDataMultiple(keyNames) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const keyHashes = keyNames.map((keyName) => {
                const schemaElement = getSchemaElement(this.options.schema, keyName);
                return schemaElement.key;
            });
            // Get all the raw data from the provider based on schema key hashes
            const allRawData = yield ((_a = this.options.provider) === null || _a === void 0 ? void 0 : _a.getAllData(this.options.address, keyHashes));
            if (((_b = this.options.provider) === null || _b === void 0 ? void 0 : _b.type) === "GRAPH_QL" /* GRAPH_QL */) {
                // If the provider type is a graphql client, we assume it can get ALL keys (including array keys)
                return allRawData.reduce((accumulator, current) => {
                    accumulator[current.key] = current.value;
                    return accumulator;
                }, {});
            }
            const tmpData = allRawData.reduce((accumulator, current) => {
                accumulator[current.key] = current.value;
                return accumulator;
            }, {});
            // Get missing 'Array' fields for all arrays, as necessary
            const arraySchemas = this.options.schema.filter((e) => e.keyType.toLowerCase() === 'array');
            // eslint-disable-next-line no-restricted-syntax
            for (const keySchema of arraySchemas) {
                const dataKeyValue = {
                    [keySchema.key]: { key: keySchema.key, value: tmpData[keySchema.key] },
                };
                const arrayValues = yield this.getArrayValues(keySchema, dataKeyValue);
                if (arrayValues && arrayValues.length > 0) {
                    arrayValues.push(dataKeyValue[keySchema.key]); // add the raw data array length
                    tmpData[keySchema.key] = arrayValues;
                }
            }
            return decodeData(tmpData, this.options.schema);
        });
    }
    /**
     * Changes the protocol from `ipfs://` to `http(s)://` and adds the selected IPFS gateway.
     * `ipfs://QmbKvCVEePiDKxuouyty9bMsWBAxZDGr2jhxd4pLGLx95D => https://ipfs.lukso.network/ipfs/QmbKvCVEePiDKxuouyty9bMsWBAxZDGr2jhxd4pLGLx95D`
     */
    patchIPFSUrlsIfApplicable(receivedData) {
        if (receivedData &&
            receivedData.url &&
            receivedData.url.indexOf('ipfs://') !== -1) {
            return Object.assign(Object.assign({}, receivedData), { url: receivedData.url.replace('ipfs://', this.options.config.ipfsGateway) });
        }
        return receivedData;
    }
    getAddressAndProvider() {
        if (!isAddress(this.options.address)) {
            throw new Error('Missing ERC725 contract address.');
        }
        if (!this.options.provider) {
            throw new Error('Missing provider.');
        }
        return {
            address: this.options.address,
            provider: this.options.provider,
        };
    }
}
export default ERC725;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7OztFQVlFOzs7Ozs7Ozs7O0FBRUY7Ozs7R0FJRztBQUVILE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFFdkMsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDdEUsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFFOUUsT0FBTyxFQUNMLGNBQWMsRUFDZCxnQkFBZ0IsRUFDaEIsVUFBVSxFQUNWLGNBQWMsRUFDZCxTQUFTLEVBQ1QsZUFBZSxFQUNmLFVBQVUsR0FDWCxNQUFNLGFBQWEsQ0FBQztBQVdyQixPQUFPLEVBQUUsK0JBQStCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQVdsRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsVUFBVSxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQzdEOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLE9BQU8sTUFBTTtJQVFqQjs7Ozs7Ozs7Ozs7O09BWUc7SUFDSCxZQUNFLE1BQTBCLEVBQzFCLE9BQVEsRUFDUixRQUFjLEVBQ2QsTUFBcUI7UUFFckIsK0ZBQStGO1FBRS9GLHFDQUFxQztRQUNyQyxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ1gsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1NBQ3BDO1FBRUQsTUFBTSxhQUFhLEdBQUc7WUFDcEIsV0FBVyxFQUFFLG1DQUFtQztTQUNqRCxDQUFDO1FBRUYsSUFBSSxDQUFDLE9BQU8sR0FBRztZQUNiLE1BQU07WUFDTixPQUFPO1lBQ1AsUUFBUSxFQUFFLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLENBQUM7WUFDM0MsTUFBTSxrQ0FDRCxhQUFhLEdBQ2IsTUFBTSxDQUNWO1NBQ0YsQ0FBQztJQUNKLENBQUM7SUFFRCxrREFBa0Q7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