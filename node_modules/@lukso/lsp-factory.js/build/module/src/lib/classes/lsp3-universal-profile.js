var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { NonceManager } from '@ethersproject/experimental';
import { concat, forkJoin, lastValueFrom, merge, of } from 'rxjs';
import { concatAll, scan } from 'rxjs/operators';
import contractVersions from '../../versions.json';
import { DEFAULT_CONTRACT_VERSION } from '../helpers/config.helper';
import { defaultUploadOptions } from '../helpers/config.helper';
import { ipfsUpload, prepareImageForLSP3 } from '../helpers/uploader.helper';
import { getUniversalProfileBaseContractAddresses$, universalProfileBaseContractsDeployment$, } from '../services/base-contract.service';
import { keyManagerDeployment$ } from '../services/key-manager.service';
import { accountDeployment$, getTransferOwnershipTransaction$, lsp3ProfileUpload$, setDataTransaction$, } from './../services/lsp3-account.service';
import { universalReceiverDelegateDeployment$ } from './../services/universal-receiver.service';
/**
 * TODO: docs
 */
export class LSP3UniversalProfile {
    constructor(options) {
        this.options = options;
        this.signer = new NonceManager(options.signer);
    }
    /**
     * TODO: docs
     */
    deployReactive(profileDeploymentOptions, contractDeploymentOptions) {
        var _a, _b, _c, _d, _e;
        // -1 > Run IPFS upload process in parallel with contract deployment
        const lsp3Profile$ = lsp3ProfileUpload$(profileDeploymentOptions.lsp3Profile);
        // 0 > Check for existing base contracts and deploy
        const defaultUPBaseContractAddress = (_b = (_a = contractVersions[this.options.chainId]) === null || _a === void 0 ? void 0 : _a.baseContracts) === null || _b === void 0 ? void 0 : _b.ERC725Account[DEFAULT_CONTRACT_VERSION];
        const defaultUniversalReceiverBaseContractAddress = (_d = (_c = contractVersions[this.options.chainId]) === null || _c === void 0 ? void 0 : _c.baseContracts) === null || _d === void 0 ? void 0 : _d.UniversalReceiverDelegate[DEFAULT_CONTRACT_VERSION];
        const defaultBaseContractByteCode$ = forkJoin([
            this.getDeployedByteCode(defaultUPBaseContractAddress !== null && defaultUPBaseContractAddress !== void 0 ? defaultUPBaseContractAddress : '0x0000000000000000000000000000000000000000'),
            this.getDeployedByteCode(defaultUniversalReceiverBaseContractAddress !== null && defaultUniversalReceiverBaseContractAddress !== void 0 ? defaultUniversalReceiverBaseContractAddress : '0x0000000000000000000000000000000000000000'),
        ]);
        const baseContractAddresses$ = getUniversalProfileBaseContractAddresses$(defaultUPBaseContractAddress, defaultUniversalReceiverBaseContractAddress, defaultBaseContractByteCode$, this.signer, contractDeploymentOptions);
        const controllerAddresses = profileDeploymentOptions.controllingAccounts.map((controller) => {
            return typeof controller === 'string' ? controller : controller.address;
        });
        // 1 > deploys ERC725Account
        const account$ = accountDeployment$(this.signer, controllerAddresses, baseContractAddresses$);
        // 2 > deploys KeyManager
        const keyManager$ = keyManagerDeployment$(this.signer, account$, (_e = contractDeploymentOptions === null || contractDeploymentOptions === void 0 ? void 0 : contractDeploymentOptions.libAddresses) === null || _e === void 0 ? void 0 : _e.keyManagerInit);
        // 3 > deploys UniversalReceiverDelegate
        const universalReceiver$ = universalReceiverDelegateDeployment$(this.signer, account$, baseContractAddresses$);
        // 4 > set permissions, profile and universal
        const setData$ = setDataTransaction$(this.signer, account$, universalReceiver$, profileDeploymentOptions.controllingAccounts, lsp3Profile$);
        // 5 > transfersOwnership to KeyManager
        const transferOwnership$ = getTransferOwnershipTransaction$(this.signer, account$, keyManager$);
        return concat([
            account$,
            merge(universalReceiver$, keyManager$),
            setData$,
            transferOwnership$,
        ]).pipe(concatAll());
    }
    /**
     * TODO: docs
     */
    deploy(profileDeploymentOptions, contractDeploymentOptions) {
        const deployments$ = this.deployReactive(profileDeploymentOptions, contractDeploymentOptions).pipe(scan((accumulator, deploymentEvent) => {
            if (deploymentEvent.receipt && deploymentEvent.receipt.contractAddress) {
                accumulator[deploymentEvent.contractName] = {
                    address: deploymentEvent.receipt.contractAddress,
                    receipt: deploymentEvent.receipt,
                };
            }
            return accumulator;
        }, {}));
        return lastValueFrom(deployments$);
    }
    getDeployedByteCode(contractAddress) {
        return this.options.provider.getCode(contractAddress);
    }
    deployBaseContracts() {
        const baseContractsToDeploy$ = of([true, true]);
        const baseContracts$ = universalProfileBaseContractsDeployment$(this.signer, baseContractsToDeploy$);
        const deployments$ = baseContracts$.pipe(scan((accumulator, deploymentEvent) => {
            if (deploymentEvent.receipt && deploymentEvent.receipt.contractAddress) {
                accumulator[deploymentEvent.contractName] = {
                    address: deploymentEvent.receipt.contractAddress,
                    receipt: deploymentEvent.receipt,
                };
            }
            return accumulator;
        }, {}));
        return lastValueFrom(deployments$);
    }
    /**
     * Pre-deploys the latest Version of the LSP3UniversalProfile smart-contracts.
     *
     * @param {'string'} [version] Instead of deploying the latest Version you can also deploy a specific
     *  version of the smart-contracts. A list of all available version is available here.
     */
    preDeployContracts(version) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(version);
        });
    }
    /**
     * Uploads the LSP3Profile to the desired endpoint. This can be an `https` URL either pointing to
     * a public, centralized storage endpoint or an IPFS Node / Cluster
     *
     * @param {ProfileDataBeforeUpload} profileData
     * @return {*}  {(Promise<AddResult | string>)}
     * @memberof LSP3UniversalProfile
     */
    static uploadProfileData(profileData, uploadOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            uploadOptions = uploadOptions || defaultUploadOptions;
            const [profileImage, backgroundImage] = yield Promise.all([
                prepareImageForLSP3(uploadOptions, profileData.profileImage),
                prepareImageForLSP3(uploadOptions, profileData.backgroundImage),
            ]);
            const profile = {
                LSP3Profile: Object.assign(Object.assign({}, profileData), { profileImage,
                    backgroundImage }),
            };
            // TODO: allow simple http upload too
            const uploadResponse = yield ipfsUpload(JSON.stringify(profile), uploadOptions.ipfsClientOptions);
            return {
                profile,
                url: uploadResponse.cid ? 'ipfs://' + uploadResponse.cid : 'https upload TBD',
            };
        });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHNwMy11bml2ZXJzYWwtcHJvZmlsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY2xhc3Nlcy9sc3AzLXVuaXZlcnNhbC1wcm9maWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUMzRCxPQUFPLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxhQUFhLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNsRSxPQUFPLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRWpELE9BQU8sZ0JBQWdCLE1BQU0scUJBQXFCLENBQUM7QUFDbkQsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDcEUsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDaEUsT0FBTyxFQUFFLFVBQVUsRUFBRSxtQkFBbUIsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBVTdFLE9BQU8sRUFDTCx5Q0FBeUMsRUFDekMsd0NBQXdDLEdBQ3pDLE1BQU0sbUNBQW1DLENBQUM7QUFDM0MsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFFeEUsT0FBTyxFQUNMLGtCQUFrQixFQUNsQixnQ0FBZ0MsRUFDaEMsa0JBQWtCLEVBQ2xCLG1CQUFtQixHQUNwQixNQUFNLG9DQUFvQyxDQUFDO0FBQzVDLE9BQU8sRUFBRSxvQ0FBb0MsRUFBRSxNQUFNLDBDQUEwQyxDQUFDO0FBRWhHOztHQUVHO0FBQ0gsTUFBTSxPQUFPLG9CQUFvQjtJQUcvQixZQUFZLE9BQTBCO1FBQ3BDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxZQUFZLENBQUMsT0FBTyxDQUFDLE1BQU0s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